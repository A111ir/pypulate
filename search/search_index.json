{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pypulate Documentation","text":"<p>Pypulate framework</p> <p>High performance financial and business analytics framework</p> <p> </p> <p>Welcome to Pypulate, a high-performance Python framework for financial analysis and business metrics. Pypulate offers powerful classes designed to handle different aspects of financial and business analytics (more to come):</p>"},{"location":"#core-components","title":"Core Components","text":""},{"location":"#parray-pypulate-array","title":"Parray (Pypulate Array)","text":"<p>A specialized array class for financial time series analysis with built-in technical analysis capabilities and chain methodss:</p> <pre><code>from pypulate import Parray\n\n# Create a price array\nprices = Parray([10, 11, 12, 11, 10, 9, 10, 11, 12, 13, 15, 11, 8, 10, 14, 16])\n\n# Technical Analysis\nsma = prices.sma(5)                   \nrsi = prices.rsi(14)                  \nbb_upper, bb_mid, bb_lower = prices.bollinger_bands(20, 2)\n\n# Signal Detection\ngolden_cross = prices.sma(5).crossover(prices.sma(10))\ndeath_cross = prices.sma(5).crossunder(prices.sma(10))\n\n# Volatility Analysis\nvolatility = prices.historical_volatility(7)\n</code></pre>"},{"location":"#kpi-key-performance-indicators","title":"KPI (Key Performance Indicators)","text":"<p>A comprehensive class for calculating and tracking business metrics:</p> <pre><code>from pypulate import KPI\n\nkpi = KPI()\n\n# Customer Metrics\nchurn = kpi.churn_rate(customers_start=1000, customers_end=950, new_customers=50)\nretention = kpi.retention_rate(customers_start=1000, customers_end=950, new_customers=50)\n\n# Financial Metrics\nclv = kpi.customer_lifetime_value(\n    avg_revenue_per_customer=100,\n    gross_margin=70,\n    churn_rate_value=5\n)\n\n# Health Assessment\nhealth = kpi.health  # Returns overall business health score and component analysis\n</code></pre>"},{"location":"#portfolio","title":"Portfolio","text":"<p>A class for portfolio analysis and risk management:</p> <pre><code>from pypulate import Portfolio\nimport numpy as np\n\nportfolio = Portfolio()\n\n# Sample data\nstart = [100, 102, 105, 103, 107, 108, 107, 110, 112, 111]\nend = [110, 95, 111, 103, 130, 89, 99, 104, 102, 100]\n\ncash_flows = [0, -1000, 0, 500, 0, -2000, 0, 1000, 0, 0]\nrisk_free_rate = 0.02\n\n# Return Metrics\nreturns = portfolio.simple_return(end, start)\nlog_ret = portfolio.log_return(end, start)\n\n# Risk Metrics\nsharpe = portfolio.sharpe_ratio(returns, risk_free_rate)\nvar = portfolio.value_at_risk(returns, confidence_level=0.95)\ndd = portfolio.drawdown(returns)\n\n# Portfolio Health\nhealth = portfolio.health  # Returns portfolio health analysis\n</code></pre>"},{"location":"#allocation","title":"Allocation","text":"<p>A comprehensive class for portfolio optimization and asset allocation:</p> <pre><code>from pypulate import Allocation\nimport numpy as np\n\nallocation = Allocation()\n\n# Sample returns data (252 days, 5 assets)\nreturns = np.random.normal(0.0001, 0.02, (252, 5))\nrisk_free_rate = 0.04\n\n# Mean-Variance Optimization\nweights, ret, risk = allocation.mean_variance(returns, risk_free_rate=risk_free_rate)\n\n# Risk Parity Portfolio\nweights, ret, risk = allocation.risk_parity(returns)\n\n# Kelly Criterion (with half-Kelly for conservative sizing)\nweights, ret, risk = allocation.kelly_criterion(returns, kelly_fraction=0.5)\n\n# Black-Litterman with views\nviews = {0: 0.15, 1: 0.12}  # Views on first two assets\nview_confidences = {0: 0.8, 1: 0.7}\nmarket_caps = np.array([1000, 800, 600, 400, 200])\nweights, ret, risk = allocation.black_litterman(\n    returns, market_caps, views, view_confidences\n)\n\n# Hierarchical Risk Parity\nweights, ret, risk = allocation.hierarchical_risk_parity(returns)\n</code></pre>"},{"location":"#servicepricing","title":"ServicePricing","text":"<p>A unified interface for calculating and managing various service pricing models:</p> <pre><code>from pypulate import ServicePricing\n\npricing = ServicePricing()\n\n# Tiered Pricing\nprice = pricing.calculate_tiered_price(\n    usage_units=1500,\n    tiers={\n        \"0-1000\": 0.10,    # $0.10 per unit for first 1000 units\n        \"1001-2000\": 0.08, # $0.08 per unit for next 500 units\n        \"2001+\": 0.05      # $0.05 per unit for remaining units\n    }\n)\n\n# Subscription with Features\nsub_price = pricing.calculate_subscription_price(\n    base_price=99.99,\n    features=['premium', 'api_access'],\n    feature_prices={'premium': 49.99, 'api_access': 29.99},\n    duration_months=12,\n    discount_rate=0.10\n)\n\n# Dynamic Pricing\ndynamic_price = pricing.apply_dynamic_pricing(\n    base_price=100.0,\n    demand_factor=1.2,\n    competition_factor=0.9,\n    seasonality_factor=1.1\n)\n\n# Track Pricing History\npricing.save_current_pricing()\nhistory = pricing.get_pricing_history()\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pypulate\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Parray: </li> <li>Technical indicators (30+ implementations)</li> <li>Signal detection and pattern recognition</li> <li>Time series transformations</li> <li> <p>Built-in filtering methods</p> </li> <li> <p>KPI:</p> </li> <li>Customer metrics (churn, retention, LTV)</li> <li>Financial metrics (ROI, CAC, ARR)</li> <li>Engagement metrics (NPS, CSAT)</li> <li> <p>Health scoring system</p> </li> <li> <p>Portfolio:</p> </li> <li>Return calculations</li> <li>Risk metrics</li> <li>Performance attribution</li> <li> <p>Health assessment</p> </li> <li> <p>Allocation:</p> </li> <li>Portfolio optimization</li> <li>Asset allocation</li> <li> <p>Risk management</p> </li> <li> <p>ServicePricing:</p> </li> <li>Tiered pricing models</li> <li>Subscription pricing with features</li> <li>Usage-based pricing</li> <li>Dynamic pricing adjustments</li> <li>Volume discounts</li> <li>Custom pricing rules</li> <li>Pricing history tracking</li> </ul>"},{"location":"#user-guide","title":"User Guide","text":"<ul> <li>Getting Started</li> <li>Parray Guide</li> <li>KPI Guide</li> <li>Portfolio Guide</li> <li>Service Pricing Guide</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please feel free to submit a Pull Request.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Initial release of Pypulate</li> <li>Parray class for method chaining</li> <li>21 different moving average implementations</li> <li>Wave and zigzag pattern detection</li> <li>Business KPI module with 26 different metrics</li> <li>Comprehensive documentation</li> </ul>"},{"location":"changelog/#010-yyyy-mm-dd","title":"[0.1.0] - YYYY-MM-DD","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Initial release </li> </ul>"},{"location":"contributing/","title":"Contributing to Pypulate","text":"<p>Thank you for considering contributing to Pypulate! This document provides guidelines and instructions for contributing to the project.</p>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please be respectful and considerate of others when contributing to this project. We aim to foster an inclusive and welcoming community.</p>"},{"location":"contributing/#how-to-contribute","title":"How to Contribute","text":"<p>There are many ways to contribute to Pypulate:</p> <ol> <li> <p>Report bugs: If you find a bug, please create an issue on GitHub with a detailed description of the problem, including steps to reproduce it.</p> </li> <li> <p>Suggest features: If you have an idea for a new feature or improvement, please create an issue on GitHub to discuss it.</p> </li> <li> <p>Contribute code: If you want to contribute code, please follow the steps below.</p> </li> </ol>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<ol> <li> <p>Fork the repository on GitHub.</p> </li> <li> <p>Clone your fork locally:    <pre><code>git clone https://github.com/yourusername/pypulate.git\ncd pypulate\n</code></pre></p> </li> <li> <p>Create a virtual environment and install development dependencies:    <pre><code>python -m venv .venv\nsource .venv/bin/activate  # On Windows, use: .venv\\Scripts\\activate\npip install -e \".[dev]\"\n</code></pre></p> </li> <li> <p>Create a branch for your changes:    <pre><code>git checkout -b feature/your-feature-name\n</code></pre></p> </li> </ol>"},{"location":"contributing/#development-guidelines","title":"Development Guidelines","text":""},{"location":"contributing/#code-style","title":"Code Style","text":"<p>We follow the PEP 8 style guide for Python code. We use the following tools to enforce code style:</p> <ul> <li>Black: For code formatting</li> <li>isort: For import sorting</li> <li>flake8: For linting</li> </ul> <p>You can run these tools with: <pre><code>black src tests\nisort src tests\nflake8 src tests\n</code></pre></p>"},{"location":"contributing/#documentation","title":"Documentation","text":"<ul> <li>All functions, classes, and modules should have docstrings following the NumPy docstring format.</li> <li>Update the documentation when adding or modifying features.</li> <li>Run the documentation locally to check your changes:   <pre><code>mkdocs serve\n</code></pre></li> </ul>"},{"location":"contributing/#testing","title":"Testing","text":"<ul> <li>Write tests for all new features and bug fixes.</li> <li>Make sure all tests pass before submitting a pull request:   <pre><code>pytest\n</code></pre></li> </ul>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Update the documentation with details of changes to the interface, if applicable.</li> <li>Update the tests to cover your changes.</li> <li>Make sure all tests pass.</li> <li>Submit a pull request to the <code>main</code> branch.</li> <li>The pull request will be reviewed by maintainers, who may request changes or improvements.</li> <li>Once approved, your pull request will be merged.</li> </ol>"},{"location":"contributing/#adding-new-kpis-or-moving-averages","title":"Adding New KPIs or Moving Averages","text":"<p>If you want to add a new KPI or moving average function:</p> <ol> <li>Add the function to the appropriate module (<code>kpi/business_kpi.py</code> for KPIs, <code>moving_averages/movingaverages.py</code> for moving averages).</li> <li>Write comprehensive docstrings with parameters, return values, and examples.</li> <li>Add tests for the new function.</li> <li>Update the documentation to include the new function.</li> <li>Add the function to the appropriate <code>__init__.py</code> file to expose it.</li> </ol>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing to Pypulate, you agree that your contributions will be licensed under the project's MIT License. </p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Pypulate requires:</p> <ul> <li>Python 3.7 or higher</li> <li>NumPy 1.20.0 or higher</li> </ul>"},{"location":"installation/#installing-from-pypi","title":"Installing from PyPI","text":"<p>The easiest way to install Pypulate is using pip:</p> <pre><code>pip install pypulate\n</code></pre> <p>This will install Pypulate and all its dependencies.</p>"},{"location":"installation/#installing-from-source","title":"Installing from Source","text":"<p>If you want to install the latest development version, you can install directly from the GitHub repository:</p> <pre><code>pip install git+https://github.com/yourusername/pypulate.git\n</code></pre>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>For development purposes, you can clone the repository and install in development mode:</p> <pre><code>git clone https://github.com/yourusername/pypulate.git\ncd pypulate\npip install -e .\n</code></pre> <p>This will install the package in development mode, allowing you to modify the code and see the changes immediately without reinstalling.</p>"},{"location":"installation/#verifying-installation","title":"Verifying Installation","text":"<p>You can verify that Pypulate is installed correctly by importing it in Python:</p> <pre><code>import pypulate\nprint(pypulate.__version__)\n</code></pre> <p>This should print the version number of Pypulate. </p>"},{"location":"license/","title":"License","text":"<p>Pypulate is released under the MIT License, which is a permissive open-source license that allows for free use, modification, and distribution of the software.</p>"},{"location":"license/#mit-license","title":"MIT License","text":"<pre><code>MIT License\n\nCopyright (c) 2025 Amir Rezaei\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"license/#what-this-means","title":"What This Means","text":"<p>The MIT License is one of the most permissive open-source licenses available. It allows you to:</p> <ul> <li>Use the code for commercial purposes</li> <li>Modify the code</li> <li>Distribute the code</li> <li>Use the code in private projects</li> <li>Sublicense the code</li> </ul> <p>The only requirement is that you include the original copyright notice and license text in any copy of the software/source.</p>"},{"location":"license/#third-party-libraries","title":"Third-Party Libraries","text":"<p>Pypulate depends on several third-party libraries, each with their own licenses:</p> <ul> <li>NumPy: BSD 3-Clause License</li> <li>MkDocs (for documentation): BSD 3-Clause License</li> <li>MkDocs Material Theme: MIT License</li> </ul> <p>Please refer to each library's documentation for more details on their licenses. </p>"},{"location":"api/business-kpis/","title":"Business KPIs API Reference","text":"<p>This page documents the API for the business KPIs module in Pypulate.</p> <p>Business KPIs Module</p> <p>This module provides functions for calculating various business metrics commonly used in SaaS and subscription-based businesses.</p>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.annual_recurring_revenue","title":"<code>annual_recurring_revenue(paying_customers, avg_revenue_per_customer)</code>","text":"<p>Calculate Annual Recurring Revenue (ARR).</p> <p>ARR is the value of the recurring revenue of a business's term subscriptions normalized for a single calendar year.</p> <p>Parameters:</p> Name Type Description Default <code>paying_customers</code> <code>int or float</code> <p>Number of paying customers</p> required <code>avg_revenue_per_customer</code> <code>int or float</code> <p>Average revenue per customer per month</p> required <p>Returns:</p> Type Description <code>float</code> <p>Annual Recurring Revenue</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; annual_recurring_revenue(100, 50)\n60000.0\n</code></pre>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.average_revenue_per_paying_user","title":"<code>average_revenue_per_paying_user(total_revenue, paying_users)</code>","text":"<p>Calculate Average Revenue Per Paying User (ARPPU).</p> <p>ARPPU measures the average revenue generated per paying user or customer.</p> <p>Parameters:</p> Name Type Description Default <code>total_revenue</code> <code>int or float</code> <p>Total revenue for the period</p> required <code>paying_users</code> <code>int or float</code> <p>Number of paying users or customers</p> required <p>Returns:</p> Type Description <code>float</code> <p>Average Revenue Per Paying User</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; average_revenue_per_paying_user(10000, 200)\n50.0\n</code></pre>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.average_revenue_per_user","title":"<code>average_revenue_per_user(total_revenue, total_users)</code>","text":"<p>Calculate Average Revenue Per User (ARPU).</p> <p>ARPU measures the average revenue generated per user or customer.</p> <p>Parameters:</p> Name Type Description Default <code>total_revenue</code> <code>(int, float, array - like)</code> <p>Total revenue for the period</p> required <code>total_users</code> <code>(int, float, array - like)</code> <p>Total number of users or customers</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Average Revenue Per User</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; average_revenue_per_user(10000, 500)\n20.0\n</code></pre>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.burn_rate","title":"<code>burn_rate(starting_capital, ending_capital, months)</code>","text":"<p>Calculate Monthly Burn Rate.</p> <p>Burn Rate is the rate at which a company is losing money.</p> <p>Parameters:</p> Name Type Description Default <code>starting_capital</code> <code>int or float</code> <p>Capital at the start of the period</p> required <code>ending_capital</code> <code>int or float</code> <p>Capital at the end of the period</p> required <code>months</code> <code>int or float</code> <p>Number of months in the period</p> required <p>Returns:</p> Type Description <code>float</code> <p>Monthly Burn Rate</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; burn_rate(100000, 70000, 6)\n5000.0\n</code></pre>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.churn_rate","title":"<code>churn_rate(customers_start, customers_end, new_customers)</code>","text":"<p>Calculate customer churn rate.</p> <p>Churn rate is the percentage of customers who stop using your product or service during a given time period.</p> <p>Parameters:</p> Name Type Description Default <code>customers_start</code> <code>(int, float, array - like)</code> <p>Number of customers at the start of the period</p> required <code>customers_end</code> <code>(int, float, array - like)</code> <p>Number of customers at the end of the period</p> required <code>new_customers</code> <code>(int, float, array - like)</code> <p>Number of new customers acquired during the period</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Churn rate as a percentage</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; churn_rate(100, 90, 10)\n20.0\n</code></pre>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.conversion_rate","title":"<code>conversion_rate(conversions, total_visitors)</code>","text":"<p>Calculate Conversion Rate.</p> <p>Conversion Rate is the percentage of visitors who take a desired action.</p> <p>Parameters:</p> Name Type Description Default <code>conversions</code> <code>(int, float, array - like)</code> <p>Number of conversions (desired actions taken)</p> required <code>total_visitors</code> <code>(int, float, array - like)</code> <p>Total number of visitors or users</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Conversion Rate as a percentage</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; conversion_rate(50, 1000)\n5.0\n</code></pre>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.customer_acquisition_cost","title":"<code>customer_acquisition_cost(marketing_costs, sales_costs, new_customers)</code>","text":"<p>Calculate Customer Acquisition Cost (CAC).</p> <p>CAC is the cost of convincing a potential customer to buy a product or service.</p> <p>Parameters:</p> Name Type Description Default <code>marketing_costs</code> <code>(int, float, array - like)</code> <p>Total marketing costs for the period</p> required <code>sales_costs</code> <code>(int, float, array - like)</code> <p>Total sales costs for the period</p> required <code>new_customers</code> <code>(int, float, array - like)</code> <p>Number of new customers acquired during the period</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Customer Acquisition Cost</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; customer_acquisition_cost(5000, 3000, 100)\n80.0\n</code></pre>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.customer_effort_score","title":"<code>customer_effort_score(effort_ratings, max_rating=7)</code>","text":"<p>Calculate Customer Effort Score (CES).</p> <p>CES measures how much effort a customer has to exert to use a product or service. Lower scores are better.</p> <p>Parameters:</p> Name Type Description Default <code>effort_ratings</code> <code>array - like</code> <p>Array of customer effort ratings</p> required <code>max_rating</code> <code>int or float</code> <p>Maximum possible rating value</p> <code>7</code> <p>Returns:</p> Type Description <code>float</code> <p>Customer Effort Score (average)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; customer_effort_score([2, 3, 1, 2, 4])\n2.4\n</code></pre>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.customer_engagement_score","title":"<code>customer_engagement_score(active_days, total_days)</code>","text":"<p>Calculate Customer Engagement Score.</p> <p>Customer Engagement Score measures how actively customers are using a product or service.</p> <p>Parameters:</p> Name Type Description Default <code>active_days</code> <code>int or float</code> <p>Number of days the customer was active</p> required <code>total_days</code> <code>int or float</code> <p>Total number of days in the period</p> required <p>Returns:</p> Type Description <code>float</code> <p>Customer Engagement Score as a percentage</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; customer_engagement_score(15, 30)\n50.0\n</code></pre>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.customer_lifetime_value","title":"<code>customer_lifetime_value(avg_revenue_per_customer, gross_margin, churn_rate_value, discount_rate=10.0)</code>","text":"<p>Calculate Customer Lifetime Value (CLV).</p> <p>CLV is the total worth to a business of a customer over the whole period of their relationship.</p> <p>Parameters:</p> Name Type Description Default <code>avg_revenue_per_customer</code> <code>int or float</code> <p>Average revenue per customer per period (e.g., monthly)</p> required <code>gross_margin</code> <code>int or float</code> <p>Gross margin percentage (0-100)</p> required <code>churn_rate_value</code> <code>int or float</code> <p>Churn rate percentage (0-100)</p> required <code>discount_rate</code> <code>int or float</code> <p>Annual discount rate for future cash flows (0-100)</p> <code>10.0</code> <p>Returns:</p> Type Description <code>float</code> <p>Customer Lifetime Value</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; customer_lifetime_value(100, 70, 5, 10)\n466.66\n</code></pre>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.customer_satisfaction_score","title":"<code>customer_satisfaction_score(satisfaction_ratings, max_rating=5)</code>","text":"<p>Calculate Customer Satisfaction Score (CSAT).</p> <p>CSAT measures how satisfied customers are with a product, service, or interaction.</p> <p>Parameters:</p> Name Type Description Default <code>satisfaction_ratings</code> <code>array - like</code> <p>Array of customer satisfaction ratings</p> required <code>max_rating</code> <code>int or float</code> <p>Maximum possible rating value</p> <code>5</code> <p>Returns:</p> Type Description <code>float</code> <p>Customer Satisfaction Score as a percentage</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; customer_satisfaction_score([4, 5, 3, 5, 4])\n84.0\n</code></pre>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.daily_active_users_ratio","title":"<code>daily_active_users_ratio(daily_active_users, total_users)</code>","text":"<p>Calculate Daily Active Users (DAU) Ratio.</p> <p>DAU Ratio measures the percentage of total users who are active on a daily basis.</p> <p>Parameters:</p> Name Type Description Default <code>daily_active_users</code> <code>int or float</code> <p>Number of daily active users</p> required <code>total_users</code> <code>int or float</code> <p>Total number of users</p> required <p>Returns:</p> Type Description <code>float</code> <p>Daily Active Users Ratio as a percentage</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; daily_active_users_ratio(500, 2000)\n25.0\n</code></pre>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.expansion_revenue_rate","title":"<code>expansion_revenue_rate(upsell_revenue, cross_sell_revenue, revenue_start)</code>","text":"<p>Calculate Expansion Revenue Rate.</p> <p>Expansion Revenue Rate is the percentage of additional revenue generated from existing customers.</p> <p>Parameters:</p> Name Type Description Default <code>upsell_revenue</code> <code>int or float</code> <p>Revenue from upselling to existing customers</p> required <code>cross_sell_revenue</code> <code>int or float</code> <p>Revenue from cross-selling to existing customers</p> required <code>revenue_start</code> <code>int or float</code> <p>Revenue at the start of the period</p> required <p>Returns:</p> Type Description <code>float</code> <p>Expansion Revenue Rate as a percentage</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; expansion_revenue_rate(1000, 500, 10000)\n15.0\n</code></pre>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.feature_adoption_rate","title":"<code>feature_adoption_rate(users_adopting_feature, total_users)</code>","text":"<p>Calculate Feature Adoption Rate.</p> <p>Feature Adoption Rate measures the percentage of users who adopt a specific feature.</p> <p>Parameters:</p> Name Type Description Default <code>users_adopting_feature</code> <code>int or float</code> <p>Number of users who adopted the feature</p> required <code>total_users</code> <code>int or float</code> <p>Total number of users</p> required <p>Returns:</p> Type Description <code>float</code> <p>Feature Adoption Rate as a percentage</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; feature_adoption_rate(300, 1000)\n30.0\n</code></pre>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.gross_margin","title":"<code>gross_margin(revenue, cost_of_goods_sold)</code>","text":"<p>Calculate Gross Margin.</p> <p>Gross Margin is the percentage of revenue that exceeds the cost of goods sold.</p> <p>Parameters:</p> Name Type Description Default <code>revenue</code> <code>int or float</code> <p>Total revenue</p> required <code>cost_of_goods_sold</code> <code>int or float</code> <p>Cost of goods sold</p> required <p>Returns:</p> Type Description <code>float</code> <p>Gross Margin as a percentage</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gross_margin(10000, 3000)\n70.0\n</code></pre>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.ltv_cac_ratio","title":"<code>ltv_cac_ratio(ltv, cac)</code>","text":"<p>Calculate LTV:CAC Ratio.</p> <p>LTV:CAC Ratio is a metric that compares the lifetime value of a customer to the cost of acquiring that customer.</p> <p>Parameters:</p> Name Type Description Default <code>ltv</code> <code>int or float</code> <p>Customer Lifetime Value</p> required <code>cac</code> <code>int or float</code> <p>Customer Acquisition Cost</p> required <p>Returns:</p> Type Description <code>float</code> <p>LTV:CAC Ratio</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ltv_cac_ratio(1000, 200)\n5.0\n</code></pre>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.monthly_active_users_ratio","title":"<code>monthly_active_users_ratio(monthly_active_users, total_users)</code>","text":"<p>Calculate Monthly Active Users (MAU) Ratio.</p> <p>MAU Ratio measures the percentage of total users who are active on a monthly basis.</p> <p>Parameters:</p> Name Type Description Default <code>monthly_active_users</code> <code>int or float</code> <p>Number of monthly active users</p> required <code>total_users</code> <code>int or float</code> <p>Total number of users</p> required <p>Returns:</p> Type Description <code>float</code> <p>Monthly Active Users Ratio as a percentage</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; monthly_active_users_ratio(1500, 2000)\n75.0\n</code></pre>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.monthly_recurring_revenue","title":"<code>monthly_recurring_revenue(paying_customers, avg_revenue_per_customer)</code>","text":"<p>Calculate Monthly Recurring Revenue (MRR).</p> <p>MRR is the predictable total revenue generated by all the active subscriptions in a month.</p> <p>Parameters:</p> Name Type Description Default <code>paying_customers</code> <code>(int, float, array - like)</code> <p>Number of paying customers</p> required <code>avg_revenue_per_customer</code> <code>(int, float, array - like)</code> <p>Average revenue per customer per month</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Monthly Recurring Revenue</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; monthly_recurring_revenue(100, 50)\n5000.0\n</code></pre>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.net_promoter_score","title":"<code>net_promoter_score(promoters, detractors, total_respondents)</code>","text":"<p>Calculate Net Promoter Score (NPS).</p> <p>NPS measures customer experience and predicts business growth.</p> <p>Parameters:</p> Name Type Description Default <code>promoters</code> <code>(int, float, array - like)</code> <p>Number of promoters (customers who rated 9-10)</p> required <code>detractors</code> <code>(int, float, array - like)</code> <p>Number of detractors (customers who rated 0-6)</p> required <code>total_respondents</code> <code>(int, float, array - like)</code> <p>Total number of survey respondents</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Net Promoter Score (ranges from -100 to 100)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; net_promoter_score(70, 10, 100)\n60.0\n</code></pre>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.payback_period","title":"<code>payback_period(cac, avg_monthly_revenue, gross_margin)</code>","text":"<p>Calculate CAC Payback Period in months.</p> <p>CAC Payback Period is the number of months it takes to recover the cost of acquiring a customer.</p> <p>Parameters:</p> Name Type Description Default <code>cac</code> <code>int or float</code> <p>Customer Acquisition Cost</p> required <code>avg_monthly_revenue</code> <code>int or float</code> <p>Average monthly revenue per customer</p> required <code>gross_margin</code> <code>int or float</code> <p>Gross margin percentage (0-100)</p> required <p>Returns:</p> Type Description <code>float</code> <p>CAC Payback Period in months</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; payback_period(1000, 100, 70)\n14.29\n</code></pre>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.retention_rate","title":"<code>retention_rate(customers_start, customers_end, new_customers)</code>","text":"<p>Calculate customer retention rate.</p> <p>Retention rate is the percentage of customers who remain with your product or service over a given time period.</p> <p>Parameters:</p> Name Type Description Default <code>customers_start</code> <code>(int, float, array - like)</code> <p>Number of customers at the start of the period</p> required <code>customers_end</code> <code>(int, float, array - like)</code> <p>Number of customers at the end of the period</p> required <code>new_customers</code> <code>(int, float, array - like)</code> <p>Number of new customers acquired during the period</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Retention rate as a percentage</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; retention_rate(100, 90, 10)\n80.0\n</code></pre>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.revenue_churn_rate","title":"<code>revenue_churn_rate(revenue_start, revenue_end, new_revenue)</code>","text":"<p>Calculate Revenue Churn Rate.</p> <p>Revenue Churn Rate is the percentage of revenue lost from existing customers in a given period.</p> <p>Parameters:</p> Name Type Description Default <code>revenue_start</code> <code>(int, float, array - like)</code> <p>Revenue at the start of the period</p> required <code>revenue_end</code> <code>(int, float, array - like)</code> <p>Revenue at the end of the period</p> required <code>new_revenue</code> <code>(int, float, array - like)</code> <p>New revenue acquired during the period</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Revenue Churn Rate as a percentage</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; revenue_churn_rate(10000, 9500, 1000)\n15.0\n</code></pre>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.roi","title":"<code>roi(revenue, costs)</code>","text":"<p>Calculate Return on Investment (ROI).</p> <p>ROI measures the return on an investment relative to its cost.</p> <p>Parameters:</p> Name Type Description Default <code>revenue</code> <code>(int, float, array - like)</code> <p>Revenue or return from the investment</p> required <code>costs</code> <code>(int, float, array - like)</code> <p>Cost of the investment</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Return on Investment as a percentage</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; roi(150, 100)\n50.0\n&gt;&gt;&gt; roi([150, 200, 250], [100, 120, 150])\narray([50., 66.67, 66.67])\n</code></pre>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.runway","title":"<code>runway(current_capital, monthly_burn_rate)</code>","text":"<p>Calculate Runway in months.</p> <p>Runway is the amount of time a company has before it runs out of money.</p> <p>Parameters:</p> Name Type Description Default <code>current_capital</code> <code>int or float</code> <p>Current capital</p> required <code>monthly_burn_rate</code> <code>int or float</code> <p>Monthly burn rate</p> required <p>Returns:</p> Type Description <code>float</code> <p>Runway in months</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; runway(100000, 5000)\n20.0\n</code></pre>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.stickiness_ratio","title":"<code>stickiness_ratio(daily_active_users, monthly_active_users)</code>","text":"<p>Calculate Stickiness Ratio (DAU/MAU).</p> <p>Stickiness Ratio measures how frequently active users engage with a product.</p> <p>Parameters:</p> Name Type Description Default <code>daily_active_users</code> <code>int or float</code> <p>Number of daily active users</p> required <code>monthly_active_users</code> <code>int or float</code> <p>Number of monthly active users</p> required <p>Returns:</p> Type Description <code>float</code> <p>Stickiness Ratio as a percentage</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; stickiness_ratio(500, 1500)\n33.33\n</code></pre>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.time_to_value","title":"<code>time_to_value(onboarding_time, setup_time, learning_time)</code>","text":"<p>Calculate Time to Value (TTV).</p> <p>Time to Value is the amount of time it takes for a customer to realize value from a product.</p> <p>Parameters:</p> Name Type Description Default <code>onboarding_time</code> <code>int or float</code> <p>Time spent on onboarding</p> required <code>setup_time</code> <code>int or float</code> <p>Time spent on setup</p> required <code>learning_time</code> <code>int or float</code> <p>Time spent on learning</p> required <p>Returns:</p> Type Description <code>float</code> <p>Time to Value</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; time_to_value(2, 3, 5)\n10.0\n</code></pre>"},{"location":"api/business-kpis/#pypulate.kpi.business_kpi.virality_coefficient","title":"<code>virality_coefficient(new_users, invites_sent, total_users)</code>","text":"<p>Calculate Virality Coefficient (K-factor).</p> <p>Virality Coefficient measures how many new users each existing user brings in.</p> <p>Parameters:</p> Name Type Description Default <code>new_users</code> <code>int or float</code> <p>Number of new users from invites</p> required <code>invites_sent</code> <code>int or float</code> <p>Number of invites sent</p> required <code>total_users</code> <code>int or float</code> <p>Total number of users</p> required <p>Returns:</p> Type Description <code>float</code> <p>Virality Coefficient</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; virality_coefficient(100, 500, 1000)\n0.1\n</code></pre>"},{"location":"api/filters/","title":"Filters API Reference","text":"<p>This page documents the API for the filters module in Pypulate.</p>"},{"location":"api/filters/#kalman-filters","title":"Kalman Filters","text":"<p>Apply a standard Kalman filter to a time series.</p> <p>The Kalman filter is an optimal estimator that infers parameters of interest from indirect, inaccurate and uncertain observations. It's recursive so new measurements can be processed as they arrive.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>process_variance</code> <code>float</code> <p>Process noise variance (Q)</p> <code>1e-5</code> <code>measurement_variance</code> <code>float</code> <p>Measurement noise variance (R)</p> <code>1e-3</code> <code>initial_state</code> <code>float</code> <p>Initial state estimate. If None, the first data point is used</p> <code>None</code> <code>initial_covariance</code> <code>float</code> <p>Initial estimate covariance</p> <code>1.0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Filtered time series</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pypulate.filters import kalman_filter\n&gt;&gt;&gt; # Create noisy data\n&gt;&gt;&gt; x = np.linspace(0, 10, 100)\n&gt;&gt;&gt; true_signal = np.sin(x)\n&gt;&gt;&gt; noisy_signal = true_signal + np.random.normal(0, 0.1, len(x))\n&gt;&gt;&gt; # Apply Kalman filter\n&gt;&gt;&gt; filtered_signal = kalman_filter(noisy_signal)\n</code></pre> <p>Apply an Extended Kalman Filter (EKF) to a time series with non-linear dynamics.</p> <p>The EKF is a nonlinear version of the Kalman filter that linearizes about the current mean and covariance. It's used when the state transition or observation models are non-linear.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data (observations)</p> required <code>state_transition_func</code> <code>callable</code> <p>Function that computes the state transition (f)</p> required <code>observation_func</code> <code>callable</code> <p>Function that computes the observation from state (h)</p> required <code>process_jacobian_func</code> <code>callable</code> <p>Function that computes the Jacobian of the state transition function</p> required <code>observation_jacobian_func</code> <code>callable</code> <p>Function that computes the Jacobian of the observation function</p> required <code>process_covariance</code> <code>ndarray</code> <p>Process noise covariance matrix (Q)</p> required <code>observation_covariance</code> <code>ndarray</code> <p>Observation noise covariance matrix (R)</p> required <code>initial_state</code> <code>ndarray</code> <p>Initial state estimate. If None, zeros are used</p> <code>None</code> <code>initial_covariance</code> <code>ndarray</code> <p>Initial estimate covariance matrix. If None, identity is used</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Filtered time series (state estimates)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pypulate.filters import extended_kalman_filter\n&gt;&gt;&gt; # Define non-linear system\n&gt;&gt;&gt; def state_transition(x):\n...     # Non-linear state transition function\n...     return np.array([x[0] + x[1], 0.5 * x[1]])\n&gt;&gt;&gt; def observation(x):\n...     # Non-linear observation function\n...     return np.array([np.sin(x[0])])\n&gt;&gt;&gt; def process_jacobian(x):\n...     # Jacobian of state transition function\n...     return np.array([[1, 1], [0, 0.5]])\n&gt;&gt;&gt; def observation_jacobian(x):\n...     # Jacobian of observation function\n...     return np.array([[np.cos(x[0]), 0]])\n&gt;&gt;&gt; # Create data\n&gt;&gt;&gt; n = 100\n&gt;&gt;&gt; true_states = np.zeros((n, 2))\n&gt;&gt;&gt; true_states[0] = [0, 1]\n&gt;&gt;&gt; for i in range(1, n):\n...     true_states[i] = state_transition(true_states[i-1])\n&gt;&gt;&gt; observations = np.array([observation(x)[0] for x in true_states])\n&gt;&gt;&gt; observations += np.random.normal(0, 0.1, n)\n&gt;&gt;&gt; # Apply EKF\n&gt;&gt;&gt; Q = np.eye(2) * 0.01  # Process noise covariance\n&gt;&gt;&gt; R = np.array([[0.1]])  # Observation noise covariance\n&gt;&gt;&gt; filtered_states = extended_kalman_filter(\n...     observations, state_transition, observation,\n...     process_jacobian, observation_jacobian, Q, R\n... )\n</code></pre> <p>Apply an Unscented Kalman Filter (UKF) to a time series with non-linear dynamics.</p> <p>The UKF uses the unscented transform to pick a minimal set of sample points (sigma points) around the mean. These sigma points are then propagated through the non-linear functions, and the mean and covariance of the estimate are recovered.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data (observations)</p> required <code>state_transition_func</code> <code>callable</code> <p>Function that computes the state transition</p> required <code>observation_func</code> <code>callable</code> <p>Function that computes the observation from state</p> required <code>process_covariance</code> <code>ndarray</code> <p>Process noise covariance matrix (Q)</p> required <code>observation_covariance</code> <code>ndarray</code> <p>Observation noise covariance matrix (R)</p> required <code>initial_state</code> <code>ndarray</code> <p>Initial state estimate. If None, zeros are used</p> <code>None</code> <code>initial_covariance</code> <code>ndarray</code> <p>Initial estimate covariance matrix. If None, identity is used</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Spread of sigma points around mean</p> <code>1e-3</code> <code>beta</code> <code>float</code> <p>Prior knowledge about distribution (2 is optimal for Gaussian)</p> <code>2.0</code> <code>kappa</code> <code>float</code> <p>Secondary scaling parameter</p> <code>0.0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Filtered time series (state estimates)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pypulate.filters import unscented_kalman_filter\n&gt;&gt;&gt; # Define non-linear system\n&gt;&gt;&gt; def state_transition(x):\n...     # Non-linear state transition function\n...     return np.array([x[0] + x[1], 0.5 * x[1]])\n&gt;&gt;&gt; def observation(x):\n...     # Non-linear observation function\n...     return np.array([np.sin(x[0])])\n&gt;&gt;&gt; # Create data\n&gt;&gt;&gt; n = 100\n&gt;&gt;&gt; true_states = np.zeros((n, 2))\n&gt;&gt;&gt; true_states[0] = [0, 1]\n&gt;&gt;&gt; for i in range(1, n):\n...     true_states[i] = state_transition(true_states[i-1])\n&gt;&gt;&gt; observations = np.array([observation(x)[0] for x in true_states])\n&gt;&gt;&gt; observations += np.random.normal(0, 0.1, n)\n&gt;&gt;&gt; # Apply UKF\n&gt;&gt;&gt; Q = np.eye(2) * 0.01  # Process noise covariance\n&gt;&gt;&gt; R = np.array([[0.1]])  # Observation noise covariance\n&gt;&gt;&gt; filtered_states = unscented_kalman_filter(\n...     observations, state_transition, observation, Q, R\n... )\n</code></pre>"},{"location":"api/filters/#signal-filters","title":"Signal Filters","text":"<p>Apply a Butterworth filter to a time series.</p> <p>The Butterworth filter is a type of signal processing filter designed to have a frequency response as flat as possible in the passband.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>cutoff</code> <code>float or tuple of float</code> <p>Cutoff frequency. For lowpass and highpass, this is a scalar. For bandpass and bandstop, this is a tuple of (low, high)</p> required <code>order</code> <code>int</code> <p>Filter order</p> <code>4</code> <code>filter_type</code> <code>str</code> <p>Filter type: 'lowpass', 'highpass', 'bandpass', or 'bandstop'</p> <code>'lowpass'</code> <code>fs</code> <code>float</code> <p>Sampling frequency</p> <code>1.0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Filtered time series</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pypulate.filters import butterworth_filter\n&gt;&gt;&gt; # Create noisy data\n&gt;&gt;&gt; x = np.linspace(0, 10, 1000)\n&gt;&gt;&gt; signal = np.sin(2 * np.pi * 0.05 * x) + 0.5 * np.sin(2 * np.pi * 0.25 * x)\n&gt;&gt;&gt; # Apply lowpass filter to remove high frequency component\n&gt;&gt;&gt; filtered = butterworth_filter(signal, cutoff=0.1, filter_type='lowpass', fs=1.0)\n</code></pre> <p>Apply a Chebyshev filter to a time series.</p> <p>The Chebyshev filter is a filter with steeper roll-off than the Butterworth but more passband ripple (type I) or stopband ripple (type II).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>cutoff</code> <code>float or tuple of float</code> <p>Cutoff frequency. For lowpass and highpass, this is a scalar. For bandpass and bandstop, this is a tuple of (low, high)</p> required <code>order</code> <code>int</code> <p>Filter order</p> <code>4</code> <code>ripple</code> <code>float</code> <p>Maximum ripple allowed in the passband (type I) or stopband (type II)</p> <code>1.0</code> <code>filter_type</code> <code>str</code> <p>Filter type: 'lowpass', 'highpass', 'bandpass', or 'bandstop'</p> <code>'lowpass'</code> <code>fs</code> <code>float</code> <p>Sampling frequency</p> <code>1.0</code> <code>type_num</code> <code>int</code> <p>Type of Chebyshev filter: 1 for Type I, 2 for Type II</p> <code>1</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Filtered time series</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pypulate.filters import chebyshev_filter\n&gt;&gt;&gt; # Create noisy data\n&gt;&gt;&gt; x = np.linspace(0, 10, 1000)\n&gt;&gt;&gt; signal = np.sin(2 * np.pi * 0.05 * x) + 0.5 * np.sin(2 * np.pi * 0.25 * x)\n&gt;&gt;&gt; # Apply Chebyshev type I lowpass filter\n&gt;&gt;&gt; filtered = chebyshev_filter(signal, cutoff=0.1, ripple=0.5, type_num=1)\n</code></pre> <p>Apply a Savitzky-Golay filter to a time series.</p> <p>The Savitzky-Golay filter is a digital filter that can be applied to a set of digital data points to smooth the data by increasing the signal-to-noise ratio without greatly distorting the signal.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>window_length</code> <code>int</code> <p>Length of the filter window (must be odd)</p> <code>11</code> <code>polyorder</code> <code>int</code> <p>Order of the polynomial used to fit the samples (must be less than window_length)</p> <code>3</code> <code>deriv</code> <code>int</code> <p>Order of the derivative to compute</p> <code>0</code> <code>delta</code> <code>float</code> <p>Spacing of the samples to which the filter is applied</p> <code>1.0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Filtered time series</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pypulate.filters import savitzky_golay_filter\n&gt;&gt;&gt; # Create noisy data\n&gt;&gt;&gt; x = np.linspace(0, 10, 100)\n&gt;&gt;&gt; signal = np.sin(x) + np.random.normal(0, 0.1, len(x))\n&gt;&gt;&gt; # Apply Savitzky-Golay filter\n&gt;&gt;&gt; filtered = savitzky_golay_filter(signal, window_length=11, polyorder=3)\n</code></pre> <p>Apply a Wiener filter to a time series.</p> <p>The Wiener filter is a filter used to produce an estimate of a desired or target signal by linear filtering of an observed noisy signal.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>mysize</code> <code>int or tuple of int</code> <p>Size of the filter window</p> <code>3</code> <code>noise</code> <code>float</code> <p>Estimate of the noise power. If None, it's estimated from the data</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Filtered time series</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pypulate.filters import wiener_filter\n&gt;&gt;&gt; # Create noisy data\n&gt;&gt;&gt; x = np.linspace(0, 10, 100)\n&gt;&gt;&gt; signal = np.sin(x) + np.random.normal(0, 0.1, len(x))\n&gt;&gt;&gt; # Apply Wiener filter\n&gt;&gt;&gt; filtered = wiener_filter(signal, mysize=5)\n</code></pre> <p>Apply a median filter to a time series.</p> <p>The median filter is a nonlinear digital filtering technique used to remove noise from a signal. It replaces each entry with the median of neighboring entries.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>kernel_size</code> <code>int</code> <p>Size of the filter kernel</p> <code>3</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Filtered time series</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pypulate.filters import median_filter\n&gt;&gt;&gt; # Create noisy data with outliers\n&gt;&gt;&gt; x = np.linspace(0, 10, 100)\n&gt;&gt;&gt; signal = np.sin(x)\n&gt;&gt;&gt; signal[10] = 5  # Add outlier\n&gt;&gt;&gt; signal[50] = -5  # Add outlier\n&gt;&gt;&gt; # Apply median filter to remove outliers\n&gt;&gt;&gt; filtered = median_filter(signal, kernel_size=5)\n</code></pre> <p>Apply a Hampel filter to a time series.</p> <p>The Hampel filter is used to identify and replace outliers in a time series. It uses the median and the median absolute deviation (MAD) to identify outliers.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>window_size</code> <code>int</code> <p>Size of the window (number of points on each side of the current point)</p> <code>5</code> <code>n_sigmas</code> <code>float</code> <p>Number of standard deviations to use for outlier detection</p> <code>3.0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Filtered time series</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pypulate.filters import hampel_filter\n&gt;&gt;&gt; # Create noisy data with outliers\n&gt;&gt;&gt; x = np.linspace(0, 10, 100)\n&gt;&gt;&gt; signal = np.sin(x)\n&gt;&gt;&gt; signal[10] = 5  # Add outlier\n&gt;&gt;&gt; signal[50] = -5  # Add outlier\n&gt;&gt;&gt; # Apply Hampel filter to remove outliers\n&gt;&gt;&gt; filtered = hampel_filter(signal, window_size=5, n_sigmas=3.0)\n</code></pre> <p>Apply the Hodrick-Prescott filter to decompose a time series into trend and cycle components.</p> <p>The Hodrick-Prescott filter is a mathematical tool used in macroeconomics to separate the cyclical component of a time series from raw data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>lambda_param</code> <code>float</code> <p>Smoothing parameter. The larger the value, the smoother the trend component</p> <code>1600.0</code> <p>Returns:</p> Type Description <code>tuple of np.ndarray</code> <p>Tuple containing (trend, cycle) components</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pypulate.filters import hodrick_prescott_filter\n&gt;&gt;&gt; # Create data with trend and cycle\n&gt;&gt;&gt; x = np.linspace(0, 10, 100)\n&gt;&gt;&gt; trend = 0.1 * x**2\n&gt;&gt;&gt; cycle = np.sin(2 * np.pi * 0.1 * x)\n&gt;&gt;&gt; data = trend + cycle\n&gt;&gt;&gt; # Apply Hodrick-Prescott filter\n&gt;&gt;&gt; trend_component, cycle_component = hodrick_prescott_filter(data, lambda_param=100)\n</code></pre> <p>Apply the Baxter-King bandpass filter to extract business cycle components.</p> <p>The Baxter-King filter is a bandpass filter used to extract business cycle components from macroeconomic time series.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>low</code> <code>float</code> <p>Minimum period of oscillations (in number of observations)</p> <code>6</code> <code>high</code> <code>float</code> <p>Maximum period of oscillations (in number of observations)</p> <code>32</code> <code>K</code> <code>int</code> <p>Number of terms in the approximation (lead/lag)</p> <code>12</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Filtered time series (cycle component)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pypulate.filters import baxter_king_filter\n&gt;&gt;&gt; # Create data with trend and multiple cycles\n&gt;&gt;&gt; x = np.linspace(0, 100, 1000)\n&gt;&gt;&gt; trend = 0.01 * x\n&gt;&gt;&gt; long_cycle = np.sin(2 * np.pi * x / 100)  # Period of 100\n&gt;&gt;&gt; business_cycle = np.sin(2 * np.pi * x / 20)  # Period of 20\n&gt;&gt;&gt; short_cycle = np.sin(2 * np.pi * x / 5)  # Period of 5\n&gt;&gt;&gt; data = trend + long_cycle + business_cycle + short_cycle\n&gt;&gt;&gt; # Extract business cycle component (periods between 8 and 32)\n&gt;&gt;&gt; cycle = baxter_king_filter(data, low=8, high=32, K=12)\n</code></pre>"},{"location":"api/filters/#adaptive-filters","title":"Adaptive Filters","text":"<p>Apply an adaptive Kalman filter to a time series.</p> <p>The adaptive Kalman filter automatically adjusts its parameters based on the observed data, making it more robust to changing dynamics.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>process_variance_init</code> <code>float</code> <p>Initial process noise variance (Q)</p> <code>1e-5</code> <code>measurement_variance_init</code> <code>float</code> <p>Initial measurement noise variance (R)</p> <code>1e-3</code> <code>adaptation_rate</code> <code>float</code> <p>Rate at which the filter adapts to changes</p> <code>0.01</code> <code>window_size</code> <code>int</code> <p>Size of the window for innovation estimation</p> <code>10</code> <code>initial_state</code> <code>float</code> <p>Initial state estimate. If None, the first data point is used</p> <code>None</code> <code>initial_covariance</code> <code>float</code> <p>Initial estimate covariance</p> <code>1.0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Filtered time series</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pypulate.filters import adaptive_kalman_filter\n&gt;&gt;&gt; # Create noisy data with changing dynamics\n&gt;&gt;&gt; x = np.linspace(0, 10, 200)\n&gt;&gt;&gt; true_signal = np.sin(x) + 0.1 * x\n&gt;&gt;&gt; noise_level = 0.1 * (1 + np.sin(x/2))  # Changing noise level\n&gt;&gt;&gt; noisy_signal = true_signal + noise_level * np.random.randn(len(x))\n&gt;&gt;&gt; # Apply adaptive Kalman filter\n&gt;&gt;&gt; filtered_signal = adaptive_kalman_filter(noisy_signal, adaptation_rate=0.05)\n</code></pre> <p>Apply a Least Mean Squares (LMS) adaptive filter to a time series.</p> <p>The LMS algorithm is an adaptive filter that adjusts its coefficients to minimize the mean square error between the desired signal and the filter output.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>desired</code> <code>ndarray</code> <p>Desired signal. If None, a delayed version of the input is used</p> <code>None</code> <code>filter_length</code> <code>int</code> <p>Length of the adaptive filter</p> <code>5</code> <code>mu</code> <code>float</code> <p>Step size (learning rate) of the adaptation</p> <code>0.01</code> <code>initial_weights</code> <code>ndarray</code> <p>Initial filter weights. If None, zeros are used</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple of np.ndarray</code> <p>Tuple containing (filtered_data, filter_weights)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pypulate.filters import least_mean_squares_filter\n&gt;&gt;&gt; # Create noisy data\n&gt;&gt;&gt; x = np.linspace(0, 10, 1000)\n&gt;&gt;&gt; clean_signal = np.sin(2 * np.pi * 0.05 * x)\n&gt;&gt;&gt; noise = 0.2 * np.random.randn(len(x))\n&gt;&gt;&gt; noisy_signal = clean_signal + noise\n&gt;&gt;&gt; # Apply LMS filter\n&gt;&gt;&gt; filtered_signal, weights = least_mean_squares_filter(noisy_signal, filter_length=10, mu=0.02)\n</code></pre> <p>Apply a Recursive Least Squares (RLS) adaptive filter to a time series.</p> <p>The RLS algorithm is an adaptive filter that recursively finds the filter coefficients that minimize a weighted linear least squares cost function related to the input signals.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>desired</code> <code>ndarray</code> <p>Desired signal. If None, a delayed version of the input is used</p> <code>None</code> <code>filter_length</code> <code>int</code> <p>Length of the adaptive filter</p> <code>5</code> <code>forgetting_factor</code> <code>float</code> <p>Forgetting factor (0 &lt; lambda &lt;= 1)</p> <code>0.99</code> <code>delta</code> <code>float</code> <p>Regularization parameter for the initial correlation matrix</p> <code>1.0</code> <code>initial_weights</code> <code>ndarray</code> <p>Initial filter weights. If None, zeros are used</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple of np.ndarray</code> <p>Tuple containing (filtered_data, filter_weights)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pypulate.filters import recursive_least_squares_filter\n&gt;&gt;&gt; # Create noisy data\n&gt;&gt;&gt; x = np.linspace(0, 10, 1000)\n&gt;&gt;&gt; clean_signal = np.sin(2 * np.pi * 0.05 * x)\n&gt;&gt;&gt; noise = 0.2 * np.random.randn(len(x))\n&gt;&gt;&gt; noisy_signal = clean_signal + noise\n&gt;&gt;&gt; # Apply RLS filter\n&gt;&gt;&gt; filtered_signal, weights = recursive_least_squares_filter(\n...     noisy_signal, filter_length=10, forgetting_factor=0.99\n... )\n</code></pre>"},{"location":"api/filters/#particle-filters","title":"Particle Filters","text":"<p>Apply a particle filter to a time series.</p> <p>The particle filter is a sequential Monte Carlo method that uses a set of particles (samples) to represent the posterior distribution of some stochastic process given noisy and/or partial observations.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data (observations)</p> required <code>state_transition_func</code> <code>callable</code> <p>Function that propagates particles through the state transition model</p> required <code>observation_func</code> <code>callable</code> <p>Function that computes the expected observation from a state</p> required <code>process_noise_func</code> <code>callable</code> <p>Function that adds process noise to particles</p> required <code>observation_likelihood_func</code> <code>callable</code> <p>Function that computes the likelihood of an observation given a state</p> required <code>n_particles</code> <code>int</code> <p>Number of particles</p> <code>100</code> <code>initial_state_func</code> <code>callable</code> <p>Function that generates initial particles. If None, a default is used</p> <code>None</code> <code>resample_threshold</code> <code>float</code> <p>Threshold for effective sample size ratio below which resampling occurs</p> <code>0.5</code> <p>Returns:</p> Type Description <code>tuple of np.ndarray</code> <p>Tuple containing (filtered_states, particle_weights)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pypulate.filters import particle_filter\n&gt;&gt;&gt; # Define model functions\n&gt;&gt;&gt; def state_transition(particles):\n...     # Simple random walk model\n...     return particles\n&gt;&gt;&gt; def process_noise(particles):\n...     # Add Gaussian noise\n...     return particles + np.random.normal(0, 0.1, particles.shape)\n&gt;&gt;&gt; def observation_func(state):\n...     # Identity observation model\n...     return state\n&gt;&gt;&gt; def observation_likelihood(observation, predicted_observation):\n...     # Gaussian likelihood\n...     return np.exp(-0.5 * ((observation - predicted_observation) / 0.1) ** 2)\n&gt;&gt;&gt; def initial_state(n):\n...     # Initial particles from normal distribution\n...     return np.random.normal(0, 1, n)\n&gt;&gt;&gt; # Create data\n&gt;&gt;&gt; true_states = np.cumsum(np.random.normal(0, 0.1, 100))\n&gt;&gt;&gt; observations = true_states + np.random.normal(0, 0.1, 100)\n&gt;&gt;&gt; # Apply particle filter\n&gt;&gt;&gt; filtered_states, weights = particle_filter(\n...     observations, state_transition, observation_func,\n...     process_noise, observation_likelihood, n_particles=1000,\n...     initial_state_func=initial_state\n... )\n</code></pre> <p>Apply a bootstrap particle filter to a time series.</p> <p>The bootstrap particle filter is a simplified version of the particle filter that resamples at every step and uses the state transition prior as the proposal.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data (observations)</p> required <code>state_transition_func</code> <code>callable</code> <p>Function that propagates particles through the state transition model</p> required <code>observation_func</code> <code>callable</code> <p>Function that computes the expected observation from a state</p> required <code>process_noise_std</code> <code>float</code> <p>Standard deviation of the process noise</p> <code>0.1</code> <code>observation_noise_std</code> <code>float</code> <p>Standard deviation of the observation noise</p> <code>0.1</code> <code>n_particles</code> <code>int</code> <p>Number of particles</p> <code>100</code> <code>initial_state_mean</code> <code>float</code> <p>Mean of the initial state distribution. If None, the first observation is used</p> <code>None</code> <code>initial_state_std</code> <code>float</code> <p>Standard deviation of the initial state distribution</p> <code>1.0</code> <p>Returns:</p> Type Description <code>tuple of np.ndarray</code> <p>Tuple containing (filtered_states, particle_weights)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pypulate.filters import bootstrap_particle_filter\n&gt;&gt;&gt; # Define model functions\n&gt;&gt;&gt; def state_transition(particles):\n...     # Simple random walk model\n...     return particles\n&gt;&gt;&gt; def observation_func(state):\n...     # Identity observation model\n...     return state\n&gt;&gt;&gt; # Create data\n&gt;&gt;&gt; true_states = np.cumsum(np.random.normal(0, 0.1, 100))\n&gt;&gt;&gt; observations = true_states + np.random.normal(0, 0.1, 100)\n&gt;&gt;&gt; # Apply bootstrap particle filter\n&gt;&gt;&gt; filtered_states, weights = bootstrap_particle_filter(\n...     observations, state_transition, observation_func,\n...     process_noise_std=0.1, observation_noise_std=0.1, n_particles=1000\n... )\n</code></pre>"},{"location":"api/kpi/","title":"business kpi API Reference","text":"<p>Business KPIs Module</p> <p>This module provides functions for calculating various business metrics commonly used in SaaS and subscription-based businesses.</p>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.annual_recurring_revenue","title":"<code>annual_recurring_revenue(paying_customers, avg_revenue_per_customer)</code>","text":"<p>Calculate Annual Recurring Revenue (ARR).</p> <p>ARR is the value of the recurring revenue of a business's term subscriptions normalized for a single calendar year.</p> <p>Parameters:</p> Name Type Description Default <code>paying_customers</code> <code>int or float</code> <p>Number of paying customers</p> required <code>avg_revenue_per_customer</code> <code>int or float</code> <p>Average revenue per customer per month</p> required <p>Returns:</p> Type Description <code>float</code> <p>Annual Recurring Revenue</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; annual_recurring_revenue(100, 50)\n60000.0\n</code></pre>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.average_revenue_per_paying_user","title":"<code>average_revenue_per_paying_user(total_revenue, paying_users)</code>","text":"<p>Calculate Average Revenue Per Paying User (ARPPU).</p> <p>ARPPU measures the average revenue generated per paying user or customer.</p> <p>Parameters:</p> Name Type Description Default <code>total_revenue</code> <code>int or float</code> <p>Total revenue for the period</p> required <code>paying_users</code> <code>int or float</code> <p>Number of paying users or customers</p> required <p>Returns:</p> Type Description <code>float</code> <p>Average Revenue Per Paying User</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; average_revenue_per_paying_user(10000, 200)\n50.0\n</code></pre>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.average_revenue_per_user","title":"<code>average_revenue_per_user(total_revenue, total_users)</code>","text":"<p>Calculate Average Revenue Per User (ARPU).</p> <p>ARPU measures the average revenue generated per user or customer.</p> <p>Parameters:</p> Name Type Description Default <code>total_revenue</code> <code>(int, float, array - like)</code> <p>Total revenue for the period</p> required <code>total_users</code> <code>(int, float, array - like)</code> <p>Total number of users or customers</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Average Revenue Per User</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; average_revenue_per_user(10000, 500)\n20.0\n</code></pre>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.burn_rate","title":"<code>burn_rate(starting_capital, ending_capital, months)</code>","text":"<p>Calculate Monthly Burn Rate.</p> <p>Burn Rate is the rate at which a company is losing money.</p> <p>Parameters:</p> Name Type Description Default <code>starting_capital</code> <code>int or float</code> <p>Capital at the start of the period</p> required <code>ending_capital</code> <code>int or float</code> <p>Capital at the end of the period</p> required <code>months</code> <code>int or float</code> <p>Number of months in the period</p> required <p>Returns:</p> Type Description <code>float</code> <p>Monthly Burn Rate</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; burn_rate(100000, 70000, 6)\n5000.0\n</code></pre>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.churn_rate","title":"<code>churn_rate(customers_start, customers_end, new_customers)</code>","text":"<p>Calculate customer churn rate.</p> <p>Churn rate is the percentage of customers who stop using your product or service during a given time period.</p> <p>Parameters:</p> Name Type Description Default <code>customers_start</code> <code>(int, float, array - like)</code> <p>Number of customers at the start of the period</p> required <code>customers_end</code> <code>(int, float, array - like)</code> <p>Number of customers at the end of the period</p> required <code>new_customers</code> <code>(int, float, array - like)</code> <p>Number of new customers acquired during the period</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Churn rate as a percentage</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; churn_rate(100, 90, 10)\n20.0\n</code></pre>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.conversion_rate","title":"<code>conversion_rate(conversions, total_visitors)</code>","text":"<p>Calculate Conversion Rate.</p> <p>Conversion Rate is the percentage of visitors who take a desired action.</p> <p>Parameters:</p> Name Type Description Default <code>conversions</code> <code>(int, float, array - like)</code> <p>Number of conversions (desired actions taken)</p> required <code>total_visitors</code> <code>(int, float, array - like)</code> <p>Total number of visitors or users</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Conversion Rate as a percentage</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; conversion_rate(50, 1000)\n5.0\n</code></pre>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.customer_acquisition_cost","title":"<code>customer_acquisition_cost(marketing_costs, sales_costs, new_customers)</code>","text":"<p>Calculate Customer Acquisition Cost (CAC).</p> <p>CAC is the cost of convincing a potential customer to buy a product or service.</p> <p>Parameters:</p> Name Type Description Default <code>marketing_costs</code> <code>(int, float, array - like)</code> <p>Total marketing costs for the period</p> required <code>sales_costs</code> <code>(int, float, array - like)</code> <p>Total sales costs for the period</p> required <code>new_customers</code> <code>(int, float, array - like)</code> <p>Number of new customers acquired during the period</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Customer Acquisition Cost</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; customer_acquisition_cost(5000, 3000, 100)\n80.0\n</code></pre>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.customer_effort_score","title":"<code>customer_effort_score(effort_ratings, max_rating=7)</code>","text":"<p>Calculate Customer Effort Score (CES).</p> <p>CES measures how much effort a customer has to exert to use a product or service. Lower scores are better.</p> <p>Parameters:</p> Name Type Description Default <code>effort_ratings</code> <code>array - like</code> <p>Array of customer effort ratings</p> required <code>max_rating</code> <code>int or float</code> <p>Maximum possible rating value</p> <code>7</code> <p>Returns:</p> Type Description <code>float</code> <p>Customer Effort Score (average)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; customer_effort_score([2, 3, 1, 2, 4])\n2.4\n</code></pre>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.customer_engagement_score","title":"<code>customer_engagement_score(active_days, total_days)</code>","text":"<p>Calculate Customer Engagement Score.</p> <p>Customer Engagement Score measures how actively customers are using a product or service.</p> <p>Parameters:</p> Name Type Description Default <code>active_days</code> <code>int or float</code> <p>Number of days the customer was active</p> required <code>total_days</code> <code>int or float</code> <p>Total number of days in the period</p> required <p>Returns:</p> Type Description <code>float</code> <p>Customer Engagement Score as a percentage</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; customer_engagement_score(15, 30)\n50.0\n</code></pre>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.customer_lifetime_value","title":"<code>customer_lifetime_value(avg_revenue_per_customer, gross_margin, churn_rate_value, discount_rate=10.0)</code>","text":"<p>Calculate Customer Lifetime Value (CLV).</p> <p>CLV is the total worth to a business of a customer over the whole period of their relationship.</p> <p>Parameters:</p> Name Type Description Default <code>avg_revenue_per_customer</code> <code>int or float</code> <p>Average revenue per customer per period (e.g., monthly)</p> required <code>gross_margin</code> <code>int or float</code> <p>Gross margin percentage (0-100)</p> required <code>churn_rate_value</code> <code>int or float</code> <p>Churn rate percentage (0-100)</p> required <code>discount_rate</code> <code>int or float</code> <p>Annual discount rate for future cash flows (0-100)</p> <code>10.0</code> <p>Returns:</p> Type Description <code>float</code> <p>Customer Lifetime Value</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; customer_lifetime_value(100, 70, 5, 10)\n466.66\n</code></pre>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.customer_satisfaction_score","title":"<code>customer_satisfaction_score(satisfaction_ratings, max_rating=5)</code>","text":"<p>Calculate Customer Satisfaction Score (CSAT).</p> <p>CSAT measures how satisfied customers are with a product, service, or interaction.</p> <p>Parameters:</p> Name Type Description Default <code>satisfaction_ratings</code> <code>array - like</code> <p>Array of customer satisfaction ratings</p> required <code>max_rating</code> <code>int or float</code> <p>Maximum possible rating value</p> <code>5</code> <p>Returns:</p> Type Description <code>float</code> <p>Customer Satisfaction Score as a percentage</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; customer_satisfaction_score([4, 5, 3, 5, 4])\n84.0\n</code></pre>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.daily_active_users_ratio","title":"<code>daily_active_users_ratio(daily_active_users, total_users)</code>","text":"<p>Calculate Daily Active Users (DAU) Ratio.</p> <p>DAU Ratio measures the percentage of total users who are active on a daily basis.</p> <p>Parameters:</p> Name Type Description Default <code>daily_active_users</code> <code>int or float</code> <p>Number of daily active users</p> required <code>total_users</code> <code>int or float</code> <p>Total number of users</p> required <p>Returns:</p> Type Description <code>float</code> <p>Daily Active Users Ratio as a percentage</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; daily_active_users_ratio(500, 2000)\n25.0\n</code></pre>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.expansion_revenue_rate","title":"<code>expansion_revenue_rate(upsell_revenue, cross_sell_revenue, revenue_start)</code>","text":"<p>Calculate Expansion Revenue Rate.</p> <p>Expansion Revenue Rate is the percentage of additional revenue generated from existing customers.</p> <p>Parameters:</p> Name Type Description Default <code>upsell_revenue</code> <code>int or float</code> <p>Revenue from upselling to existing customers</p> required <code>cross_sell_revenue</code> <code>int or float</code> <p>Revenue from cross-selling to existing customers</p> required <code>revenue_start</code> <code>int or float</code> <p>Revenue at the start of the period</p> required <p>Returns:</p> Type Description <code>float</code> <p>Expansion Revenue Rate as a percentage</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; expansion_revenue_rate(1000, 500, 10000)\n15.0\n</code></pre>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.feature_adoption_rate","title":"<code>feature_adoption_rate(users_adopting_feature, total_users)</code>","text":"<p>Calculate Feature Adoption Rate.</p> <p>Feature Adoption Rate measures the percentage of users who adopt a specific feature.</p> <p>Parameters:</p> Name Type Description Default <code>users_adopting_feature</code> <code>int or float</code> <p>Number of users who adopted the feature</p> required <code>total_users</code> <code>int or float</code> <p>Total number of users</p> required <p>Returns:</p> Type Description <code>float</code> <p>Feature Adoption Rate as a percentage</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; feature_adoption_rate(300, 1000)\n30.0\n</code></pre>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.gross_margin","title":"<code>gross_margin(revenue, cost_of_goods_sold)</code>","text":"<p>Calculate Gross Margin.</p> <p>Gross Margin is the percentage of revenue that exceeds the cost of goods sold.</p> <p>Parameters:</p> Name Type Description Default <code>revenue</code> <code>int or float</code> <p>Total revenue</p> required <code>cost_of_goods_sold</code> <code>int or float</code> <p>Cost of goods sold</p> required <p>Returns:</p> Type Description <code>float</code> <p>Gross Margin as a percentage</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gross_margin(10000, 3000)\n70.0\n</code></pre>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.ltv_cac_ratio","title":"<code>ltv_cac_ratio(ltv, cac)</code>","text":"<p>Calculate LTV:CAC Ratio.</p> <p>LTV:CAC Ratio is a metric that compares the lifetime value of a customer to the cost of acquiring that customer.</p> <p>Parameters:</p> Name Type Description Default <code>ltv</code> <code>int or float</code> <p>Customer Lifetime Value</p> required <code>cac</code> <code>int or float</code> <p>Customer Acquisition Cost</p> required <p>Returns:</p> Type Description <code>float</code> <p>LTV:CAC Ratio</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ltv_cac_ratio(1000, 200)\n5.0\n</code></pre>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.monthly_active_users_ratio","title":"<code>monthly_active_users_ratio(monthly_active_users, total_users)</code>","text":"<p>Calculate Monthly Active Users (MAU) Ratio.</p> <p>MAU Ratio measures the percentage of total users who are active on a monthly basis.</p> <p>Parameters:</p> Name Type Description Default <code>monthly_active_users</code> <code>int or float</code> <p>Number of monthly active users</p> required <code>total_users</code> <code>int or float</code> <p>Total number of users</p> required <p>Returns:</p> Type Description <code>float</code> <p>Monthly Active Users Ratio as a percentage</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; monthly_active_users_ratio(1500, 2000)\n75.0\n</code></pre>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.monthly_recurring_revenue","title":"<code>monthly_recurring_revenue(paying_customers, avg_revenue_per_customer)</code>","text":"<p>Calculate Monthly Recurring Revenue (MRR).</p> <p>MRR is the predictable total revenue generated by all the active subscriptions in a month.</p> <p>Parameters:</p> Name Type Description Default <code>paying_customers</code> <code>(int, float, array - like)</code> <p>Number of paying customers</p> required <code>avg_revenue_per_customer</code> <code>(int, float, array - like)</code> <p>Average revenue per customer per month</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Monthly Recurring Revenue</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; monthly_recurring_revenue(100, 50)\n5000.0\n</code></pre>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.net_promoter_score","title":"<code>net_promoter_score(promoters, detractors, total_respondents)</code>","text":"<p>Calculate Net Promoter Score (NPS).</p> <p>NPS measures customer experience and predicts business growth.</p> <p>Parameters:</p> Name Type Description Default <code>promoters</code> <code>(int, float, array - like)</code> <p>Number of promoters (customers who rated 9-10)</p> required <code>detractors</code> <code>(int, float, array - like)</code> <p>Number of detractors (customers who rated 0-6)</p> required <code>total_respondents</code> <code>(int, float, array - like)</code> <p>Total number of survey respondents</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Net Promoter Score (ranges from -100 to 100)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; net_promoter_score(70, 10, 100)\n60.0\n</code></pre>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.payback_period","title":"<code>payback_period(cac, avg_monthly_revenue, gross_margin)</code>","text":"<p>Calculate CAC Payback Period in months.</p> <p>CAC Payback Period is the number of months it takes to recover the cost of acquiring a customer.</p> <p>Parameters:</p> Name Type Description Default <code>cac</code> <code>int or float</code> <p>Customer Acquisition Cost</p> required <code>avg_monthly_revenue</code> <code>int or float</code> <p>Average monthly revenue per customer</p> required <code>gross_margin</code> <code>int or float</code> <p>Gross margin percentage (0-100)</p> required <p>Returns:</p> Type Description <code>float</code> <p>CAC Payback Period in months</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; payback_period(1000, 100, 70)\n14.29\n</code></pre>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.retention_rate","title":"<code>retention_rate(customers_start, customers_end, new_customers)</code>","text":"<p>Calculate customer retention rate.</p> <p>Retention rate is the percentage of customers who remain with your product or service over a given time period.</p> <p>Parameters:</p> Name Type Description Default <code>customers_start</code> <code>(int, float, array - like)</code> <p>Number of customers at the start of the period</p> required <code>customers_end</code> <code>(int, float, array - like)</code> <p>Number of customers at the end of the period</p> required <code>new_customers</code> <code>(int, float, array - like)</code> <p>Number of new customers acquired during the period</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Retention rate as a percentage</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; retention_rate(100, 90, 10)\n80.0\n</code></pre>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.revenue_churn_rate","title":"<code>revenue_churn_rate(revenue_start, revenue_end, new_revenue)</code>","text":"<p>Calculate Revenue Churn Rate.</p> <p>Revenue Churn Rate is the percentage of revenue lost from existing customers in a given period.</p> <p>Parameters:</p> Name Type Description Default <code>revenue_start</code> <code>(int, float, array - like)</code> <p>Revenue at the start of the period</p> required <code>revenue_end</code> <code>(int, float, array - like)</code> <p>Revenue at the end of the period</p> required <code>new_revenue</code> <code>(int, float, array - like)</code> <p>New revenue acquired during the period</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Revenue Churn Rate as a percentage</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; revenue_churn_rate(10000, 9500, 1000)\n15.0\n</code></pre>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.roi","title":"<code>roi(revenue, costs)</code>","text":"<p>Calculate Return on Investment (ROI).</p> <p>ROI measures the return on an investment relative to its cost.</p> <p>Parameters:</p> Name Type Description Default <code>revenue</code> <code>(int, float, array - like)</code> <p>Revenue or return from the investment</p> required <code>costs</code> <code>(int, float, array - like)</code> <p>Cost of the investment</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Return on Investment as a percentage</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; roi(150, 100)\n50.0\n&gt;&gt;&gt; roi([150, 200, 250], [100, 120, 150])\narray([50., 66.67, 66.67])\n</code></pre>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.runway","title":"<code>runway(current_capital, monthly_burn_rate)</code>","text":"<p>Calculate Runway in months.</p> <p>Runway is the amount of time a company has before it runs out of money.</p> <p>Parameters:</p> Name Type Description Default <code>current_capital</code> <code>int or float</code> <p>Current capital</p> required <code>monthly_burn_rate</code> <code>int or float</code> <p>Monthly burn rate</p> required <p>Returns:</p> Type Description <code>float</code> <p>Runway in months</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; runway(100000, 5000)\n20.0\n</code></pre>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.stickiness_ratio","title":"<code>stickiness_ratio(daily_active_users, monthly_active_users)</code>","text":"<p>Calculate Stickiness Ratio (DAU/MAU).</p> <p>Stickiness Ratio measures how frequently active users engage with a product.</p> <p>Parameters:</p> Name Type Description Default <code>daily_active_users</code> <code>int or float</code> <p>Number of daily active users</p> required <code>monthly_active_users</code> <code>int or float</code> <p>Number of monthly active users</p> required <p>Returns:</p> Type Description <code>float</code> <p>Stickiness Ratio as a percentage</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; stickiness_ratio(500, 1500)\n33.33\n</code></pre>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.time_to_value","title":"<code>time_to_value(onboarding_time, setup_time, learning_time)</code>","text":"<p>Calculate Time to Value (TTV).</p> <p>Time to Value is the amount of time it takes for a customer to realize value from a product.</p> <p>Parameters:</p> Name Type Description Default <code>onboarding_time</code> <code>int or float</code> <p>Time spent on onboarding</p> required <code>setup_time</code> <code>int or float</code> <p>Time spent on setup</p> required <code>learning_time</code> <code>int or float</code> <p>Time spent on learning</p> required <p>Returns:</p> Type Description <code>float</code> <p>Time to Value</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; time_to_value(2, 3, 5)\n10.0\n</code></pre>"},{"location":"api/kpi/#pypulate.kpi.business_kpi.virality_coefficient","title":"<code>virality_coefficient(new_users, invites_sent, total_users)</code>","text":"<p>Calculate Virality Coefficient (K-factor).</p> <p>Virality Coefficient measures how many new users each existing user brings in.</p> <p>Parameters:</p> Name Type Description Default <code>new_users</code> <code>int or float</code> <p>Number of new users from invites</p> required <code>invites_sent</code> <code>int or float</code> <p>Number of invites sent</p> required <code>total_users</code> <code>int or float</code> <p>Total number of users</p> required <p>Returns:</p> Type Description <code>float</code> <p>Virality Coefficient</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; virality_coefficient(100, 500, 1000)\n0.1\n</code></pre>"},{"location":"api/moving_averages/","title":"Moving Averages API Reference","text":"<p>Moving Averages Module</p> <p>This module provides various moving average implementations for financial time series analysis. All functions use numpy arrays for input and output to ensure high performance.</p>"},{"location":"api/moving_averages/#pypulate.moving_averages.movingaverages.alma","title":"<code>alma(data, period=9, offset=0.85, sigma=6.0)</code>","text":"<p>Arnaud Legoux Moving Average (ALMA)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input price data</p> required <code>period</code> <code>int</code> <p>Window size for the moving average</p> <code>9</code> <code>offset</code> <code>float</code> <p>Controls tradeoff between smoothness and responsiveness (0-1)</p> <code>0.85</code> <code>sigma</code> <code>float</code> <p>Controls the filter width</p> <code>6.0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Arnaud Legoux moving average values</p>"},{"location":"api/moving_averages/#pypulate.moving_averages.movingaverages.ema","title":"<code>ema(data, period=9, alpha=None)</code>","text":"<p>Exponential Moving Average (EMA)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input price data</p> required <code>period</code> <code>int</code> <p>Window size for the moving average</p> <code>9</code> <code>alpha</code> <code>float</code> <p>Smoothing factor. If None, alpha = 2/(period+1)</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Exponential moving average values</p>"},{"location":"api/moving_averages/#pypulate.moving_averages.movingaverages.frama","title":"<code>frama(data, period=9, fc_period=198)</code>","text":"<p>Fractal Adaptive Moving Average (FRAMA)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input price data</p> required <code>period</code> <code>int</code> <p>Window size for the moving average</p> <code>9</code> <code>fc_period</code> <code>int</code> <p>Fractal cycle period</p> <code>198</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Fractal adaptive moving average values</p>"},{"location":"api/moving_averages/#pypulate.moving_averages.movingaverages.hma","title":"<code>hma(data, period=9)</code>","text":"<p>Hull Moving Average (HMA)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input price data</p> required <code>period</code> <code>int</code> <p>Window size for the moving average</p> <code>9</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Hull moving average values</p>"},{"location":"api/moving_averages/#pypulate.moving_averages.movingaverages.jma","title":"<code>jma(data, period=9, phase=0)</code>","text":"<p>Jurik Moving Average (JMA)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input price data</p> required <code>period</code> <code>int</code> <p>Window size for the moving average</p> <code>9</code> <code>phase</code> <code>float</code> <p>Phase parameter (-100 to 100)</p> <code>0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Jurik moving average values</p>"},{"location":"api/moving_averages/#pypulate.moving_averages.movingaverages.kama","title":"<code>kama(data, period=9, fast_period=2, slow_period=30)</code>","text":"<p>Kaufman Adaptive Moving Average (KAMA)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input price data</p> required <code>period</code> <code>int</code> <p>Window size for the efficiency ratio calculation</p> <code>9</code> <code>fast_period</code> <code>int</code> <p>Fast EMA period</p> <code>2</code> <code>slow_period</code> <code>int</code> <p>Slow EMA period</p> <code>30</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Kaufman adaptive moving average values</p>"},{"location":"api/moving_averages/#pypulate.moving_averages.movingaverages.laguerre_filter","title":"<code>laguerre_filter(data, gamma=0.8)</code>","text":"<p>Laguerre Filter</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input price data</p> required <code>gamma</code> <code>float</code> <p>Damping factor (0-1)</p> <code>0.8</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Laguerre filter values</p>"},{"location":"api/moving_averages/#pypulate.moving_averages.movingaverages.lsma","title":"<code>lsma(data, period=9)</code>","text":"<p>Least Squares Moving Average (LSMA)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input price data</p> required <code>period</code> <code>int</code> <p>Window size for the moving average</p> <code>9</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Least squares moving average values</p>"},{"location":"api/moving_averages/#pypulate.moving_averages.movingaverages.mcginley_dynamic","title":"<code>mcginley_dynamic(data, period=9, k=0.6)</code>","text":"<p>McGinley Dynamic Indicator</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input price data</p> required <code>period</code> <code>int</code> <p>Window size for the moving average</p> <code>9</code> <code>k</code> <code>float</code> <p>Adjustment factor</p> <code>0.6</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>McGinley dynamic indicator values</p>"},{"location":"api/moving_averages/#pypulate.moving_averages.movingaverages.modular_filter","title":"<code>modular_filter(data, period=9, phase=0.5)</code>","text":"<p>Modular Filter</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input price data</p> required <code>period</code> <code>int</code> <p>Window size for the filter</p> <code>9</code> <code>phase</code> <code>float</code> <p>Phase parameter (0-1)</p> <code>0.5</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Modular filter values</p>"},{"location":"api/moving_averages/#pypulate.moving_averages.movingaverages.rdma","title":"<code>rdma(data)</code>","text":"<p>Rex Dog Moving Average (RDMA)</p> <p>This implementation follows the original RexDog definition, which is the average of six SMAs with periods 5, 9, 24, 50, 100, and 200.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input price data</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Rex Dog moving average values</p>"},{"location":"api/moving_averages/#pypulate.moving_averages.movingaverages.sma","title":"<code>sma(data, period=9)</code>","text":"<p>Simple Moving Average (SMA)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input price data</p> required <code>period</code> <code>int</code> <p>Window size for the moving average</p> <code>9</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Simple moving average values</p>"},{"location":"api/moving_averages/#pypulate.moving_averages.movingaverages.smma","title":"<code>smma(data, period=9)</code>","text":"<p>Smoothed Moving Average (SMMA) or Running Moving Average (RMA)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input price data</p> required <code>period</code> <code>int</code> <p>Window size for the moving average</p> <code>9</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Smoothed moving average values</p>"},{"location":"api/moving_averages/#pypulate.moving_averages.movingaverages.t3","title":"<code>t3(data, period=9, vfactor=0.7)</code>","text":"<p>Tillson T3 Moving Average</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input price data</p> required <code>period</code> <code>int</code> <p>Window size for the moving average</p> <code>9</code> <code>vfactor</code> <code>float</code> <p>Volume factor (0-1)</p> <code>0.7</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>T3 moving average values</p>"},{"location":"api/moving_averages/#pypulate.moving_averages.movingaverages.tma","title":"<code>tma(data, period=9)</code>","text":"<p>Triangular Moving Average (TMA)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input price data</p> required <code>period</code> <code>int</code> <p>Window size for the moving average</p> <code>9</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Triangular moving average values</p>"},{"location":"api/moving_averages/#pypulate.moving_averages.movingaverages.vama","title":"<code>vama(data, volatility, period=9)</code>","text":"<p>Volatility-Adjusted Moving Average (VAMA)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input price data</p> required <code>volatility</code> <code>ndarray</code> <p>Volatility data corresponding to price data</p> required <code>period</code> <code>int</code> <p>Window size for the moving average</p> <code>9</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Volatility-adjusted moving average values</p>"},{"location":"api/moving_averages/#pypulate.moving_averages.movingaverages.vwma","title":"<code>vwma(data, volume, period=9)</code>","text":"<p>Volume-Weighted Moving Average (VWMA)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input price data</p> required <code>volume</code> <code>ndarray</code> <p>Volume data corresponding to price data</p> required <code>period</code> <code>int</code> <p>Window size for the moving average</p> <code>9</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Volume-weighted moving average values</p>"},{"location":"api/moving_averages/#pypulate.moving_averages.movingaverages.wma","title":"<code>wma(data, period=9)</code>","text":"<p>Weighted Moving Average (WMA)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input price data</p> required <code>period</code> <code>int</code> <p>Window size for the moving average</p> <code>9</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Weighted moving average values</p>"},{"location":"api/moving_averages/#pypulate.moving_averages.movingaverages.zlma","title":"<code>zlma(data, period=9)</code>","text":"<p>Zero-Lag Moving Average (ZLMA)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input price data</p> required <code>period</code> <code>int</code> <p>Window size for the moving average</p> <code>9</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Zero-lag moving average values</p>"},{"location":"api/optimization/","title":"Optimizations Reference","text":"<p>Portfolio Optimization Module</p> <p>This module provides various portfolio optimization methods including Mean-Variance Optimization, Minimum Variance Portfolio, Maximum Sharpe Ratio, Hierarchical Risk Parity, Black-Litterman, Kelly Criterion, and other common portfolio optimization techniques.</p>"},{"location":"api/optimization/#pypulate.allocation.optimization.black_litterman","title":"<code>black_litterman(returns, market_caps, views, view_confidences, tau=0.05, risk_free_rate=0.0)</code>","text":"<p>Implement Black-Litterman portfolio optimization.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>ndarray</code> <p>Matrix of asset returns where each column represents an asset</p> required <code>market_caps</code> <code>ndarray</code> <p>Array of market capitalizations for each asset</p> required <code>views</code> <code>dict</code> <p>Dictionary mapping asset indices to expected returns</p> required <code>view_confidences</code> <code>dict</code> <p>Dictionary mapping asset indices to confidence levels (0-1)</p> required <code>tau</code> <code>float</code> <p>Uncertainty in the prior distribution</p> <code>0.05</code> <code>risk_free_rate</code> <code>float</code> <p>Risk-free rate</p> <code>0.0</code> <p>Returns:</p> Type Description <code>tuple</code> <p>(optimal_weights, portfolio_return, portfolio_risk)</p>"},{"location":"api/optimization/#pypulate.allocation.optimization.equal_weight_portfolio","title":"<code>equal_weight_portfolio(returns)</code>","text":"<p>Create an equal-weighted portfolio.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>ndarray</code> <p>Matrix of asset returns where each column represents an asset</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>(weights, portfolio_return, portfolio_risk)</p>"},{"location":"api/optimization/#pypulate.allocation.optimization.hierarchical_risk_parity","title":"<code>hierarchical_risk_parity(returns, linkage_method='single', distance_metric='euclidean')</code>","text":"<p>Implement Hierarchical Risk Parity (HRP) portfolio optimization.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>ndarray</code> <p>Matrix of asset returns where each column represents an asset</p> required <code>linkage_method</code> <code>str</code> <p>Linkage method for hierarchical clustering ('single', 'complete', 'average', 'ward')</p> <code>'single'</code> <code>distance_metric</code> <code>str</code> <p>Distance metric for clustering ('euclidean', 'correlation')</p> <code>'euclidean'</code> <p>Returns:</p> Type Description <code>tuple</code> <p>(optimal_weights, portfolio_return, portfolio_risk)</p>"},{"location":"api/optimization/#pypulate.allocation.optimization.kelly_criterion_optimization","title":"<code>kelly_criterion_optimization(returns, risk_free_rate=0.0, constraints=None, kelly_fraction=1.0)</code>","text":"<p>Implement Kelly Criterion portfolio optimization.</p> <p>The Kelly Criterion determines the optimal fraction of capital to allocate to each investment to maximize long-term growth rate.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>ndarray</code> <p>Matrix of asset returns where each column represents an asset</p> required <code>risk_free_rate</code> <code>float</code> <p>Risk-free rate</p> <code>0.0</code> <code>constraints</code> <code>list of dict</code> <p>List of constraints for the optimization problem</p> <code>None</code> <code>kelly_fraction</code> <code>float</code> <p>Fraction of Kelly Criterion to use (e.g., 0.5 for half-Kelly)</p> <code>1.0</code> <p>Returns:</p> Type Description <code>tuple</code> <p>(optimal_weights, portfolio_return, portfolio_risk)</p> Notes <p>The Kelly Criterion maximizes the expected logarithmic growth rate of wealth. The full Kelly Criterion can be aggressive, so practitioners often use a fraction of the Kelly Criterion (e.g., half-Kelly) for more conservative position sizing.</p>"},{"location":"api/optimization/#pypulate.allocation.optimization.market_cap_weight_portfolio","title":"<code>market_cap_weight_portfolio(market_caps)</code>","text":"<p>Create a market-cap weighted portfolio.</p> <p>Parameters:</p> Name Type Description Default <code>market_caps</code> <code>ndarray</code> <p>Array of market capitalizations for each asset</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Market-cap weighted portfolio weights</p>"},{"location":"api/optimization/#pypulate.allocation.optimization.maximum_diversification_portfolio","title":"<code>maximum_diversification_portfolio(returns, constraints=None)</code>","text":"<p>Find the portfolio that maximizes diversification ratio.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>ndarray</code> <p>Matrix of asset returns where each column represents an asset</p> required <code>constraints</code> <code>list of dict</code> <p>List of constraints for the optimization problem</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>(optimal_weights, portfolio_return, portfolio_risk)</p>"},{"location":"api/optimization/#pypulate.allocation.optimization.maximum_sharpe_ratio","title":"<code>maximum_sharpe_ratio(returns, risk_free_rate=0.0, constraints=None)</code>","text":"<p>Find the portfolio with maximum Sharpe ratio.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>ndarray</code> <p>Matrix of asset returns where each column represents an asset</p> required <code>risk_free_rate</code> <code>float</code> <p>Risk-free rate for Sharpe ratio calculation</p> <code>0.0</code> <code>constraints</code> <code>list of dict</code> <p>List of constraints for the optimization problem</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>(optimal_weights, portfolio_return, portfolio_risk)</p>"},{"location":"api/optimization/#pypulate.allocation.optimization.mean_variance_optimization","title":"<code>mean_variance_optimization(returns, target_return=None, risk_free_rate=0.0, constraints=None)</code>","text":"<p>Perform Mean-Variance Optimization to find optimal portfolio weights.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>ndarray</code> <p>Matrix of asset returns where each column represents an asset</p> required <code>target_return</code> <code>float</code> <p>Target portfolio return. If None, maximizes Sharpe ratio</p> <code>None</code> <code>risk_free_rate</code> <code>float</code> <p>Risk-free rate for Sharpe ratio calculation</p> <code>0.0</code> <code>constraints</code> <code>list of dict</code> <p>List of constraints for the optimization problem</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>(optimal_weights, portfolio_return, portfolio_risk)</p>"},{"location":"api/optimization/#pypulate.allocation.optimization.minimum_variance_portfolio","title":"<code>minimum_variance_portfolio(returns, constraints=None)</code>","text":"<p>Find the portfolio with minimum variance.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>ndarray</code> <p>Matrix of asset returns where each column represents an asset</p> required <code>constraints</code> <code>list of dict</code> <p>List of constraints for the optimization problem</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>(optimal_weights, portfolio_return, portfolio_risk)</p>"},{"location":"api/optimization/#pypulate.allocation.optimization.risk_parity_portfolio","title":"<code>risk_parity_portfolio(returns, constraints=None)</code>","text":"<p>Find the portfolio where risk is equally distributed across assets.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>ndarray</code> <p>Matrix of asset returns where each column represents an asset</p> required <code>constraints</code> <code>list of dict</code> <p>List of constraints for the optimization problem</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>(optimal_weights, portfolio_return, portfolio_risk)</p>"},{"location":"api/parray/","title":"Parray API Reference","text":"<p>Parray Module</p> <p>This module provides a NumPy array extension that supports method chaining for financial time series analysis, including moving averages and transforms.</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray","title":"<code>Parray</code>","text":"<p>               Bases: <code>ndarray</code></p> <p>A wrapper around numpy arrays that provides method chaining for financial analysis.</p> <p>This class allows for fluent method chaining like: data.ema(9).sma(20)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pypulate.dtypes import Parray\n&gt;&gt;&gt; data = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n&gt;&gt;&gt; ts = Parray(data)\n&gt;&gt;&gt; result = ts.ema(3).sma(2)\n</code></pre>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.adaptive_kalman_filter","title":"<code>adaptive_kalman_filter(process_variance_init=1e-05, measurement_variance_init=0.001, adaptation_rate=0.01, window_size=10, initial_state=None, initial_covariance=1.0)</code>","text":"<p>Apply an adaptive Kalman filter to the time series.</p> <p>Parameters:</p> Name Type Description Default <code>process_variance_init</code> <code>float</code> <p>Initial process noise variance (Q)</p> <code>1e-5</code> <code>measurement_variance_init</code> <code>float</code> <p>Initial measurement noise variance (R)</p> <code>1e-3</code> <code>adaptation_rate</code> <code>float</code> <p>Rate at which the filter adapts to changes</p> <code>0.01</code> <code>window_size</code> <code>int</code> <p>Size of the window for innovation estimation</p> <code>10</code> <code>initial_state</code> <code>float</code> <p>Initial state estimate. If None, the first data point is used</p> <code>None</code> <code>initial_covariance</code> <code>float</code> <p>Initial estimate covariance</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Parray</code> <p>Filtered time series</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.adx","title":"<code>adx(period=14)</code>","text":"<p>Calculate Average Directional Index (ADX).</p> <p>ADX measures the strength of a trend.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>Number of periods for calculation</p> <code>14</code> <p>Returns:</p> Type Description <code>Parray</code> <p>ADX values</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.atr","title":"<code>atr(high=None, low=None, period=14)</code>","text":"<p>Calculate Average True Range (ATR) over a specified period.</p> <p>ATR measures market volatility by decomposing the entire range of an asset price.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <code>ndarray</code> <p>High prices. If None, assumes self contains close prices and high=low=close</p> <code>None</code> <code>low</code> <code>ndarray</code> <p>Low prices. If None, assumes self contains close prices and high=low=close</p> <code>None</code> <code>period</code> <code>int</code> <p>Number of periods to calculate ATR</p> <code>14</code> <p>Returns:</p> Type Description <code>Parray</code> <p>ATR values</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.bollinger_bands","title":"<code>bollinger_bands(period=20, std_dev=2.0)</code>","text":"<p>Calculate Bollinger Bands over a specified period.</p> <p>Bollinger Bands consist of a middle band (SMA), an upper band (SMA + kstd), and a lower band (SMA - kstd).</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>Number of periods for the moving average</p> <code>20</code> <code>std_dev</code> <code>float</code> <p>Number of standard deviations for the upper and lower bands</p> <code>2.0</code> <p>Returns:</p> Type Description <code>tuple of Parray</code> <p>Tuple containing (upper_band, middle_band, lower_band)</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.butterworth_filter","title":"<code>butterworth_filter(cutoff, order=4, filter_type='lowpass', fs=1.0)</code>","text":"<p>Apply a Butterworth filter to the time series.</p> <p>Parameters:</p> Name Type Description Default <code>cutoff</code> <code>float or tuple of float</code> <p>Cutoff frequency. For lowpass and highpass, this is a scalar. For bandpass and bandstop, this is a tuple of (low, high)</p> required <code>order</code> <code>int</code> <p>Filter order</p> <code>4</code> <code>filter_type</code> <code>str</code> <p>Filter type: 'lowpass', 'highpass', 'bandpass', or 'bandstop'</p> <code>'lowpass'</code> <code>fs</code> <code>float</code> <p>Sampling frequency</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Parray</code> <p>Filtered time series</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.cci","title":"<code>cci(period=20, constant=0.015)</code>","text":"<p>Calculate Commodity Channel Index (CCI).</p> <p>CCI measures the current price level relative to an average price level over a given period.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>Number of periods for calculation</p> <code>20</code> <code>constant</code> <code>float</code> <p>Scaling constant</p> <code>0.015</code> <p>Returns:</p> Type Description <code>Parray</code> <p>CCI values</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.crossover","title":"<code>crossover(other)</code>","text":"<p>Detect when this series crosses above another series or value.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>array - like or scalar</code> <p>The other series or value to compare against</p> required <p>Returns:</p> Type Description <code>Parray</code> <p>Boolean array where True indicates a crossover (this crosses above other)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; prices = Parray([10, 11, 12, 11, 10, 9, 10, 11, 12])\n&gt;&gt;&gt; sma = prices.sma(3)\n&gt;&gt;&gt; crossovers = prices.crossover(sma)\n</code></pre>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.crossunder","title":"<code>crossunder(other)</code>","text":"<p>Detect when this series crosses below another series or value.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>array - like or scalar</code> <p>The other series or value to compare against</p> required <p>Returns:</p> Type Description <code>Parray</code> <p>Boolean array where True indicates a crossunder (this crosses below other)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; prices = Parray([10, 11, 12, 11, 10, 9, 10, 11, 12])\n&gt;&gt;&gt; sma = prices.sma(3)\n&gt;&gt;&gt; crossunders = prices.crossunder(sma)\n</code></pre>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.diff","title":"<code>diff(periods=1)</code>","text":"<p>Calculate difference between consecutive values.</p> <p>Parameters:</p> Name Type Description Default <code>periods</code> <code>int</code> <p>Number of periods to calculate difference over</p> <code>1</code> <p>Returns:</p> Type Description <code>Parray</code> <p>Difference values</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.donchian_channels","title":"<code>donchian_channels(high=None, low=None, period=20)</code>","text":"<p>Calculate Donchian Channels over a specified period.</p> <p>Donchian Channels consist of an upper band (highest high), a lower band (lowest low), and a middle band (average of upper and lower).</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <code>ndarray</code> <p>High prices. If None, uses self</p> <code>None</code> <code>low</code> <code>ndarray</code> <p>Low prices. If None, uses self</p> <code>None</code> <code>period</code> <code>int</code> <p>Number of periods for the channels</p> <code>20</code> <p>Returns:</p> Type Description <code>tuple of Parray</code> <p>Tuple containing (upper_channel, middle_channel, lower_channel)</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.ema","title":"<code>ema(period=9, alpha=None)</code>","text":"<p>Apply Exponential Moving Average</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.frama","title":"<code>frama(period=9, fc_period=198)</code>","text":"<p>Apply Fractal Adaptive Moving Average</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.hampel_filter","title":"<code>hampel_filter(window_size=5, n_sigmas=3.0)</code>","text":"<p>Apply a Hampel filter to the time series to remove outliers.</p> <p>Parameters:</p> Name Type Description Default <code>window_size</code> <code>int</code> <p>Size of the window (number of points on each side of the current point)</p> <code>5</code> <code>n_sigmas</code> <code>float</code> <p>Number of standard deviations to use for outlier detection</p> <code>3.0</code> <p>Returns:</p> Type Description <code>Parray</code> <p>Filtered time series</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.historical_volatility","title":"<code>historical_volatility(period=21, annualization_factor=252)</code>","text":"<p>Calculate historical volatility over a specified period.</p> <p>Historical volatility is the standard deviation of log returns, typically annualized.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>Number of periods to calculate volatility</p> <code>21</code> <code>annualization_factor</code> <code>int</code> <p>Factor to annualize volatility (252 for daily data, 52 for weekly, 12 for monthly)</p> <code>252</code> <p>Returns:</p> Type Description <code>Parray</code> <p>Historical volatility values as percentage</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.hma","title":"<code>hma(period=9)</code>","text":"<p>Apply Hull Moving Average</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.hodrick_prescott_filter","title":"<code>hodrick_prescott_filter(lambda_param=1600.0)</code>","text":"<p>Apply the Hodrick-Prescott filter to decompose the time series into trend and cycle components.</p> <p>Parameters:</p> Name Type Description Default <code>lambda_param</code> <code>float</code> <p>Smoothing parameter. The larger the value, the smoother the trend component</p> <code>1600.0</code> <p>Returns:</p> Type Description <code>tuple of Parray</code> <p>Tuple containing (trend, cycle) components</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.kalman_filter","title":"<code>kalman_filter(process_variance=1e-05, measurement_variance=0.001, initial_state=None, initial_covariance=1.0)</code>","text":"<p>Apply a standard Kalman filter to the time series.</p> <p>Parameters:</p> Name Type Description Default <code>process_variance</code> <code>float</code> <p>Process noise variance (Q)</p> <code>1e-5</code> <code>measurement_variance</code> <code>float</code> <p>Measurement noise variance (R)</p> <code>1e-3</code> <code>initial_state</code> <code>float</code> <p>Initial state estimate. If None, the first data point is used</p> <code>None</code> <code>initial_covariance</code> <code>float</code> <p>Initial estimate covariance</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Parray</code> <p>Filtered time series</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.kama","title":"<code>kama(period=9, fast_period=2, slow_period=30)</code>","text":"<p>Apply Kaufman Adaptive Moving Average</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.keltner_channels","title":"<code>keltner_channels(high=None, low=None, period=20, atr_period=10, multiplier=2.0)</code>","text":"<p>Calculate Keltner Channels over a specified period.</p> <p>Keltner Channels consist of a middle band (EMA), an upper band (EMA + kATR), and a lower band (EMA - kATR).</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <code>ndarray</code> <p>High prices. If None, assumes self contains close prices and high=low=close</p> <code>None</code> <code>low</code> <code>ndarray</code> <p>Low prices. If None, assumes self contains close prices and high=low=close</p> <code>None</code> <code>period</code> <code>int</code> <p>Number of periods for the EMA</p> <code>20</code> <code>atr_period</code> <code>int</code> <p>Number of periods for the ATR</p> <code>10</code> <code>multiplier</code> <code>float</code> <p>Multiplier for the ATR</p> <code>2.0</code> <p>Returns:</p> Type Description <code>tuple of Parray</code> <p>Tuple containing (upper_channel, middle_channel, lower_channel)</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.log","title":"<code>log()</code>","text":"<p>Calculate the natural logarithm of the time series.</p> <p>Returns:</p> Type Description <code>Parray</code> <p>Natural logarithm of the time series</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.macd","title":"<code>macd(fast_period=12, slow_period=26, signal_period=9)</code>","text":"<p>Calculate Moving Average Convergence Divergence (MACD).</p> <p>MACD is a trend-following momentum indicator that shows the relationship between two moving averages of a security's price.</p> <p>Parameters:</p> Name Type Description Default <code>fast_period</code> <code>int</code> <p>Period for the fast EMA</p> <code>12</code> <code>slow_period</code> <code>int</code> <p>Period for the slow EMA</p> <code>26</code> <code>signal_period</code> <code>int</code> <p>Period for the signal line (EMA of MACD line)</p> <code>9</code> <p>Returns:</p> Type Description <code>tuple of Parray</code> <p>Tuple containing (macd_line, signal_line, histogram)</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.mcginley_dynamic","title":"<code>mcginley_dynamic(period=9, k=0.6)</code>","text":"<p>Apply McGinley Dynamic Indicator</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.median_filter","title":"<code>median_filter(kernel_size=3)</code>","text":"<p>Apply a median filter to the time series.</p> <p>Parameters:</p> Name Type Description Default <code>kernel_size</code> <code>int</code> <p>Size of the filter kernel</p> <code>3</code> <p>Returns:</p> Type Description <code>Parray</code> <p>Filtered time series</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.momentum","title":"<code>momentum(period=14)</code>","text":"<p>Calculate momentum over a specified period.</p> <p>Momentum measures the amount that a price has changed over a given period.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>Number of periods to calculate momentum</p> <code>14</code> <p>Returns:</p> Type Description <code>Parray</code> <p>Momentum values</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.percent_change","title":"<code>percent_change(periods=1)</code>","text":"<p>Calculate percentage change between consecutive periods.</p> <p>Parameters:</p> Name Type Description Default <code>periods</code> <code>int</code> <p>Number of periods to calculate change over</p> <code>1</code> <p>Returns:</p> Type Description <code>Parray</code> <p>Percentage change values</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.roc","title":"<code>roc(period=14)</code>","text":"<p>Calculate Rate of Change (ROC) over a specified period.</p> <p>ROC measures the percentage change in price over a given period.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>Number of periods to calculate ROC</p> <code>14</code> <p>Returns:</p> Type Description <code>Parray</code> <p>ROC values in percentage</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.rolling_max","title":"<code>rolling_max(period=14)</code>","text":"<p>Calculate rolling maximum over a specified period.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>Window size for rolling maximum</p> <code>14</code> <p>Returns:</p> Type Description <code>Parray</code> <p>Rolling maximum values</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.rolling_min","title":"<code>rolling_min(period=14)</code>","text":"<p>Calculate rolling minimum over a specified period.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>Window size for rolling minimum</p> <code>14</code> <p>Returns:</p> Type Description <code>Parray</code> <p>Rolling minimum values</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.rolling_std","title":"<code>rolling_std(period=14)</code>","text":"<p>Calculate rolling standard deviation over a specified period.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>Window size for rolling standard deviation</p> <code>14</code> <p>Returns:</p> Type Description <code>Parray</code> <p>Rolling standard deviation values</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.rolling_var","title":"<code>rolling_var(period=14)</code>","text":"<p>Calculate rolling variance over a specified period.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>Window size for rolling variance</p> <code>14</code> <p>Returns:</p> Type Description <code>Parray</code> <p>Rolling variance values</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.rsi","title":"<code>rsi(period=14, smoothing_type='sma')</code>","text":"<p>Calculate Relative Strength Index (RSI) over a specified period.</p> <p>RSI measures the speed and change of price movements, indicating overbought (&gt;70) or oversold (&lt;30) conditions.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>Number of periods to calculate RSI</p> <code>14</code> <code>smoothing_type</code> <code>str</code> <p>Type of smoothing to use: 'sma' (Simple Moving Average) or  'ema' (Exponential Moving Average)</p> <code>'sma'</code> <p>Returns:</p> Type Description <code>Parray</code> <p>RSI values (0-100)</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.savitzky_golay_filter","title":"<code>savitzky_golay_filter(window_length=11, polyorder=3, deriv=0, delta=1.0)</code>","text":"<p>Apply a Savitzky-Golay filter to the time series.</p> <p>Parameters:</p> Name Type Description Default <code>window_length</code> <code>int</code> <p>Length of the filter window (must be odd)</p> <code>11</code> <code>polyorder</code> <code>int</code> <p>Order of the polynomial used to fit the samples</p> <code>3</code> <code>deriv</code> <code>int</code> <p>Order of the derivative to compute</p> <code>0</code> <code>delta</code> <code>float</code> <p>Spacing of the samples to which the filter is applied</p> <code>1.0</code> <p>Returns:</p> Type Description <code>Parray</code> <p>Filtered time series</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.slope","title":"<code>slope(period=5)</code>","text":"<p>Calculate the slope of the time series over a specified period.</p> <p>This method uses linear regression to calculate the slope of the line that best fits the data over the specified period.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>Number of points to use for slope calculation</p> <code>5</code> <p>Returns:</p> Type Description <code>Parray</code> <p>Slope values for each point in the time series</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.sma","title":"<code>sma(period=9)</code>","text":"<p>Apply Simple Moving Average</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.smma","title":"<code>smma(period=9)</code>","text":"<p>Apply Smoothed Moving Average</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.stochastic_oscillator","title":"<code>stochastic_oscillator(high, low, k_period=14, d_period=3)</code>","text":"<p>Calculate Stochastic Oscillator.</p> <p>The Stochastic Oscillator is a momentum indicator that shows the location of the close relative to the high-low range over a set number of periods.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <code>ndarray</code> <p>High prices. If None, assumes self contains close prices and high=low=self</p> required <code>low</code> <code>ndarray</code> <p>Low prices. If None, assumes self contains close prices and high=low=self</p> required <code>k_period</code> <code>int</code> <p>Number of periods for %K</p> <code>14</code> <code>d_period</code> <code>int</code> <p>Number of periods for %D (moving average of %K)</p> <code>3</code> <p>Returns:</p> Type Description <code>tuple of Parray</code> <p>Tuple containing (%K, %D)</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.t3","title":"<code>t3(period=9, vfactor=0.7)</code>","text":"<p>Apply Tillson T3 Moving Average</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.tma","title":"<code>tma(period=9)</code>","text":"<p>Apply Triangular Moving Average</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.tsi","title":"<code>tsi(long_period=25, short_period=13, signal_period=7)</code>","text":"<p>Calculate True Strength Index (TSI).</p> <p>TSI is a momentum oscillator that helps identify trends and reversals.</p> <p>Parameters:</p> Name Type Description Default <code>long_period</code> <code>int</code> <p>Long period for double smoothing</p> <code>25</code> <code>short_period</code> <code>int</code> <p>Short period for double smoothing</p> <code>13</code> <code>signal_period</code> <code>int</code> <p>Period for the signal line</p> <code>7</code> <p>Returns:</p> Type Description <code>tuple of Parray</code> <p>Tuple containing (tsi_line, signal_line)</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.typical_price","title":"<code>typical_price(high, low)</code>","text":"<p>Calculate the typical price from close, high, and low prices.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <code>ndarray</code> <p>High prices. If None, uses self</p> required <code>low</code> <code>ndarray</code> <p>Low prices. If None, uses self</p> required <p>Returns:</p> Type Description <code>Parray</code> <p>Typical price values</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.volatility_ratio","title":"<code>volatility_ratio(period=21, smooth_period=5)</code>","text":"<p>Calculate Volatility Ratio over a specified period.</p> <p>Volatility Ratio compares recent volatility to historical volatility. Values above 1 indicate increasing volatility, values below 1 indicate decreasing volatility.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>Number of periods for historical volatility</p> <code>21</code> <code>smooth_period</code> <code>int</code> <p>Number of periods to smooth the ratio</p> <code>5</code> <p>Returns:</p> Type Description <code>Parray</code> <p>Volatility Ratio values</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.williams_r","title":"<code>williams_r(high=None, low=None, period=14)</code>","text":"<p>Calculate Williams %R.</p> <p>Williams %R is a momentum indicator that measures overbought and oversold levels.</p> <p>Parameters:</p> Name Type Description Default <code>high</code> <code>ndarray</code> <p>High prices. If None, assumes self contains close prices and high=low=self</p> <code>None</code> <code>low</code> <code>ndarray</code> <p>Low prices. If None, assumes self contains close prices and high=low=self</p> <code>None</code> <code>period</code> <code>int</code> <p>Number of periods for calculation</p> <code>14</code> <p>Returns:</p> Type Description <code>Parray</code> <p>Williams %R values (-100 to 0)</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.wma","title":"<code>wma(period=9)</code>","text":"<p>Apply Weighted Moving Average</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.zigzag","title":"<code>zigzag(threshold=0.03)</code>","text":"<p>Extract zigzag pivot points from price data based on a percentage threshold.</p> <p>Parameters:</p> Name Type Description Default <code>threshold</code> <code>float</code> <p>Minimum percentage change required to identify a new pivot point (0.03 = 3%)</p> <code>0.03</code> <p>Returns:</p> Type Description <code>Parray</code> <p>2D array of zigzag points with shape (n, 2), where each row contains [index, price]</p> Notes <p>The algorithm identifies significant price movements while filtering out minor fluctuations. It marks pivot points where the price changes direction by at least the specified threshold percentage.</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.zlma","title":"<code>zlma(period=9)</code>","text":"<p>Apply Zero-Lag Moving Average</p>"},{"location":"api/parray/#pypulate.dtypes.parray.Parray.zscore","title":"<code>zscore(period=14)</code>","text":"<p>Calculate rolling z-score over a specified period.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>Window size for rolling z-score calculation</p> <code>14</code> <p>Returns:</p> Type Description <code>Parray</code> <p>Rolling z-score values</p>"},{"location":"api/portfolio/","title":"Portfolio API Reference","text":"<p>Portfolio Module</p> <p>This module provides a class for calculating various portfolio metrics including returns, risk-adjusted performance, and risk measurements.</p>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio","title":"<code>Portfolio</code>","text":"<p>A class for calculating various portfolio metrics and assessing portfolio health.</p> <p>This class provides methods for calculating portfolio returns, risk-adjusted performance metrics, and risk measurements, while maintaining state to assess overall portfolio health.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pypulate.dtypes import Portfolio\n&gt;&gt;&gt; portfolio = Portfolio()\n&gt;&gt;&gt; returns = portfolio.simple_return(105, 100)\n&gt;&gt;&gt; sharpe = portfolio.sharpe_ratio([0.01, 0.02, -0.01, 0.03, 0.01])\n&gt;&gt;&gt; health = portfolio.health\n</code></pre>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.health","title":"<code>health</code>  <code>property</code>","text":"<p>Calculate and return the overall health of the portfolio based on stored metrics.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing: - overall_score: Float between 0 and 100 - status: String indicating health status - components: Dictionary of component scores and metrics     - returns: Return metrics and score     - risk_adjusted: Risk-adjusted performance metrics and score     - risk: Risk metrics and score</p>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the Portfolio class with empty state.</p>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.annualized_return","title":"<code>annualized_return(total_return, years)</code>","text":"<p>Calculate the annualized return from a total return over a period of years.</p> <p>Parameters:</p> Name Type Description Default <code>total_return</code> <code>float or array - like</code> <p>The total return over the entire period as a decimal</p> required <code>years</code> <code>float or array - like</code> <p>The number of years in the period</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>The annualized return as a decimal If array inputs are provided, returns an array of annualized returns</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; annualized_return(0.2, 2)\n0.09544511501033215\n&gt;&gt;&gt; annualized_return([0.2, 0.3, 0.15], [2, 3, 1.5])\n[0.09544512, 0.09139288, 0.0976534 ]\n&gt;&gt;&gt; annualized_return(np.array([0.4, 0.5]), 2)\n[0.18321596, 0.22474487]\n</code></pre>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.arithmetic_return","title":"<code>arithmetic_return(prices)</code>","text":"<p>Calculate the arithmetic average return from a series of prices.</p> <p>Parameters:</p> Name Type Description Default <code>prices</code> <code>array - like</code> <p>Array or list of prices</p> required <p>Returns:</p> Type Description <code>float</code> <p>The arithmetic average return as a decimal</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; arithmetic_return([100, 105, 103, 108, 110])\n0.024503647197821957\n</code></pre>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.benchmark_alpha","title":"<code>benchmark_alpha(returns, benchmark_returns)</code>","text":"<p>Calculate the benchmark alpha, which is the difference between portfolio return and benchmark return.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>array - like</code> <p>Array of portfolio returns</p> required <code>benchmark_returns</code> <code>array - like</code> <p>Array of benchmark returns for the same periods</p> required <p>Returns:</p> Type Description <code>float</code> <p>The benchmark alpha (difference in mean returns)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; benchmark_alpha([0.01, 0.02, -0.01, 0.03, 0.01], [0.005, 0.01, -0.005, 0.02, 0.005])\n0.005\n</code></pre>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.beta_adjusted_return","title":"<code>beta_adjusted_return(portfolio_return, benchmark_return, portfolio_beta)</code>","text":"<p>Calculate the beta-adjusted return (alpha) of a portfolio.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio_return</code> <code>float or array - like</code> <p>The return of the portfolio as a decimal</p> required <code>benchmark_return</code> <code>float or array - like</code> <p>The return of the benchmark as a decimal</p> required <code>portfolio_beta</code> <code>float or array - like</code> <p>The beta of the portfolio relative to the benchmark</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>The beta-adjusted return (alpha) as a decimal If array inputs are provided, returns an array of beta-adjusted returns</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; beta_adjusted_return(0.12, 0.10, 1.2)\n0.0\n&gt;&gt;&gt; beta_adjusted_return([0.12, 0.15], [0.10, 0.08], 1.2)\n[0.   , 0.054]\n&gt;&gt;&gt; beta_adjusted_return(0.12, 0.10, [1.2, 1.5])\n[ 0.  , -0.03]\n</code></pre>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.calmar_ratio","title":"<code>calmar_ratio(returns, max_drawdown=None, annualization_factor=1.0)</code>","text":"<p>Calculate the Calmar ratio, which measures return relative to maximum drawdown.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>array - like</code> <p>Array of portfolio returns</p> required <code>max_drawdown</code> <code>float</code> <p>Maximum drawdown as a positive decimal. If None, it will be calculated from returns.</p> <code>None</code> <code>annualization_factor</code> <code>float</code> <p>Factor to annualize returns</p> <code>1.0</code> <p>Returns:</p> Type Description <code>float</code> <p>The Calmar ratio</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; calmar_ratio([0.01, 0.02, -0.01, 0.03, 0.01], 0.15, 252)\n0.8\n</code></pre>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.capm_alpha","title":"<code>capm_alpha(returns, benchmark_returns, risk_free_rate=0.0)</code>","text":"<p>Calculate the CAPM alpha (Jensen's alpha) and related statistics.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>array - like</code> <p>Array of portfolio returns</p> required <code>benchmark_returns</code> <code>array - like</code> <p>Array of benchmark returns for the same periods</p> required <code>risk_free_rate</code> <code>float or array - like</code> <p>Risk-free rate for the same period as returns</p> <code>0.0</code> <p>Returns:</p> Type Description <code>tuple</code> <p>(alpha, beta, r_squared, p_value, std_err) - alpha: The CAPM alpha (intercept) - beta: The CAPM beta (slope) - r_squared: The R-squared of the regression - p_value: The p-value for alpha - std_err: The standard error of alpha</p>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.capm_beta","title":"<code>capm_beta(portfolio_returns, market_returns)</code>","text":"<p>Calculate the CAPM beta of a portfolio.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio_returns</code> <code>list or ndarray</code> <p>Array or list of portfolio returns</p> required <code>market_returns</code> <code>list or ndarray</code> <p>Array or list of market returns</p> required <p>Returns:</p> Type Description <code>float</code> <p>CAPM beta</p> Notes <p>Beta measures the sensitivity of portfolio returns to market returns. It is the covariance of portfolio returns and market returns divided by the variance of market returns.</p>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.conditional_value_at_risk","title":"<code>conditional_value_at_risk(returns, confidence_level=0.95, method='historical', current_value=1.0)</code>","text":"<p>Calculate the Conditional Value-at-Risk (CVaR) of a portfolio.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>list or ndarray</code> <p>Array or list of returns</p> required <code>confidence_level</code> <code>float</code> <p>Confidence level for CVaR calculation (e.g., 0.95 for 95% confidence)</p> <code>0.95</code> <code>method</code> <code>str</code> <p>Method for calculating CVaR ('historical' or 'parametric')</p> <code>'historical'</code> <code>current_value</code> <code>float</code> <p>Current value of the portfolio</p> <code>1.0</code> <p>Returns:</p> Type Description <code>float</code> <p>Conditional Value-at-Risk (CVaR) as a positive number representing the potential loss</p> Notes <p>CVaR, also known as Expected Shortfall, measures the expected loss given that the loss exceeds the VaR threshold. It provides a more conservative risk measure than VaR.</p>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.correlation_matrix","title":"<code>correlation_matrix(returns_matrix)</code>","text":"<p>Calculate the correlation matrix of returns.</p> <p>Parameters:</p> Name Type Description Default <code>returns_matrix</code> <code>list of lists or np.ndarray</code> <p>Matrix of returns where each column represents an asset</p> required <p>Returns:</p> Type Description <code>np.ndarray or list of lists</code> <p>Correlation matrix</p> Notes <p>The correlation matrix measures the strength of the relationship between returns of different assets, normalized to be between -1 and 1.</p>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.covariance_matrix","title":"<code>covariance_matrix(returns_matrix)</code>","text":"<p>Calculate the covariance matrix of returns.</p> <p>Parameters:</p> Name Type Description Default <code>returns_matrix</code> <code>list of lists or np.ndarray</code> <p>Matrix of returns where each column represents an asset</p> required <p>Returns:</p> Type Description <code>np.ndarray or list of lists</code> <p>Covariance matrix</p> Notes <p>The covariance matrix measures how returns of different assets move together.</p>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.dollar_weighted_return","title":"<code>dollar_weighted_return(cash_flows, cash_flow_dates, end_value)</code>","text":"<p>Calculate the dollar-weighted return (internal rate of return) for a series of cash flows.</p> <p>Parameters:</p> Name Type Description Default <code>cash_flows</code> <code>array - like</code> <p>Array or list of cash flows (positive for inflows, negative for outflows)</p> required <code>cash_flow_dates</code> <code>array - like</code> <p>Array or list of dates (in days) when each cash flow occurs</p> required <code>end_value</code> <code>float</code> <p>The final value of the investment</p> required <p>Returns:</p> Type Description <code>float</code> <p>The dollar-weighted return as a decimal</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dollar_weighted_return([-1000, -500, 200], [0, 30, 60], 1400)\n0.36174448410245186\n</code></pre>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.drawdown","title":"<code>drawdown(returns, as_list=False)</code>","text":"<p>Calculate drawdown metrics.</p>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.geometric_return","title":"<code>geometric_return(prices)</code>","text":"<p>Calculate the geometric average return from a series of prices.</p> <p>Parameters:</p> Name Type Description Default <code>prices</code> <code>array - like</code> <p>Array or list of prices</p> required <p>Returns:</p> Type Description <code>float</code> <p>The geometric average return as a decimal</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; geometric_return([100, 105, 103, 108, 110])\n0.02411368908444511\n</code></pre>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.holding_period_return","title":"<code>holding_period_return(prices, dividends=None)</code>","text":"<p>Calculate the holding period return for a series of prices and optional dividends.</p> <p>Parameters:</p> Name Type Description Default <code>prices</code> <code>array - like</code> <p>Array or list of prices over the holding period</p> required <code>dividends</code> <code>array - like</code> <p>Array or list of dividends paid during the holding period</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>The holding period return as a decimal</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; holding_period_return([100, 102, 105, 103, 106])\n0.06\n&gt;&gt;&gt; holding_period_return([100, 102, 105, 103, 106], [0, 1, 0, 2, 0])\n0.09\n</code></pre>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.information_ratio","title":"<code>information_ratio(returns, benchmark_returns, annualization_factor=1.0)</code>","text":"<p>Calculate the Information ratio, which measures excess return per unit of tracking error.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>array - like</code> <p>Array of portfolio returns</p> required <code>benchmark_returns</code> <code>array - like</code> <p>Array of benchmark returns for the same periods</p> required <code>annualization_factor</code> <code>float</code> <p>Factor to annualize the Information ratio (e.g., 252 for daily returns to annual)</p> <code>1.0</code> <p>Returns:</p> Type Description <code>float</code> <p>The Information ratio</p>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.leveraged_return","title":"<code>leveraged_return(unleveraged_return, leverage_ratio, borrowing_rate)</code>","text":"<p>Calculate the return of a leveraged portfolio.</p> <p>Parameters:</p> Name Type Description Default <code>unleveraged_return</code> <code>float or array - like</code> <p>The return of the unleveraged portfolio as a decimal</p> required <code>leverage_ratio</code> <code>float or array - like</code> <p>The leverage ratio (e.g., 2.0 for 2:1 leverage)</p> required <code>borrowing_rate</code> <code>float or array - like</code> <p>The borrowing rate as a decimal</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>The leveraged return as a decimal If array inputs are provided, returns an array of leveraged returns</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; leveraged_return(0.10, 2.0, 0.05)\n0.15\n&gt;&gt;&gt; leveraged_return([0.10, 0.15], [2.0, 1.5], 0.05)\n[0.15, 0.2 ]\n&gt;&gt;&gt; leveraged_return(0.10, [2.0, 3.0], [0.05, 0.06])\n[0.15, 0.18]\n</code></pre>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.linked_modified_dietz_return","title":"<code>linked_modified_dietz_return(period_returns)</code>","text":"<p>Calculate the linked Modified Dietz return over multiple periods.</p> <p>Parameters:</p> Name Type Description Default <code>period_returns</code> <code>array - like</code> <p>Array or list of Modified Dietz returns for each period</p> required <p>Returns:</p> Type Description <code>float</code> <p>The linked Modified Dietz return as a decimal</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; linked_modified_dietz_return([0.05, -0.02, 0.03, 0.04])\n0.10226479999999993\n</code></pre>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.log_return","title":"<code>log_return(end_value, start_value)</code>","text":"<p>Calculate the logarithmic (continuously compounded) return between two values.</p> <p>Parameters:</p> Name Type Description Default <code>end_value</code> <code>float or array - like</code> <p>The ending value(s) of the investment</p> required <code>start_value</code> <code>float or array - like</code> <p>The starting value(s) of the investment</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>The logarithmic return If array inputs are provided, returns an array of logarithmic returns</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; log_return(105, 100)\n0.04879016416929972\n&gt;&gt;&gt; log_return([105, 110, 108], [100, 100, 100])\narray([0.04879016, 0.09531018, 0.07696104])\n&gt;&gt;&gt; log_return(np.array([105, 110]), np.array([100, 100]))\narray([0.04879016, 0.09531018])\n</code></pre>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.long_short_equity_return","title":"<code>long_short_equity_return(long_portfolio_return, short_portfolio_return, long_exposure, short_exposure, risk_free_rate=0.0, short_rebate=0.0)</code>","text":"<p>Calculate the return of a long-short equity portfolio.</p> <p>Parameters:</p> Name Type Description Default <code>long_portfolio_return</code> <code>float or array - like</code> <p>The return of the long portfolio as a decimal</p> required <code>short_portfolio_return</code> <code>float or array - like</code> <p>The return of the short portfolio as a decimal</p> required <code>long_exposure</code> <code>float or array - like</code> <p>The exposure of the long portfolio as a decimal of NAV</p> required <code>short_exposure</code> <code>float or array - like</code> <p>The exposure of the short portfolio as a decimal of NAV</p> required <code>risk_free_rate</code> <code>float or array - like</code> <p>The risk-free rate as a decimal</p> <code>0.0</code> <code>short_rebate</code> <code>float or array - like</code> <p>The rebate received on short proceeds as a decimal</p> <code>0.0</code> <p>Returns:</p> Type Description <code>float or ndarray</code> <p>The return of the long-short equity portfolio as a decimal If array inputs are provided, returns an array of long-short equity returns</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; long_short_equity_return(0.10, -0.05, 1.0, 0.5, 0.02, 0.01)\n0.14\n&gt;&gt;&gt; long_short_equity_return([0.10, 0.12], [-0.05, -0.03], 1.0, 0.5, 0.02, 0.01)\n[0.14, 0.15]\n&gt;&gt;&gt; long_short_equity_return(0.10, -0.05, [1.0, 0.8], [0.5, 0.4], [0.02, 0.03], 0.01)\n[0.14 , 0.122]\n</code></pre>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.market_neutral_return","title":"<code>market_neutral_return(long_return, short_return, long_weight=0.5, short_weight=0.5, short_borrowing_cost=0.0)</code>","text":"<p>Calculate the return of a market-neutral portfolio with long and short positions.</p> <p>Parameters:</p> Name Type Description Default <code>long_return</code> <code>float or array - like</code> <p>The return of the long portfolio as a decimal</p> required <code>short_return</code> <code>float or array - like</code> <p>The return of the short portfolio as a decimal</p> required <code>long_weight</code> <code>float or array - like</code> <p>The weight of the long portfolio</p> <code>0.5</code> <code>short_weight</code> <code>float or array - like</code> <p>The weight of the short portfolio</p> <code>0.5</code> <code>short_borrowing_cost</code> <code>float or array - like</code> <p>The cost of borrowing for the short position as a decimal</p> <code>0.0</code> <p>Returns:</p> Type Description <code>float or ndarray</code> <p>The market-neutral return as a decimal If array inputs are provided, returns an array of market-neutral returns</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; market_neutral_return(0.08, -0.05, 0.6, 0.4, 0.01)\n0.064\n&gt;&gt;&gt; market_neutral_return([0.08, 0.10], [-0.05, -0.03], 0.6, 0.4, 0.01)\n[0.064, 0.068]\n&gt;&gt;&gt; market_neutral_return(0.08, -0.05, [0.6, 0.7], [0.4, 0.3], [0.01, 0.02])\n[0.064, 0.065]\n</code></pre>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.modified_dietz_return","title":"<code>modified_dietz_return(start_value, end_value, cash_flows, cash_flow_days, total_days)</code>","text":"<p>Calculate the Modified Dietz return, which approximates the money-weighted return.</p> <p>Parameters:</p> Name Type Description Default <code>start_value</code> <code>float</code> <p>The starting value of the investment</p> required <code>end_value</code> <code>float</code> <p>The ending value of the investment</p> required <code>cash_flows</code> <code>array - like</code> <p>Array or list of cash flows (positive for inflows, negative for outflows)</p> required <code>cash_flow_days</code> <code>array - like</code> <p>Array or list of days when each cash flow occurs (day 0 is the start)</p> required <code>total_days</code> <code>int</code> <p>Total number of days in the period</p> required <p>Returns:</p> Type Description <code>float</code> <p>The Modified Dietz return as a decimal</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; modified_dietz_return(1000, 1200, [100, -50], [10, 20], 30)\n0.14285714285714285\n</code></pre>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.money_weighted_return","title":"<code>money_weighted_return(cash_flows, cash_flow_times, final_value, initial_value=0, max_iterations=100, tolerance=1e-06)</code>","text":"<p>Calculate the money-weighted return (internal rate of return) for a series of cash flows.</p> <p>Parameters:</p> Name Type Description Default <code>cash_flows</code> <code>array - like</code> <p>Array or list of cash flows (positive for inflows, negative for outflows)</p> required <code>cash_flow_times</code> <code>array - like</code> <p>Array or list of times (in years) when each cash flow occurs</p> required <code>final_value</code> <code>float</code> <p>The final value of the investment</p> required <code>initial_value</code> <code>float</code> <p>The initial value of the investment</p> <code>0</code> <code>max_iterations</code> <code>int</code> <p>Maximum number of iterations for the numerical solver</p> <code>100</code> <code>tolerance</code> <code>float</code> <p>Convergence tolerance for the numerical solver</p> <code>1e-6</code> <p>Returns:</p> Type Description <code>float</code> <p>The money-weighted return (IRR) as a decimal</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; money_weighted_return([-1000, -500, 1700], [0, 0.5, 1], 0)\n0.16120409753798307\n</code></pre>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.multifactor_alpha","title":"<code>multifactor_alpha(returns, factor_returns, risk_free_rate=0.0)</code>","text":"<p>Calculate the alpha from a multifactor model (e.g., Fama-French).</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>array - like</code> <p>Array of portfolio returns</p> required <code>factor_returns</code> <code>array - like</code> <p>2D array where each column represents returns for a factor</p> required <code>risk_free_rate</code> <code>float or array - like</code> <p>Risk-free rate for the same period as returns</p> <code>0.0</code> <p>Returns:</p> Type Description <code>tuple</code> <p>(alpha, betas, r_squared, p_value, std_err) - alpha: The multifactor alpha (intercept) - betas: Array of factor betas (coefficients) - r_squared: The R-squared of the regression - p_value: The p-value for alpha - std_err: The standard error of alpha</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Example with market, size, and value factors\n&gt;&gt;&gt; portfolio_returns = [0.01, 0.02, -0.01, 0.03, 0.01]\n&gt;&gt;&gt; factor_returns = [\n...     [0.005, 0.01, -0.005, 0.02, 0.005],  # Market\n...     [0.002, 0.003, -0.001, 0.004, 0.001],  # Size\n...     [0.001, 0.002, -0.002, 0.003, 0.002]   # Value\n... ]\n&gt;&gt;&gt; multifactor_alpha(portfolio_returns, factor_returns, 0.001)\n(0.0032, array([0.9, 0.5, 0.3]), 0.92, 0.04, 0.0015)  # Example values\n</code></pre>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.omega_ratio","title":"<code>omega_ratio(returns, threshold=0.0, annualization_factor=1.0)</code>","text":"<p>Calculate the Omega ratio, which measures the probability-weighted ratio of gains versus losses.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>array - like</code> <p>Array of portfolio returns</p> required <code>threshold</code> <code>float</code> <p>The threshold return</p> <code>0.0</code> <code>annualization_factor</code> <code>float</code> <p>Factor to annualize the threshold</p> <code>1.0</code> <p>Returns:</p> Type Description <code>float</code> <p>The Omega ratio</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; omega_ratio([0.01, 0.02, -0.01, 0.03, 0.01], 0.005)\n2.0\n</code></pre>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.semi_standard_deviation","title":"<code>semi_standard_deviation(returns, threshold=0.0, annualize=False, periods_per_year=252)</code>","text":"<p>Calculate the semi-standard deviation of returns below a threshold.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>list or ndarray</code> <p>Array or list of returns</p> required <code>threshold</code> <code>float</code> <p>Threshold below which to calculate semi-standard deviation</p> <code>0.0</code> <code>annualize</code> <code>bool</code> <p>Whether to annualize the semi-standard deviation</p> <code>False</code> <code>periods_per_year</code> <code>int</code> <p>Number of periods in a year (252 for daily returns, 12 for monthly, 4 for quarterly)</p> <code>252</code> <p>Returns:</p> Type Description <code>float</code> <p>Semi-standard deviation of returns</p> Notes <p>Semi-standard deviation only considers returns below the threshold (typically 0), making it a measure of downside risk.</p>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.sharpe_ratio","title":"<code>sharpe_ratio(returns, risk_free_rate=0.0, annualization_factor=1.0)</code>","text":"<p>Calculate the Sharpe ratio, which measures excess return per unit of risk.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>array - like</code> <p>Array of portfolio returns</p> required <code>risk_free_rate</code> <code>float or array - like</code> <p>Risk-free rate for the same period as returns</p> <code>0.0</code> <code>annualization_factor</code> <code>float</code> <p>Factor to annualize the Sharpe ratio (e.g., 252 for daily returns to annual)</p> <code>1.0</code> <p>Returns:</p> Type Description <code>float or ndarray</code> <p>The Sharpe ratio</p>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.simple_return","title":"<code>simple_return(end_value, start_value)</code>","text":"<p>Calculate the simple return (percentage change) between two values.</p> <p>Parameters:</p> Name Type Description Default <code>end_value</code> <code>float or array - like</code> <p>The ending value(s) of the investment</p> required <code>start_value</code> <code>float or array - like</code> <p>The starting value(s) of the investment</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>The simple return as a decimal (e.g., 0.05 for 5%) If array inputs are provided, returns an array of simple returns</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; simple_return(105, 100)\n0.05\n&gt;&gt;&gt; simple_return([105, 110, 108], [100, 100, 100])\narray([0.05, 0.1 , 0.08])\n&gt;&gt;&gt; simple_return(np.array([105, 110]), np.array([100, 100]))\narray([0.05, 0.1 ])\n</code></pre>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.sortino_ratio","title":"<code>sortino_ratio(returns, risk_free_rate=0.0, target_return=0.0, annualization_factor=1.0)</code>","text":"<p>Calculate the Sortino ratio, which measures excess return per unit of downside risk.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>array - like</code> <p>Array of portfolio returns</p> required <code>risk_free_rate</code> <code>float or array - like</code> <p>Risk-free rate for the same period as returns</p> <code>0.0</code> <code>target_return</code> <code>float</code> <p>Minimum acceptable return</p> <code>0.0</code> <code>annualization_factor</code> <code>float</code> <p>Factor to annualize the Sortino ratio</p> <code>1.0</code> <p>Returns:</p> Type Description <code>float</code> <p>The Sortino ratio</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sortino_ratio([0.01, 0.02, -0.01, 0.03, 0.01], 0.001, 0.0, 252)\n3.7947331922020545\n</code></pre>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.standard_deviation","title":"<code>standard_deviation(returns, annualize=False, periods_per_year=252)</code>","text":"<p>Calculate the standard deviation of returns.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>list or ndarray</code> <p>Array or list of returns</p> required <code>annualize</code> <code>bool</code> <p>Whether to annualize the standard deviation</p> <code>False</code> <code>periods_per_year</code> <code>int</code> <p>Number of periods in a year (252 for daily returns, 12 for monthly, 4 for quarterly)</p> <code>252</code> <p>Returns:</p> Type Description <code>float</code> <p>Standard deviation of returns</p> Notes <p>Standard deviation measures the dispersion of returns around the mean. It is the square root of the variance.</p>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.time_weighted_return","title":"<code>time_weighted_return(period_returns)</code>","text":"<p>Calculate the time-weighted return from a series of period returns.</p> <p>Parameters:</p> Name Type Description Default <code>period_returns</code> <code>array - like</code> <p>Array or list of returns for each period</p> required <p>Returns:</p> Type Description <code>float</code> <p>The time-weighted return as a decimal</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; time_weighted_return([0.05, -0.02, 0.03, 0.04])\n0.10226479999999993\n</code></pre>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.total_return_index","title":"<code>total_return_index(prices, dividends=None)</code>","text":"<p>Calculate the total return index from a series of prices and optional dividends.</p> <p>Parameters:</p> Name Type Description Default <code>prices</code> <code>array - like</code> <p>Array or list of prices</p> required <code>dividends</code> <code>array - like</code> <p>Array or list of dividends paid</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The total return index</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; total_return_index([100, 102, 105, 103, 106])\n[100., 102., 105., 103., 106.]\n&gt;&gt;&gt; total_return_index([100, 102, 105, 103, 106], [0, 1, 0, 2, 0])\n[100.        , 103.        , 106.02941176, 106.02941176,\n109.11764706]\n</code></pre>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.tracking_error","title":"<code>tracking_error(portfolio_returns, benchmark_returns, annualize=False, periods_per_year=252)</code>","text":"<p>Calculate the tracking error between portfolio returns and benchmark returns.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio_returns</code> <code>list or ndarray</code> <p>Array or list of portfolio returns</p> required <code>benchmark_returns</code> <code>list or ndarray</code> <p>Array or list of benchmark returns</p> required <code>annualize</code> <code>bool</code> <p>Whether to annualize the tracking error</p> <code>False</code> <code>periods_per_year</code> <code>int</code> <p>Number of periods in a year (252 for daily returns, 12 for monthly, 4 for quarterly)</p> <code>252</code> <p>Returns:</p> Type Description <code>float</code> <p>Tracking error</p> Notes <p>Tracking error measures how closely a portfolio follows its benchmark. It is the standard deviation of the difference between portfolio and benchmark returns.</p>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.treynor_ratio","title":"<code>treynor_ratio(returns, benchmark_returns, risk_free_rate=0.0, annualization_factor=1.0)</code>","text":"<p>Calculate the Treynor ratio, which measures excess return per unit of systematic risk.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>array - like</code> <p>Array of portfolio returns</p> required <code>benchmark_returns</code> <code>array - like</code> <p>Array of benchmark returns for the same periods</p> required <code>risk_free_rate</code> <code>float or array - like</code> <p>Risk-free rate for the same period as returns</p> <code>0.0</code> <code>annualization_factor</code> <code>float</code> <p>Factor to annualize the Treynor ratio</p> <code>1.0</code> <p>Returns:</p> Type Description <code>float</code> <p>The Treynor ratio</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; treynor_ratio([0.01, 0.02, -0.01, 0.03, 0.01], [0.005, 0.01, -0.005, 0.02, 0.005], 0.001, 252)\n0.0378\n</code></pre>"},{"location":"api/portfolio/#pypulate.dtypes.portfolio.Portfolio.value_at_risk","title":"<code>value_at_risk(returns, confidence_level=0.95, method='historical', parametric_mean=None, parametric_std=None, current_value=1.0)</code>","text":"<p>Calculate the Value-at-Risk (VaR) of a portfolio.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>list or ndarray</code> <p>Array or list of returns</p> required <code>confidence_level</code> <code>float</code> <p>Confidence level for VaR calculation (e.g., 0.95 for 95% confidence)</p> <code>0.95</code> <code>method</code> <code>str</code> <p>Method for calculating VaR ('historical', 'parametric', or 'monte_carlo')</p> <code>'historical'</code> <code>parametric_mean</code> <code>float</code> <p>Mean for parametric VaR calculation (if None, calculated from returns)</p> <code>None</code> <code>parametric_std</code> <code>float</code> <p>Standard deviation for parametric VaR calculation (if None, calculated from returns)</p> <code>None</code> <code>current_value</code> <code>float</code> <p>Current value of the portfolio</p> <code>1.0</code> <p>Returns:</p> Type Description <code>float</code> <p>Value-at-Risk (VaR) as a positive number representing the potential loss</p> Notes <p>VaR measures the potential loss in value of a portfolio over a defined period for a given confidence interval.</p>"},{"location":"api/transforms/","title":"sransforms API Reference","text":"<p>Wave and zigzag transforms for financial time series data.</p> <p>This module provides functions for extracting wave points and zigzag patterns from financial time series data, which are useful for technical analysis.</p>"},{"location":"api/transforms/#pypulate.transforms.wave.wave","title":"<code>wave(open, high, low, close)</code>","text":"<p>Extract wave points from OHLC financial data.</p> <p>This function processes OHLC data to extract price points based on candlestick patterns, and removes consecutive points that follow the same trend direction.</p> <p>Parameters:</p> Name Type Description Default <code>open</code> <code>ndarray</code> <p>Array of opening prices</p> required <code>high</code> <code>ndarray</code> <p>Array of high prices</p> required <code>low</code> <code>ndarray</code> <p>Array of low prices</p> required <code>close</code> <code>ndarray</code> <p>Array of closing prices</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>2D array of wave points with shape (n, 2), where each row contains [index, price]</p> Notes <p>The algorithm works as follows: 1. For each candle:    - If close &gt; open: adds low then high to the price list    - If close &lt; open: adds high then low to the price list 2. Removes intermediate points where three consecutive points form a consistent trend    (either all increasing or all decreasing)</p>"},{"location":"api/transforms/#pypulate.transforms.wave.zigzag","title":"<code>zigzag(prices, threshold=0.03)</code>","text":"<p>Extract zigzag pivot points from price data based on a percentage threshold.</p> <p>Parameters:</p> Name Type Description Default <code>prices</code> <code>ndarray or list</code> <p>1D array/list of price values or 2D array/list of [index, price] points</p> required <code>threshold</code> <code>float</code> <p>Minimum percentage change required to identify a new pivot point (0.03 = 3%)</p> <code>0.03</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>2D array of zigzag points with shape (n, 2), where each row contains [index, price]</p> Notes <p>The algorithm identifies significant price movements while filtering out minor fluctuations. It marks pivot points where the price changes direction by at least the specified threshold percentage.</p>"},{"location":"api/portfolio/return_measurement/","title":"Return Measurement API","text":"<p>Return measurement functions for portfolio analysis.</p> <p>This module provides functions for measuring returns in various portfolio scenarios, including portfolios with no cash flows, portfolios with inflows and outflows, and market-neutral and leveraged portfolios.</p> <p>All functions support both Python lists and NumPy arrays as inputs.</p>"},{"location":"api/portfolio/return_measurement/#pypulate.portfolio.return_measurement.annualized_return","title":"<code>annualized_return(total_return, years)</code>","text":"<p>Calculate the annualized return from a total return over a period of years.</p> <p>Parameters:</p> Name Type Description Default <code>total_return</code> <code>float or array - like</code> <p>The total return over the entire period as a decimal</p> required <code>years</code> <code>float or array - like</code> <p>The number of years in the period</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>The annualized return as a decimal If array inputs are provided, returns an array of annualized returns</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; annualized_return(0.2, 2)\n0.09544511501033215\n&gt;&gt;&gt; annualized_return([0.2, 0.3, 0.15], [2, 3, 1.5])\n[0.09544512, 0.09139288, 0.0976534 ]\n&gt;&gt;&gt; annualized_return(np.array([0.4, 0.5]), 2)\n[0.18321596, 0.22474487]\n</code></pre>"},{"location":"api/portfolio/return_measurement/#pypulate.portfolio.return_measurement.arithmetic_return","title":"<code>arithmetic_return(prices)</code>","text":"<p>Calculate the arithmetic average return from a series of prices.</p> <p>Parameters:</p> Name Type Description Default <code>prices</code> <code>array - like</code> <p>Array or list of prices</p> required <p>Returns:</p> Type Description <code>float</code> <p>The arithmetic average return as a decimal</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; arithmetic_return([100, 105, 103, 108, 110])\n0.024503647197821957\n</code></pre>"},{"location":"api/portfolio/return_measurement/#pypulate.portfolio.return_measurement.beta_adjusted_return","title":"<code>beta_adjusted_return(portfolio_return, benchmark_return, portfolio_beta)</code>","text":"<p>Calculate the beta-adjusted return (alpha) of a portfolio.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio_return</code> <code>float or array - like</code> <p>The return of the portfolio as a decimal</p> required <code>benchmark_return</code> <code>float or array - like</code> <p>The return of the benchmark as a decimal</p> required <code>portfolio_beta</code> <code>float or array - like</code> <p>The beta of the portfolio relative to the benchmark</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>The beta-adjusted return (alpha) as a decimal If array inputs are provided, returns an array of beta-adjusted returns</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; beta_adjusted_return(0.12, 0.10, 1.2)\n0.0\n&gt;&gt;&gt; beta_adjusted_return([0.12, 0.15], [0.10, 0.08], 1.2)\n[0.   , 0.054]\n&gt;&gt;&gt; beta_adjusted_return(0.12, 0.10, [1.2, 1.5])\n[ 0.  , -0.03]\n</code></pre>"},{"location":"api/portfolio/return_measurement/#pypulate.portfolio.return_measurement.dollar_weighted_return","title":"<code>dollar_weighted_return(cash_flows, cash_flow_dates, end_value)</code>","text":"<p>Calculate the dollar-weighted return (internal rate of return) for a series of cash flows.</p> <p>Parameters:</p> Name Type Description Default <code>cash_flows</code> <code>array - like</code> <p>Array or list of cash flows (positive for inflows, negative for outflows)</p> required <code>cash_flow_dates</code> <code>array - like</code> <p>Array or list of dates (in days) when each cash flow occurs</p> required <code>end_value</code> <code>float</code> <p>The final value of the investment</p> required <p>Returns:</p> Type Description <code>float</code> <p>The dollar-weighted return as a decimal</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dollar_weighted_return([-1000, -500, 200], [0, 30, 60], 1400)\n0.36174448410245186\n</code></pre>"},{"location":"api/portfolio/return_measurement/#pypulate.portfolio.return_measurement.geometric_return","title":"<code>geometric_return(prices)</code>","text":"<p>Calculate the geometric average return from a series of prices.</p> <p>Parameters:</p> Name Type Description Default <code>prices</code> <code>array - like</code> <p>Array or list of prices</p> required <p>Returns:</p> Type Description <code>float</code> <p>The geometric average return as a decimal</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; geometric_return([100, 105, 103, 108, 110])\n0.02411368908444511\n</code></pre>"},{"location":"api/portfolio/return_measurement/#pypulate.portfolio.return_measurement.holding_period_return","title":"<code>holding_period_return(prices, dividends=None)</code>","text":"<p>Calculate the holding period return for a series of prices and optional dividends.</p> <p>Parameters:</p> Name Type Description Default <code>prices</code> <code>array - like</code> <p>Array or list of prices over the holding period</p> required <code>dividends</code> <code>array - like</code> <p>Array or list of dividends paid during the holding period</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>The holding period return as a decimal</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; holding_period_return([100, 102, 105, 103, 106])\n0.06\n&gt;&gt;&gt; holding_period_return([100, 102, 105, 103, 106], [0, 1, 0, 2, 0])\n0.09\n</code></pre>"},{"location":"api/portfolio/return_measurement/#pypulate.portfolio.return_measurement.leveraged_return","title":"<code>leveraged_return(unleveraged_return, leverage_ratio, borrowing_rate)</code>","text":"<p>Calculate the return of a leveraged portfolio.</p> <p>Parameters:</p> Name Type Description Default <code>unleveraged_return</code> <code>float or array - like</code> <p>The return of the unleveraged portfolio as a decimal</p> required <code>leverage_ratio</code> <code>float or array - like</code> <p>The leverage ratio (e.g., 2.0 for 2:1 leverage)</p> required <code>borrowing_rate</code> <code>float or array - like</code> <p>The borrowing rate as a decimal</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>The leveraged return as a decimal If array inputs are provided, returns an array of leveraged returns</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; leveraged_return(0.10, 2.0, 0.05)\n0.15\n&gt;&gt;&gt; leveraged_return([0.10, 0.15], [2.0, 1.5], 0.05)\n[0.15, 0.2 ]\n&gt;&gt;&gt; leveraged_return(0.10, [2.0, 3.0], [0.05, 0.06])\n[0.15, 0.18]\n</code></pre>"},{"location":"api/portfolio/return_measurement/#pypulate.portfolio.return_measurement.linked_modified_dietz_return","title":"<code>linked_modified_dietz_return(period_returns)</code>","text":"<p>Calculate the linked Modified Dietz return over multiple periods.</p> <p>Parameters:</p> Name Type Description Default <code>period_returns</code> <code>array - like</code> <p>Array or list of Modified Dietz returns for each period</p> required <p>Returns:</p> Type Description <code>float</code> <p>The linked Modified Dietz return as a decimal</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; linked_modified_dietz_return([0.05, -0.02, 0.03, 0.04])\n0.10226479999999993\n</code></pre>"},{"location":"api/portfolio/return_measurement/#pypulate.portfolio.return_measurement.log_return","title":"<code>log_return(end_value, start_value)</code>","text":"<p>Calculate the logarithmic (continuously compounded) return between two values.</p> <p>Parameters:</p> Name Type Description Default <code>end_value</code> <code>float or array - like</code> <p>The ending value(s) of the investment</p> required <code>start_value</code> <code>float or array - like</code> <p>The starting value(s) of the investment</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>The logarithmic return If array inputs are provided, returns an array of logarithmic returns</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; log_return(105, 100)\n0.04879016416929972\n&gt;&gt;&gt; log_return([105, 110, 108], [100, 100, 100])\narray([0.04879016, 0.09531018, 0.07696104])\n&gt;&gt;&gt; log_return(np.array([105, 110]), np.array([100, 100]))\narray([0.04879016, 0.09531018])\n</code></pre>"},{"location":"api/portfolio/return_measurement/#pypulate.portfolio.return_measurement.long_short_equity_return","title":"<code>long_short_equity_return(long_portfolio_return, short_portfolio_return, long_exposure, short_exposure, risk_free_rate=0.0, short_rebate=0.0)</code>","text":"<p>Calculate the return of a long-short equity portfolio.</p> <p>Parameters:</p> Name Type Description Default <code>long_portfolio_return</code> <code>float or array - like</code> <p>The return of the long portfolio as a decimal</p> required <code>short_portfolio_return</code> <code>float or array - like</code> <p>The return of the short portfolio as a decimal</p> required <code>long_exposure</code> <code>float or array - like</code> <p>The exposure of the long portfolio as a decimal of NAV</p> required <code>short_exposure</code> <code>float or array - like</code> <p>The exposure of the short portfolio as a decimal of NAV</p> required <code>risk_free_rate</code> <code>float or array - like</code> <p>The risk-free rate as a decimal</p> <code>0.0</code> <code>short_rebate</code> <code>float or array - like</code> <p>The rebate received on short proceeds as a decimal</p> <code>0.0</code> <p>Returns:</p> Type Description <code>float or ndarray</code> <p>The return of the long-short equity portfolio as a decimal If array inputs are provided, returns an array of long-short equity returns</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; long_short_equity_return(0.10, -0.05, 1.0, 0.5, 0.02, 0.01)\n0.14\n&gt;&gt;&gt; long_short_equity_return([0.10, 0.12], [-0.05, -0.03], 1.0, 0.5, 0.02, 0.01)\n[0.14, 0.15]\n&gt;&gt;&gt; long_short_equity_return(0.10, -0.05, [1.0, 0.8], [0.5, 0.4], [0.02, 0.03], 0.01)\n[0.14 , 0.122]\n</code></pre>"},{"location":"api/portfolio/return_measurement/#pypulate.portfolio.return_measurement.market_neutral_return","title":"<code>market_neutral_return(long_return, short_return, long_weight=0.5, short_weight=0.5, short_borrowing_cost=0.0)</code>","text":"<p>Calculate the return of a market-neutral portfolio with long and short positions.</p> <p>Parameters:</p> Name Type Description Default <code>long_return</code> <code>float or array - like</code> <p>The return of the long portfolio as a decimal</p> required <code>short_return</code> <code>float or array - like</code> <p>The return of the short portfolio as a decimal</p> required <code>long_weight</code> <code>float or array - like</code> <p>The weight of the long portfolio</p> <code>0.5</code> <code>short_weight</code> <code>float or array - like</code> <p>The weight of the short portfolio</p> <code>0.5</code> <code>short_borrowing_cost</code> <code>float or array - like</code> <p>The cost of borrowing for the short position as a decimal</p> <code>0.0</code> <p>Returns:</p> Type Description <code>float or ndarray</code> <p>The market-neutral return as a decimal If array inputs are provided, returns an array of market-neutral returns</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; market_neutral_return(0.08, -0.05, 0.6, 0.4, 0.01)\n0.064\n&gt;&gt;&gt; market_neutral_return([0.08, 0.10], [-0.05, -0.03], 0.6, 0.4, 0.01)\n[0.064, 0.068]\n&gt;&gt;&gt; market_neutral_return(0.08, -0.05, [0.6, 0.7], [0.4, 0.3], [0.01, 0.02])\n[0.064, 0.065]\n</code></pre>"},{"location":"api/portfolio/return_measurement/#pypulate.portfolio.return_measurement.modified_dietz_return","title":"<code>modified_dietz_return(start_value, end_value, cash_flows, cash_flow_days, total_days)</code>","text":"<p>Calculate the Modified Dietz return, which approximates the money-weighted return.</p> <p>Parameters:</p> Name Type Description Default <code>start_value</code> <code>float</code> <p>The starting value of the investment</p> required <code>end_value</code> <code>float</code> <p>The ending value of the investment</p> required <code>cash_flows</code> <code>array - like</code> <p>Array or list of cash flows (positive for inflows, negative for outflows)</p> required <code>cash_flow_days</code> <code>array - like</code> <p>Array or list of days when each cash flow occurs (day 0 is the start)</p> required <code>total_days</code> <code>int</code> <p>Total number of days in the period</p> required <p>Returns:</p> Type Description <code>float</code> <p>The Modified Dietz return as a decimal</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; modified_dietz_return(1000, 1200, [100, -50], [10, 20], 30)\n0.14285714285714285\n</code></pre>"},{"location":"api/portfolio/return_measurement/#pypulate.portfolio.return_measurement.money_weighted_return","title":"<code>money_weighted_return(cash_flows, cash_flow_times, final_value, initial_value=0, max_iterations=100, tolerance=1e-06)</code>","text":"<p>Calculate the money-weighted return (internal rate of return) for a series of cash flows.</p> <p>Parameters:</p> Name Type Description Default <code>cash_flows</code> <code>array - like</code> <p>Array or list of cash flows (positive for inflows, negative for outflows)</p> required <code>cash_flow_times</code> <code>array - like</code> <p>Array or list of times (in years) when each cash flow occurs</p> required <code>final_value</code> <code>float</code> <p>The final value of the investment</p> required <code>initial_value</code> <code>float</code> <p>The initial value of the investment</p> <code>0</code> <code>max_iterations</code> <code>int</code> <p>Maximum number of iterations for the numerical solver</p> <code>100</code> <code>tolerance</code> <code>float</code> <p>Convergence tolerance for the numerical solver</p> <code>1e-6</code> <p>Returns:</p> Type Description <code>float</code> <p>The money-weighted return (IRR) as a decimal</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; money_weighted_return([-1000, -500, 1700], [0, 0.5, 1], 0)\n0.16120409753798307\n</code></pre>"},{"location":"api/portfolio/return_measurement/#pypulate.portfolio.return_measurement.simple_return","title":"<code>simple_return(end_value, start_value)</code>","text":"<p>Calculate the simple return (percentage change) between two values.</p> <p>Parameters:</p> Name Type Description Default <code>end_value</code> <code>float or array - like</code> <p>The ending value(s) of the investment</p> required <code>start_value</code> <code>float or array - like</code> <p>The starting value(s) of the investment</p> required <p>Returns:</p> Type Description <code>float or ndarray</code> <p>The simple return as a decimal (e.g., 0.05 for 5%) If array inputs are provided, returns an array of simple returns</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; simple_return(105, 100)\n0.05\n&gt;&gt;&gt; simple_return([105, 110, 108], [100, 100, 100])\narray([0.05, 0.1 , 0.08])\n&gt;&gt;&gt; simple_return(np.array([105, 110]), np.array([100, 100]))\narray([0.05, 0.1 ])\n</code></pre>"},{"location":"api/portfolio/return_measurement/#pypulate.portfolio.return_measurement.time_weighted_return","title":"<code>time_weighted_return(period_returns)</code>","text":"<p>Calculate the time-weighted return from a series of period returns.</p> <p>Parameters:</p> Name Type Description Default <code>period_returns</code> <code>array - like</code> <p>Array or list of returns for each period</p> required <p>Returns:</p> Type Description <code>float</code> <p>The time-weighted return as a decimal</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; time_weighted_return([0.05, -0.02, 0.03, 0.04])\n0.10226479999999993\n</code></pre>"},{"location":"api/portfolio/return_measurement/#pypulate.portfolio.return_measurement.total_return_index","title":"<code>total_return_index(prices, dividends=None)</code>","text":"<p>Calculate the total return index from a series of prices and optional dividends.</p> <p>Parameters:</p> Name Type Description Default <code>prices</code> <code>array - like</code> <p>Array or list of prices</p> required <code>dividends</code> <code>array - like</code> <p>Array or list of dividends paid</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The total return index</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; total_return_index([100, 102, 105, 103, 106])\n[100., 102., 105., 103., 106.]\n&gt;&gt;&gt; total_return_index([100, 102, 105, 103, 106], [0, 1, 0, 2, 0])\n[100.        , 103.        , 106.02941176, 106.02941176,\n   109.11764706]\n</code></pre>"},{"location":"api/portfolio/risk_adjusted/","title":"Risk-Adjusted Performance API","text":"<p>Risk-adjusted performance measurement functions for portfolio analysis.</p> <p>This module provides functions for measuring risk-adjusted performance metrics including Sharpe ratio, Information ratio, CAPM alpha, and multifactor models.</p> <p>All functions support both Python lists and NumPy arrays as inputs.</p>"},{"location":"api/portfolio/risk_adjusted/#pypulate.portfolio.risk_adjusted.benchmark_alpha","title":"<code>benchmark_alpha(returns, benchmark_returns)</code>","text":"<p>Calculate the benchmark alpha, which is the difference between portfolio return and benchmark return.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>array - like</code> <p>Array of portfolio returns</p> required <code>benchmark_returns</code> <code>array - like</code> <p>Array of benchmark returns for the same periods</p> required <p>Returns:</p> Type Description <code>float</code> <p>The benchmark alpha (difference in mean returns)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; benchmark_alpha([0.01, 0.02, -0.01, 0.03, 0.01], [0.005, 0.01, -0.005, 0.02, 0.005])\n0.005\n</code></pre>"},{"location":"api/portfolio/risk_adjusted/#pypulate.portfolio.risk_adjusted.calmar_ratio","title":"<code>calmar_ratio(returns, max_drawdown=None, annualization_factor=1.0)</code>","text":"<p>Calculate the Calmar ratio, which measures return relative to maximum drawdown.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>array - like</code> <p>Array of portfolio returns</p> required <code>max_drawdown</code> <code>float</code> <p>Maximum drawdown as a positive decimal. If None, it will be calculated from returns.</p> <code>None</code> <code>annualization_factor</code> <code>float</code> <p>Factor to annualize returns</p> <code>1.0</code> <p>Returns:</p> Type Description <code>float</code> <p>The Calmar ratio</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; calmar_ratio([0.01, 0.02, -0.01, 0.03, 0.01], 0.15, 252)\n0.8\n</code></pre>"},{"location":"api/portfolio/risk_adjusted/#pypulate.portfolio.risk_adjusted.capm_alpha","title":"<code>capm_alpha(returns, benchmark_returns, risk_free_rate=0.0)</code>","text":"<p>Calculate the CAPM alpha (Jensen's alpha) and related statistics.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>array - like</code> <p>Array of portfolio returns</p> required <code>benchmark_returns</code> <code>array - like</code> <p>Array of benchmark returns for the same periods</p> required <code>risk_free_rate</code> <code>float or array - like</code> <p>Risk-free rate for the same period as returns</p> <code>0.0</code> <p>Returns:</p> Type Description <code>tuple</code> <p>(alpha, beta, r_squared, p_value, std_err) - alpha: The CAPM alpha (intercept) - beta: The CAPM beta (slope) - r_squared: The R-squared of the regression - p_value: The p-value for alpha - std_err: The standard error of alpha</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; capm_alpha([0.01, 0.02, -0.01, 0.03, 0.01], [0.005, 0.01, -0.005, 0.02, 0.005], 0.001)\n(0.0046, 1.2, 0.9, 0.0023, 0.0012)\n</code></pre>"},{"location":"api/portfolio/risk_adjusted/#pypulate.portfolio.risk_adjusted.information_ratio","title":"<code>information_ratio(returns, benchmark_returns, annualization_factor=1.0)</code>","text":"<p>Calculate the Information ratio, which measures active return per unit of active risk.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>array - like</code> <p>Array of portfolio returns</p> required <code>benchmark_returns</code> <code>array - like</code> <p>Array of benchmark returns for the same periods</p> required <code>annualization_factor</code> <code>float</code> <p>Factor to annualize the Information ratio (e.g., 252 for daily returns to annual)</p> <code>1.0</code> <p>Returns:</p> Type Description <code>float</code> <p>The Information ratio</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; information_ratio([0.01, 0.02, -0.01, 0.03, 0.01], [0.005, 0.01, -0.005, 0.02, 0.005], 252)\n2.8284271247461903\n</code></pre>"},{"location":"api/portfolio/risk_adjusted/#pypulate.portfolio.risk_adjusted.multifactor_alpha","title":"<code>multifactor_alpha(returns, factor_returns, risk_free_rate=0.0)</code>","text":"<p>Calculate the alpha from a multifactor model (e.g., Fama-French).</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>array - like</code> <p>Array of portfolio returns</p> required <code>factor_returns</code> <code>array - like</code> <p>2D array where each column represents returns for a factor</p> required <code>risk_free_rate</code> <code>float or array - like</code> <p>Risk-free rate for the same period as returns</p> <code>0.0</code> <p>Returns:</p> Type Description <code>tuple</code> <p>(alpha, betas, r_squared, p_value, std_err) - alpha: The multifactor alpha (intercept) - betas: Array of factor betas (coefficients) - r_squared: The R-squared of the regression - p_value: The p-value for alpha - std_err: The standard error of alpha</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Example with market, size, and value factors\n&gt;&gt;&gt; portfolio_returns = [0.01, 0.02, -0.01, 0.03, 0.01]\n&gt;&gt;&gt; factor_returns = [\n...     [0.005, 0.01, -0.005, 0.02, 0.005],  # Market\n...     [0.002, 0.003, -0.001, 0.004, 0.001],  # Size\n...     [0.001, 0.002, -0.002, 0.003, 0.002]   # Value\n... ]\n&gt;&gt;&gt; multifactor_alpha(portfolio_returns, factor_returns, 0.001)\n(0.0032, array([0.9, 0.5, 0.3]), 0.92, 0.04, 0.0015)  # Example values\n</code></pre>"},{"location":"api/portfolio/risk_adjusted/#pypulate.portfolio.risk_adjusted.omega_ratio","title":"<code>omega_ratio(returns, threshold=0.0, annualization_factor=1.0)</code>","text":"<p>Calculate the Omega ratio, which measures the probability-weighted ratio of gains versus losses.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>array - like</code> <p>Array of portfolio returns</p> required <code>threshold</code> <code>float</code> <p>The threshold return</p> <code>0.0</code> <code>annualization_factor</code> <code>float</code> <p>Factor to annualize the threshold</p> <code>1.0</code> <p>Returns:</p> Type Description <code>float</code> <p>The Omega ratio</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; omega_ratio([0.01, 0.02, -0.01, 0.03, 0.01], 0.005)\n2.0\n</code></pre>"},{"location":"api/portfolio/risk_adjusted/#pypulate.portfolio.risk_adjusted.sharpe_ratio","title":"<code>sharpe_ratio(returns, risk_free_rate=0.0, annualization_factor=1.0)</code>","text":"<p>Calculate the Sharpe ratio, which measures excess return per unit of risk.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>array - like</code> <p>Array of periodic returns</p> required <code>risk_free_rate</code> <code>float or array - like</code> <p>Risk-free rate for the same period as returns</p> <code>0.0</code> <code>annualization_factor</code> <code>float</code> <p>Factor to annualize the Sharpe ratio (e.g., 252 for daily returns to annual)</p> <code>1.0</code> <p>Returns:</p> Type Description <code>float or ndarray</code> <p>The Sharpe ratio If array input is provided for risk_free_rate, returns an array of Sharpe ratios</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sharpe_ratio([0.01, 0.02, -0.01, 0.03, 0.01], 0.001, 252)\n2.5298221281347035\n&gt;&gt;&gt; sharpe_ratio([0.01, 0.02, -0.01, 0.03, 0.01], [0.001, 0.002], 252)\narray([2.52982213, 2.26684001])\n</code></pre>"},{"location":"api/portfolio/risk_adjusted/#pypulate.portfolio.risk_adjusted.sortino_ratio","title":"<code>sortino_ratio(returns, risk_free_rate=0.0, target_return=0.0, annualization_factor=1.0)</code>","text":"<p>Calculate the Sortino ratio, which measures excess return per unit of downside risk.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>array - like</code> <p>Array of portfolio returns</p> required <code>risk_free_rate</code> <code>float or array - like</code> <p>Risk-free rate for the same period as returns</p> <code>0.0</code> <code>target_return</code> <code>float</code> <p>Minimum acceptable return</p> <code>0.0</code> <code>annualization_factor</code> <code>float</code> <p>Factor to annualize the Sortino ratio</p> <code>1.0</code> <p>Returns:</p> Type Description <code>float</code> <p>The Sortino ratio</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sortino_ratio([0.01, 0.02, -0.01, 0.03, 0.01], 0.001, 0.0, 252)\n3.7947331922020545\n</code></pre>"},{"location":"api/portfolio/risk_adjusted/#pypulate.portfolio.risk_adjusted.treynor_ratio","title":"<code>treynor_ratio(returns, benchmark_returns, risk_free_rate=0.0, annualization_factor=1.0)</code>","text":"<p>Calculate the Treynor ratio, which measures excess return per unit of systematic risk.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>array - like</code> <p>Array of portfolio returns</p> required <code>benchmark_returns</code> <code>array - like</code> <p>Array of benchmark returns for the same periods</p> required <code>risk_free_rate</code> <code>float or array - like</code> <p>Risk-free rate for the same period as returns</p> <code>0.0</code> <code>annualization_factor</code> <code>float</code> <p>Factor to annualize the Treynor ratio</p> <code>1.0</code> <p>Returns:</p> Type Description <code>float</code> <p>The Treynor ratio</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; treynor_ratio([0.01, 0.02, -0.01, 0.03, 0.01], [0.005, 0.01, -0.005, 0.02, 0.005], 0.001, 252)\n0.0378\n</code></pre>"},{"location":"api/portfolio/risk_measurement/","title":"Risk Measurement API","text":"<p>Risk measurement functions for portfolio analysis.</p> <p>This module provides various risk metrics used in portfolio management and financial analysis.</p>"},{"location":"api/portfolio/risk_measurement/#pypulate.portfolio.risk_measurement.capm_beta","title":"<code>capm_beta(portfolio_returns, market_returns)</code>","text":"<p>Calculate the CAPM beta of a portfolio.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio_returns</code> <code>list or ndarray</code> <p>Array or list of portfolio returns</p> required <code>market_returns</code> <code>list or ndarray</code> <p>Array or list of market returns</p> required <p>Returns:</p> Type Description <code>float</code> <p>CAPM beta</p> Notes <p>Beta measures the sensitivity of portfolio returns to market returns. It is the covariance of portfolio returns and market returns divided by the variance of market returns.</p>"},{"location":"api/portfolio/risk_measurement/#pypulate.portfolio.risk_measurement.conditional_value_at_risk","title":"<code>conditional_value_at_risk(returns, confidence_level=0.95, method='historical', current_value=1.0)</code>","text":"<p>Calculate the Conditional Value-at-Risk (CVaR) of a portfolio.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>list or ndarray</code> <p>Array or list of returns</p> required <code>confidence_level</code> <code>float</code> <p>Confidence level for CVaR calculation (e.g., 0.95 for 95% confidence)</p> <code>0.95</code> <code>method</code> <code>str</code> <p>Method for calculating CVaR ('historical' or 'parametric')</p> <code>'historical'</code> <code>current_value</code> <code>float</code> <p>Current value of the portfolio</p> <code>1.0</code> <p>Returns:</p> Type Description <code>float</code> <p>Conditional Value-at-Risk (CVaR) as a positive number representing the potential loss</p> Notes <p>CVaR, also known as Expected Shortfall, measures the expected loss given that the loss exceeds the VaR threshold. It provides a more conservative risk measure than VaR.</p>"},{"location":"api/portfolio/risk_measurement/#pypulate.portfolio.risk_measurement.correlation_matrix","title":"<code>correlation_matrix(returns_matrix)</code>","text":"<p>Calculate the correlation matrix of returns.</p> <p>Parameters:</p> Name Type Description Default <code>returns_matrix</code> <code>list of lists or np.ndarray</code> <p>Matrix of returns where each column represents an asset</p> required <p>Returns:</p> Type Description <code>np.ndarray or list of lists</code> <p>Correlation matrix</p> Notes <p>The correlation matrix measures the strength of the relationship between returns of different assets, normalized to be between -1 and 1.</p>"},{"location":"api/portfolio/risk_measurement/#pypulate.portfolio.risk_measurement.covariance_matrix","title":"<code>covariance_matrix(returns_matrix)</code>","text":"<p>Calculate the covariance matrix of returns.</p> <p>Parameters:</p> Name Type Description Default <code>returns_matrix</code> <code>list of lists or np.ndarray</code> <p>Matrix of returns where each column represents an asset</p> required <p>Returns:</p> Type Description <code>np.ndarray or list of lists</code> <p>Covariance matrix</p> Notes <p>The covariance matrix measures how returns of different assets move together.</p>"},{"location":"api/portfolio/risk_measurement/#pypulate.portfolio.risk_measurement.drawdown","title":"<code>drawdown(returns, as_list=False)</code>","text":"<p>Calculate the drawdown, maximum drawdown, and drawdown duration of returns.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>list or ndarray</code> <p>Array or list of returns</p> required <code>as_list</code> <code>bool</code> <p>If True, returns the drawdowns as a list instead of numpy array</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple containing:</code> <ul> <li>Array or list of drawdowns</li> <li>Maximum drawdown (as a positive number)</li> <li>Start index of maximum drawdown</li> <li>End index of maximum drawdown</li> </ul> Notes <p>Drawdown measures the decline from a historical peak in cumulative returns.</p>"},{"location":"api/portfolio/risk_measurement/#pypulate.portfolio.risk_measurement.semi_standard_deviation","title":"<code>semi_standard_deviation(returns, threshold=0.0, annualize=False, periods_per_year=252)</code>","text":"<p>Calculate the semi-standard deviation of returns below a threshold.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>list or ndarray</code> <p>Array or list of returns</p> required <code>threshold</code> <code>float</code> <p>Threshold below which to calculate semi-standard deviation</p> <code>0.0</code> <code>annualize</code> <code>bool</code> <p>Whether to annualize the semi-standard deviation</p> <code>False</code> <code>periods_per_year</code> <code>int</code> <p>Number of periods in a year (252 for daily returns, 12 for monthly, 4 for quarterly)</p> <code>252</code> <p>Returns:</p> Type Description <code>float</code> <p>Semi-standard deviation of returns</p> Notes <p>Semi-standard deviation only considers returns below the threshold (typically 0), making it a measure of downside risk.</p>"},{"location":"api/portfolio/risk_measurement/#pypulate.portfolio.risk_measurement.standard_deviation","title":"<code>standard_deviation(returns, annualize=False, periods_per_year=252)</code>","text":"<p>Calculate the standard deviation of returns.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>list or ndarray</code> <p>Array or list of returns</p> required <code>annualize</code> <code>bool</code> <p>Whether to annualize the standard deviation</p> <code>False</code> <code>periods_per_year</code> <code>int</code> <p>Number of periods in a year (252 for daily returns, 12 for monthly, 4 for quarterly)</p> <code>252</code> <p>Returns:</p> Type Description <code>float</code> <p>Standard deviation of returns</p> Notes <p>Standard deviation measures the dispersion of returns around the mean. It is the square root of the variance.</p>"},{"location":"api/portfolio/risk_measurement/#pypulate.portfolio.risk_measurement.tracking_error","title":"<code>tracking_error(portfolio_returns, benchmark_returns, annualize=False, periods_per_year=252)</code>","text":"<p>Calculate the tracking error between portfolio returns and benchmark returns.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio_returns</code> <code>list or ndarray</code> <p>Array or list of portfolio returns</p> required <code>benchmark_returns</code> <code>list or ndarray</code> <p>Array or list of benchmark returns</p> required <code>annualize</code> <code>bool</code> <p>Whether to annualize the tracking error</p> <code>False</code> <code>periods_per_year</code> <code>int</code> <p>Number of periods in a year (252 for daily returns, 12 for monthly, 4 for quarterly)</p> <code>252</code> <p>Returns:</p> Type Description <code>float</code> <p>Tracking error</p> Notes <p>Tracking error measures how closely a portfolio follows its benchmark. It is the standard deviation of the difference between portfolio and benchmark returns.</p>"},{"location":"api/portfolio/risk_measurement/#pypulate.portfolio.risk_measurement.value_at_risk","title":"<code>value_at_risk(returns, confidence_level=0.95, method='historical', parametric_mean=None, parametric_std=None, current_value=1.0)</code>","text":"<p>Calculate the Value-at-Risk (VaR) of a portfolio.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>list or ndarray</code> <p>Array or list of returns</p> required <code>confidence_level</code> <code>float</code> <p>Confidence level for VaR calculation (e.g., 0.95 for 95% confidence)</p> <code>0.95</code> <code>method</code> <code>str</code> <p>Method for calculating VaR ('historical', 'parametric', or 'monte_carlo')</p> <code>'historical'</code> <code>parametric_mean</code> <code>float</code> <p>Mean for parametric VaR calculation (if None, calculated from returns)</p> <code>None</code> <code>parametric_std</code> <code>float</code> <p>Standard deviation for parametric VaR calculation (if None, calculated from returns)</p> <code>None</code> <code>current_value</code> <code>float</code> <p>Current value of the portfolio</p> <code>1.0</code> <p>Returns:</p> Type Description <code>float</code> <p>Value-at-Risk (VaR) as a positive number representing the potential loss</p> Notes <p>VaR measures the potential loss in value of a portfolio over a defined period for a given confidence interval.</p>"},{"location":"api/service-pricing/bundle-pricing/","title":"Bundle Pricing API Reference","text":"<p>This page documents the API for the bundle pricing module in Pypulate.</p>"},{"location":"api/service-pricing/bundle-pricing/#pypulate.pricing.bundle_pricing.calculate_bundle_price","title":"<code>calculate_bundle_price(items, item_prices, bundle_discounts, minimum_bundle_size=2)</code>","text":"<p>Calculate price for bundled items with discounts.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>list</code> <p>List of items in the bundle</p> required <code>item_prices</code> <code>dict</code> <p>Individual prices for each item</p> required <code>bundle_discounts</code> <code>dict</code> <p>Discount rates for different bundle combinations</p> required <code>minimum_bundle_size</code> <code>int</code> <p>Minimum items required for bundle pricing</p> <code>2</code>"},{"location":"api/service-pricing/dynamic-pricing/","title":"Dynamic Pricing API Reference","text":"<p>This page documents the API for the business KPIs module in Pypulate.</p> <p>Dynamic Pricing Module</p> <p>This module provides functions for calculating dynamic pricing adjustments.</p>"},{"location":"api/service-pricing/dynamic-pricing/#pypulate.pricing.dynamic_pricing.PricingRule","title":"<code>PricingRule</code>","text":"<p>A class for managing custom pricing rules.</p> <p>This class provides methods for: - Adding custom pricing rules - Applying custom pricing rules - Managing rule metadata</p>"},{"location":"api/service-pricing/dynamic-pricing/#pypulate.pricing.dynamic_pricing.PricingRule.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the PricingRule class.</p>"},{"location":"api/service-pricing/dynamic-pricing/#pypulate.pricing.dynamic_pricing.PricingRule.add_rule","title":"<code>add_rule(rule_name, calculation_function, description='')</code>","text":"<p>Add a custom pricing rule.</p> <p>Parameters:</p> Name Type Description Default <code>rule_name</code> <code>str</code> <p>Name of the custom pricing rule</p> required <code>calculation_function</code> <code>callable</code> <p>Function that implements the custom pricing logic</p> required <code>description</code> <code>str</code> <p>Description of the pricing rule</p> <code>''</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; def holiday_pricing(base_price, holiday_multiplier):\n...     return base_price * holiday_multiplier\n&gt;&gt;&gt; rules = PricingRule()\n&gt;&gt;&gt; rules.add_rule('holiday', holiday_pricing, 'Apply holiday pricing multiplier')\n</code></pre>"},{"location":"api/service-pricing/dynamic-pricing/#pypulate.pricing.dynamic_pricing.PricingRule.apply_rule","title":"<code>apply_rule(rule_name, *args, **kwargs)</code>","text":"<p>Apply a custom pricing rule.</p> <p>Parameters:</p> Name Type Description Default <code>rule_name</code> <code>str</code> <p>Name of the custom pricing rule</p> required <code>*args</code> <p>Arguments to pass to the custom pricing function</p> <code>()</code> <code>**kwargs</code> <p>Arguments to pass to the custom pricing function</p> <code>()</code> <p>Returns:</p> Type Description <code>float</code> <p>Price calculated using the custom rule</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the specified rule_name doesn't exist</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; rules = PricingRule()\n&gt;&gt;&gt; rules.add_rule('holiday', lambda price, mult: price * mult)\n&gt;&gt;&gt; rules.apply_rule('holiday', 100.0, 1.2)\n120.0\n</code></pre>"},{"location":"api/service-pricing/dynamic-pricing/#pypulate.pricing.dynamic_pricing.PricingRule.get_rule_description","title":"<code>get_rule_description(rule_name)</code>","text":"<p>Get the description of a pricing rule.</p> <p>Parameters:</p> Name Type Description Default <code>rule_name</code> <code>str</code> <p>Name of the pricing rule</p> required <p>Returns:</p> Type Description <code>str</code> <p>Description of the pricing rule</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the specified rule_name doesn't exist</p>"},{"location":"api/service-pricing/dynamic-pricing/#pypulate.pricing.dynamic_pricing.PricingRule.list_rules","title":"<code>list_rules()</code>","text":"<p>List all available pricing rules and their descriptions.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of rule names and their descriptions</p>"},{"location":"api/service-pricing/dynamic-pricing/#pypulate.pricing.dynamic_pricing.apply_dynamic_pricing","title":"<code>apply_dynamic_pricing(base_price, demand_factor, competition_factor, seasonality_factor=1.0, min_price=None, max_price=None)</code>","text":"<p>Calculate dynamically adjusted price based on market factors.</p> <p>Parameters:</p> Name Type Description Default <code>base_price</code> <code>float</code> <p>Base price before adjustments</p> required <code>demand_factor</code> <code>float</code> <p>Demand multiplier (1.0 is neutral)</p> required <code>competition_factor</code> <code>float</code> <p>Competition multiplier (1.0 is neutral)</p> required <code>seasonality_factor</code> <code>float</code> <p>Seasonal adjustment factor</p> <code>1.0</code> <code>min_price</code> <code>float</code> <p>Minimum price floor</p> <code>None</code> <code>max_price</code> <code>float</code> <p>Maximum price ceiling</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Dynamically adjusted price</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; apply_dynamic_pricing(100.0, 1.2, 0.9, 1.1)\n118.8  # 100.0 * 1.2 * 0.9 * 1.1\n&gt;&gt;&gt; apply_dynamic_pricing(100.0, 1.5, 0.8, min_price=90.0, max_price=150.0)\n120.0  # 100.0 * 1.5 * 0.8, bounded by min/max\n</code></pre>"},{"location":"api/service-pricing/freemium-pricing/","title":"Freemium Pricing API Reference","text":"<p>This page documents the API for the freemium pricing module in Pypulate.</p>"},{"location":"api/service-pricing/freemium-pricing/#pypulate.pricing.freemium_pricing.calculate_freemium_price","title":"<code>calculate_freemium_price(base_features, premium_features, feature_usage, free_limits, overage_rates)</code>","text":"<p>Calculate price for freemium model with usage limits.</p> <p>Parameters:</p> Name Type Description Default <code>base_features</code> <code>list</code> <p>List of free features</p> required <code>premium_features</code> <code>list</code> <p>List of premium features</p> required <code>feature_usage</code> <code>dict</code> <p>Usage metrics for each feature</p> required <code>free_limits</code> <code>dict</code> <p>Usage limits for free tier</p> required <code>overage_rates</code> <code>dict</code> <p>Rates for usage beyond free limits</p> required"},{"location":"api/service-pricing/loyalty-based-pricing/","title":"Loyalty-Based Pricing API Reference","text":"<p>This page documents the API for the loyalty-based pricing module in Pypulate.</p>"},{"location":"api/service-pricing/loyalty-based-pricing/#pypulate.pricing.loyalty_based_pricing.calculate_loyalty_price","title":"<code>calculate_loyalty_price(base_price, customer_tenure, loyalty_tiers, additional_benefits={})</code>","text":"<p>Calculate price with loyalty discounts and benefits.</p> <p>Parameters:</p> Name Type Description Default <code>base_price</code> <code>float</code> <p>Base price before loyalty benefits</p> required <code>customer_tenure</code> <code>int</code> <p>Customer's tenure in months</p> required <code>loyalty_tiers</code> <code>dict</code> <p>Discount rates for different tenure levels</p> required <code>additional_benefits</code> <code>dict</code> <p>Additional benefits for loyal customers</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing: - loyalty_price: final price after discount - loyalty_tier: the applicable tier - loyalty_discount: discount amount - additional_benefits: benefits dictionary</p>"},{"location":"api/service-pricing/peak-pricing/","title":"Peak Pricing API Reference","text":"<p>This page documents the API for the peak pricing module in Pypulate.</p>"},{"location":"api/service-pricing/peak-pricing/#pypulate.pricing.peak_pricing.calculate_peak_pricing","title":"<code>calculate_peak_pricing(base_price, usage_time, peak_hours, peak_multiplier=1.5, off_peak_multiplier=0.8)</code>","text":"<p>Calculate price based on peak/off-peak hours.</p> <p>Parameters:</p> Name Type Description Default <code>base_price</code> <code>float</code> <p>Base price per unit</p> required <code>usage_time</code> <code>str</code> <p>Time of usage (format: \"HH:MM\")</p> required <code>peak_hours</code> <code>dict</code> <p>Dictionary of weekdays and their peak hours Format: {\"monday\": (\"09:00\", \"17:00\")}</p> required <code>peak_multiplier</code> <code>float</code> <p>Price multiplier during peak hours</p> <code>1.5</code> <code>off_peak_multiplier</code> <code>float</code> <p>Price multiplier during off-peak hours</p> <code>0.8</code>"},{"location":"api/service-pricing/subscription-pricing/","title":"Subscription Based Pricing API Reference","text":"<p>This page documents the API for the business KPIs module in Pypulate.</p> <p>Subscription Pricing Module</p> <p>This module provides functions for calculating subscription-based pricing.</p>"},{"location":"api/service-pricing/subscription-pricing/#pypulate.pricing.subscription_pricing.calculate_subscription_price","title":"<code>calculate_subscription_price(base_price, features, feature_prices, duration_months=1, discount_rate=0.0)</code>","text":"<p>Calculate subscription price including selected features.</p> <p>Parameters:</p> Name Type Description Default <code>base_price</code> <code>float</code> <p>Base subscription price</p> required <code>features</code> <code>list</code> <p>List of selected feature names</p> required <code>feature_prices</code> <code>dict</code> <p>Dictionary of feature names and their prices</p> required <code>duration_months</code> <code>int</code> <p>Subscription duration in months</p> <code>1</code> <code>discount_rate</code> <code>float</code> <p>Annual discount rate for longer subscriptions</p> <code>0.0</code> <p>Returns:</p> Type Description <code>float</code> <p>Total subscription price</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; features = ['premium', 'api_access']\n&gt;&gt;&gt; feature_prices = {'premium': 49.99, 'api_access': 29.99}\n&gt;&gt;&gt; calculate_subscription_price(99.99, features, feature_prices)\n179.97  # 99.99 + 49.99 + 29.99\n&gt;&gt;&gt; calculate_subscription_price(99.99, features, feature_prices, \n...                            duration_months=12, discount_rate=0.10)\n1943.68  # (99.99 + 49.99 + 29.99) * 12 * (1 - 0.10)\n</code></pre>"},{"location":"api/service-pricing/tiered-pricing/","title":"Tiered Pricing API Reference","text":"<p>This page documents the API for the business KPIs module in Pypulate.</p> <p>Tiered Pricing Module</p> <p>This module provides functions for calculating tiered pricing structures.</p>"},{"location":"api/service-pricing/tiered-pricing/#pypulate.pricing.tiered_pricing.calculate_tiered_price","title":"<code>calculate_tiered_price(usage_units, tiers, cumulative=True)</code>","text":"<p>Calculate price based on tiered pricing structure.</p> <p>Parameters:</p> Name Type Description Default <code>usage_units</code> <code>float</code> <p>The number of units consumed</p> required <code>tiers</code> <code>dict</code> <p>Dictionary of tier ranges and their prices Format: {\"0-1000\": 0.10, \"1001-2000\": 0.08, \"2001+\": 0.05}</p> required <code>cumulative</code> <code>bool</code> <p>If True, price is calculated cumulatively across tiers If False, entire usage is priced at the tier it falls into</p> <code>True</code> <p>Returns:</p> Type Description <code>float</code> <p>Total price based on tiered pricing</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tiers = {\"0-1000\": 0.10, \"1001-2000\": 0.08, \"2001+\": 0.05}\n&gt;&gt;&gt; calculate_tiered_price(1500, tiers)\n130.0  # (1000 * 0.10) + (500 * 0.08)\n&gt;&gt;&gt; calculate_tiered_price(1500, tiers, cumulative=False)\n120.0  # 1500 * 0.08\n</code></pre>"},{"location":"api/service-pricing/time-based-pricing/","title":"Time-Based Pricing API Reference","text":"<p>This page documents the API for the time-based pricing module in Pypulate.</p>"},{"location":"api/service-pricing/time-based-pricing/#pypulate.pricing.time_based_pricing.calculate_time_based_price","title":"<code>calculate_time_based_price(base_price, duration, time_unit='hour', minimum_duration=1.0, rounding_method='up')</code>","text":"<p>Calculate price based on time duration.</p> <p>Parameters:</p> Name Type Description Default <code>base_price</code> <code>float</code> <p>Base price per time unit</p> required <code>duration</code> <code>float</code> <p>Duration of usage</p> required <code>time_unit</code> <code>str</code> <p>Unit of time ('minute', 'hour', 'day')</p> <code>'hour'</code> <code>minimum_duration</code> <code>float</code> <p>Minimum billable duration</p> <code>1.0</code> <code>rounding_method</code> <code>str</code> <p>How to round partial units ('up', 'down', 'nearest')</p> <code>'up'</code>"},{"location":"api/service-pricing/usage-based-pricing/","title":"Usage Based Pricing API Reference","text":"<p>This page documents the API for the business KPIs module in Pypulate.</p> <p>Usage Pricing Module</p> <p>This module provides functions for calculating usage-based pricing.</p>"},{"location":"api/service-pricing/usage-based-pricing/#pypulate.pricing.usage_pricing.calculate_usage_price","title":"<code>calculate_usage_price(usage_metrics, metric_rates, minimum_charge=0.0, maximum_charge=None)</code>","text":"<p>Calculate price based on usage metrics.</p> <p>Parameters:</p> Name Type Description Default <code>usage_metrics</code> <code>dict</code> <p>Dictionary of metric names and their usage values</p> required <code>metric_rates</code> <code>dict</code> <p>Dictionary of metric names and their per-unit rates</p> required <code>minimum_charge</code> <code>float</code> <p>Minimum charge to apply</p> <code>0.0</code> <code>maximum_charge</code> <code>float</code> <p>Maximum charge cap</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Total usage-based price</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; metrics = {'api_calls': 1000, 'storage_gb': 50}\n&gt;&gt;&gt; rates = {'api_calls': 0.001, 'storage_gb': 0.10}\n&gt;&gt;&gt; calculate_usage_price(metrics, rates)\n6.0  # (1000 * 0.001) + (50 * 0.10)\n&gt;&gt;&gt; calculate_usage_price(metrics, rates, minimum_charge=10.0)\n10.0  # Max of calculated price and minimum charge\n</code></pre>"},{"location":"api/service-pricing/usage-based-pricing/#pypulate.pricing.usage_pricing.calculate_volume_discount","title":"<code>calculate_volume_discount(base_price, volume, discount_tiers)</code>","text":"<p>Calculate price with volume-based discounts.</p> <p>Parameters:</p> Name Type Description Default <code>base_price</code> <code>float</code> <p>Base price per unit</p> required <code>volume</code> <code>int</code> <p>Number of units</p> required <code>discount_tiers</code> <code>dict</code> <p>Dictionary of volume thresholds and discount rates Format: {100: 0.05, 500: 0.10, 1000: 0.15}</p> required <p>Returns:</p> Type Description <code>float</code> <p>Total price after volume discount</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tiers = {100: 0.05, 500: 0.10, 1000: 0.15}\n&gt;&gt;&gt; calculate_volume_discount(10.0, 750, tiers)\n6750.0  # 750 * 10.0 * (1 - 0.10)\n</code></pre>"},{"location":"api/technical/momentum/","title":"Momentum API Reference","text":"<p>Momentum Indicators Module</p> <p>This module provides functions for calculating momentum-based indicators for financial time series analysis.</p>"},{"location":"api/technical/momentum/#pypulate.technical.momentum.adx","title":"<code>adx(data, period=14)</code>","text":"<p>Calculate Average Directional Index (ADX).</p> <p>ADX is a technical indicator used to determine the strength of a trend.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>period</code> <code>int</code> <p>Number of periods for calculation</p> <code>14</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>ADX values</p>"},{"location":"api/technical/momentum/#pypulate.technical.momentum.cci","title":"<code>cci(close, period=20, constant=0.015)</code>","text":"<p>Calculate Commodity Channel Index (CCI) using close prices.</p> <p>CCI measures the current price level relative to an average price level over a given period. This version uses only close prices instead of typical prices for simplified calculation.</p> <p>Parameters:</p> Name Type Description Default <code>close</code> <code>ndarray</code> <p>Close prices</p> required <code>period</code> <code>int</code> <p>Number of periods for calculation</p> <code>20</code> <code>constant</code> <code>float</code> <p>Scaling constant</p> <code>0.015</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>CCI values</p>"},{"location":"api/technical/momentum/#pypulate.technical.momentum.macd","title":"<code>macd(data, fast_period=12, slow_period=26, signal_period=9)</code>","text":"<p>Calculate Moving Average Convergence Divergence (MACD).</p> <p>MACD is a trend-following momentum indicator that shows the relationship between two moving averages of a security's price.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>fast_period</code> <code>int</code> <p>Period for the fast EMA</p> <code>12</code> <code>slow_period</code> <code>int</code> <p>Period for the slow EMA</p> <code>26</code> <code>signal_period</code> <code>int</code> <p>Period for the signal line (EMA of MACD line)</p> <code>9</code> <p>Returns:</p> Type Description <code>tuple of numpy.ndarray</code> <p>Tuple containing (macd_line, signal_line, histogram)</p>"},{"location":"api/technical/momentum/#pypulate.technical.momentum.momentum","title":"<code>momentum(data, period=14)</code>","text":"<p>Calculate momentum over a specified period.</p> <p>Momentum measures the amount that a price has changed over a given period.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>period</code> <code>int</code> <p>Number of periods to calculate momentum</p> <code>14</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Momentum values</p>"},{"location":"api/technical/momentum/#pypulate.technical.momentum.percent_change","title":"<code>percent_change(data, periods=1)</code>","text":"<p>Calculate percentage change between consecutive periods.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>periods</code> <code>int</code> <p>Number of periods to calculate change over</p> <code>1</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Percentage change values</p>"},{"location":"api/technical/momentum/#pypulate.technical.momentum.roc","title":"<code>roc(data, period=14)</code>","text":"<p>Calculate Rate of Change (ROC) over a specified period.</p> <p>ROC measures the percentage change in price over a given period.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>period</code> <code>int</code> <p>Number of periods to calculate ROC</p> <code>14</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>ROC values in percentage</p>"},{"location":"api/technical/momentum/#pypulate.technical.momentum.rsi","title":"<code>rsi(data, period=14, smoothing_type='sma')</code>","text":"<p>Calculate Relative Strength Index (RSI) over a specified period.</p> <p>RSI measures the speed and change of price movements, indicating overbought (&gt;70) or oversold (&lt;30) conditions.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>period</code> <code>int</code> <p>Number of periods to calculate RSI</p> <code>14</code> <code>smoothing_type</code> <code>str</code> <p>Type of smoothing to use: 'sma' (Simple Moving Average) or  'ema' (Exponential Moving Average)</p> <code>'sma'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>RSI values (0-100)</p>"},{"location":"api/technical/momentum/#pypulate.technical.momentum.stochastic_oscillator","title":"<code>stochastic_oscillator(close, high, low, k_period=14, d_period=3)</code>","text":"<p>Calculate Stochastic Oscillator.</p> <p>The Stochastic Oscillator is a momentum indicator that shows the location of the close relative to the high-low range over a set number of periods.</p> <p>Parameters:</p> Name Type Description Default <code>close</code> <code>ndarray</code> <p>Close prices</p> required <code>high</code> <code>ndarray</code> <p>High prices. If None, assumes close contains close prices and high=low=close</p> required <code>low</code> <code>ndarray</code> <p>Low prices. If None, assumes close contains close prices and high=low=close</p> required <code>k_period</code> <code>int</code> <p>Number of periods for %K</p> <code>14</code> <code>d_period</code> <code>int</code> <p>Number of periods for %D (moving average of %K)</p> <code>3</code> <p>Returns:</p> Type Description <code>tuple of numpy.ndarray</code> <p>Tuple containing (%K, %D)</p>"},{"location":"api/technical/momentum/#pypulate.technical.momentum.tsi","title":"<code>tsi(data, long_period=25, short_period=13, signal_period=7)</code>","text":"<p>Calculate True Strength Index (TSI).</p> <p>TSI is a momentum oscillator that helps identify trends and reversals.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>long_period</code> <code>int</code> <p>Long period for double smoothing</p> <code>25</code> <code>short_period</code> <code>int</code> <p>Short period for double smoothing</p> <code>13</code> <code>signal_period</code> <code>int</code> <p>Period for the signal line</p> <code>7</code> <p>Returns:</p> Type Description <code>tuple of numpy.ndarray</code> <p>Tuple containing (tsi_line, signal_line)</p>"},{"location":"api/technical/momentum/#pypulate.technical.momentum.williams_r","title":"<code>williams_r(close, high=None, low=None, period=14)</code>","text":"<p>Calculate Williams %R.</p> <p>Williams %R is a momentum indicator that measures overbought and oversold levels.</p> <p>Parameters:</p> Name Type Description Default <code>close</code> <code>ndarray</code> <p>Close prices</p> required <code>high</code> <code>ndarray</code> <p>High prices. If None, assumes close contains close prices and high=low=close</p> <code>None</code> <code>low</code> <code>ndarray</code> <p>Low prices. If None, assumes close contains close prices and high=low=close</p> <code>None</code> <code>period</code> <code>int</code> <p>Number of periods for calculation</p> <code>14</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Williams %R values (-100 to 0)</p>"},{"location":"api/technical/utils/","title":"Utils API Reference","text":"<p>KPI Utility Functions</p> <p>This module provides utility functions for calculating Key Performance Indicators (KPIs) for financial time series analysis.</p>"},{"location":"api/technical/utils/#pypulate.technical.utils.diff","title":"<code>diff(data, periods=1)</code>","text":"<p>Calculate difference between consecutive values.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>periods</code> <code>int</code> <p>Number of periods to calculate difference over</p> <code>1</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Difference values</p>"},{"location":"api/technical/utils/#pypulate.technical.utils.log","title":"<code>log(data)</code>","text":"<p>Calculate the natural logarithm of price data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>array - like</code> <p>Input price data as list or numpy array</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Natural logarithm of the input data. Returns NaN for any non-positive values.</p>"},{"location":"api/technical/utils/#pypulate.technical.utils.rolling_kurtosis","title":"<code>rolling_kurtosis(data, period=14)</code>","text":"<p>Calculate rolling kurtosis over a specified period.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>period</code> <code>int</code> <p>Window size for rolling kurtosis</p> <code>14</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Rolling kurtosis values</p>"},{"location":"api/technical/utils/#pypulate.technical.utils.rolling_max","title":"<code>rolling_max(data, period=14)</code>","text":"<p>Calculate rolling maximum over a specified period.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>period</code> <code>int</code> <p>Window size for rolling maximum</p> <code>14</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Rolling maximum values</p>"},{"location":"api/technical/utils/#pypulate.technical.utils.rolling_min","title":"<code>rolling_min(data, period=14)</code>","text":"<p>Calculate rolling minimum over a specified period.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>period</code> <code>int</code> <p>Window size for rolling minimum</p> <code>14</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Rolling minimum values</p>"},{"location":"api/technical/utils/#pypulate.technical.utils.rolling_skew","title":"<code>rolling_skew(data, period=14)</code>","text":"<p>Calculate rolling skewness over a specified period.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>period</code> <code>int</code> <p>Window size for rolling skewness</p> <code>14</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Rolling skewness values</p>"},{"location":"api/technical/utils/#pypulate.technical.utils.rolling_std","title":"<code>rolling_std(data, period=14)</code>","text":"<p>Calculate rolling standard deviation over a specified period.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>period</code> <code>int</code> <p>Window size for rolling standard deviation</p> <code>14</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Rolling standard deviation values</p>"},{"location":"api/technical/utils/#pypulate.technical.utils.rolling_var","title":"<code>rolling_var(data, period=14)</code>","text":"<p>Calculate rolling variance over a specified period.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>period</code> <code>int</code> <p>Window size for rolling variance</p> <code>14</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Rolling variance values</p>"},{"location":"api/technical/utils/#pypulate.technical.utils.slope","title":"<code>slope(data, period=5)</code>","text":"<p>Calculate the slope of the time series over a specified period.</p> <p>This function uses linear regression to calculate the slope of the line that best fits the data over the specified period.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>period</code> <code>int</code> <p>Number of points to use for slope calculation</p> <code>5</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Slope values for each point in the time series</p>"},{"location":"api/technical/utils/#pypulate.technical.utils.typical_price","title":"<code>typical_price(close, high, low)</code>","text":"<p>Calculate the typical price from close, high, and low prices.</p> <p>Parameters:</p> Name Type Description Default <code>close</code> <code>ndarray</code> <p>Close prices</p> required <code>high</code> <code>ndarray</code> <p>High prices</p> required <code>low</code> <code>ndarray</code> <p>Low prices</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Typical price values</p>"},{"location":"api/technical/utils/#pypulate.technical.utils.zscore","title":"<code>zscore(data, period=14)</code>","text":"<p>Calculate rolling Z-score over a specified period.</p> <p>Z-score measures how many standard deviations a data point is from the mean.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>period</code> <code>int</code> <p>Window size for Z-score calculation</p> <code>14</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Z-score values</p>"},{"location":"api/technical/volatility/","title":"Volatility API Reference","text":"<p>Volatility Measurement Functions</p> <p>This module provides functions for measuring volatility in financial time series data.</p>"},{"location":"api/technical/volatility/#pypulate.technical.volatility.atr","title":"<code>atr(close, high, low, period=14)</code>","text":"<p>Calculate Average True Range (ATR) over a specified period.</p> <p>ATR measures market volatility by decomposing the entire range of an asset price.</p> <p>Parameters:</p> Name Type Description Default <code>close</code> <code>ndarray</code> <p>Close prices</p> required <code>high</code> <code>ndarray</code> <p>High prices. If None, assumes close contains close prices and high=low=close</p> required <code>low</code> <code>ndarray</code> <p>Low prices. If None, assumes close contains close prices and high=low=close</p> required <code>period</code> <code>int</code> <p>Number of periods to calculate ATR</p> <code>14</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>ATR values</p>"},{"location":"api/technical/volatility/#pypulate.technical.volatility.bollinger_bands","title":"<code>bollinger_bands(data, period=20, std_dev=2.0)</code>","text":"<p>Calculate Bollinger Bands over a specified period.</p> <p>Bollinger Bands consist of a middle band (SMA), an upper band (SMA + kstd), and a lower band (SMA - kstd).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>period</code> <code>int</code> <p>Number of periods for the moving average</p> <code>20</code> <code>std_dev</code> <code>float</code> <p>Number of standard deviations for the upper and lower bands</p> <code>2.0</code> <p>Returns:</p> Type Description <code>tuple of numpy.ndarray</code> <p>Tuple containing (upper_band, middle_band, lower_band)</p>"},{"location":"api/technical/volatility/#pypulate.technical.volatility.donchian_channels","title":"<code>donchian_channels(data, high, low, period=20)</code>","text":"<p>Calculate Donchian Channels over a specified period.</p> <p>Donchian Channels consist of an upper band (highest high), a lower band (lowest low), and a middle band (average of upper and lower).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data (typically close prices)</p> required <code>high</code> <code>ndarray</code> <p>High prices. If None, uses data</p> required <code>low</code> <code>ndarray</code> <p>Low prices. If None, uses data</p> required <code>period</code> <code>int</code> <p>Number of periods for the channels</p> <code>20</code> <p>Returns:</p> Type Description <code>tuple of numpy.ndarray</code> <p>Tuple containing (upper_channel, middle_channel, lower_channel)</p>"},{"location":"api/technical/volatility/#pypulate.technical.volatility.historical_volatility","title":"<code>historical_volatility(data, period=21, annualization_factor=252)</code>","text":"<p>Calculate historical volatility over a specified period.</p> <p>Historical volatility is the standard deviation of log returns, typically annualized.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>period</code> <code>int</code> <p>Number of periods to calculate volatility</p> <code>21</code> <code>annualization_factor</code> <code>int</code> <p>Factor to annualize volatility (252 for daily data, 52 for weekly, 12 for monthly)</p> <code>252</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Historical volatility values as percentage</p>"},{"location":"api/technical/volatility/#pypulate.technical.volatility.keltner_channels","title":"<code>keltner_channels(close, high, low, period=20, atr_period=10, multiplier=2.0)</code>","text":"<p>Calculate Keltner Channels over a specified period.</p> <p>Keltner Channels consist of a middle band (EMA), an upper band (EMA + kATR), and a lower band (EMA - kATR).</p> <p>Parameters:</p> Name Type Description Default <code>close</code> <code>ndarray</code> <p>Close prices</p> required <code>high</code> <code>ndarray</code> <p>High prices. If None, assumes close contains close prices and high=low=close</p> required <code>low</code> <code>ndarray</code> <p>Low prices. If None, assumes close contains close prices and high=low=close</p> required <code>period</code> <code>int</code> <p>Number of periods for the EMA</p> <code>20</code> <code>atr_period</code> <code>int</code> <p>Number of periods for the ATR</p> <code>10</code> <code>multiplier</code> <code>float</code> <p>Multiplier for the ATR</p> <code>2.0</code> <p>Returns:</p> Type Description <code>tuple of numpy.ndarray</code> <p>Tuple containing (upper_channel, middle_channel, lower_channel)</p>"},{"location":"api/technical/volatility/#pypulate.technical.volatility.volatility_ratio","title":"<code>volatility_ratio(data, period=21, smooth_period=5)</code>","text":"<p>Calculate Volatility Ratio over a specified period.</p> <p>Volatility Ratio compares recent volatility to historical volatility. Values above 1 indicate increasing volatility, values below 1 indicate decreasing volatility.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Input time series data</p> required <code>period</code> <code>int</code> <p>Number of periods for historical volatility</p> <code>21</code> <code>smooth_period</code> <code>int</code> <p>Number of periods to smooth the ratio</p> <code>5</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Volatility Ratio values</p>"},{"location":"examples/advanced_techniques/","title":"Advanced Techniques","text":"<p>This guide demonstrates advanced techniques and methods using the <code>pypulate</code> package.</p>"},{"location":"examples/advanced_techniques/#advanced-method-chaining","title":"Advanced Method Chaining","text":""},{"location":"examples/advanced_techniques/#multi-indicator-strategy-with-method-chaining","title":"Multi-Indicator Strategy with Method Chaining","text":"<pre><code>import numpy as np\nfrom pypulate import as_parray\n\n# Create sample price data\nprices = np.array([100, 102, 104, 103, 105, 107, 108, 107, 105, 104, 103, 105, 107, 109, 108])\nhigh = prices + 2\nlow = prices - 2\nvolume = np.array([1000, 1200, 1500, 1300, 1400, 1600, 1700, 1500, 1300, 1200, 1100, 1300, 1500, 1700, 1600])\n\n# Convert to Parray\nts = as_parray(prices)\n\n# Create a complex strategy with method chaining\n# 1. Calculate price-based indicators\nema_short = ts.ema(5)\nema_long = ts.ema(10)\nupper_bb, middle_bb, lower_bb = ts.bollinger_bands(20, 2.0)\n\n# 2. Calculate momentum indicators\nrsi_values = ts.rsi(14)\nmacd_line, signal_line, histogram = ts.macd()\nk, d = ts.stochastic_oscillator(high, low)\n\n# 3. Calculate volatility indicators\natr_values = ts.atr(high, low, 14)\nvolatility = ts.historical_volatility(21)\n\n# 4. Generate complex signals\nbuy_signals = (\n    (ema_short.crossover(ema_long)) &amp;                # Price trend confirmation\n    (rsi_values &gt; 30) &amp; (rsi_values &lt; 70) &amp;          # RSI not extreme\n    (macd_line.crossover(signal_line)) &amp;             # MACD bullish crossover\n    (k.crossover(d)) &amp; (k &lt; 50) &amp;                    # Stochastic bullish crossover from low levels\n    (ts &gt; lower_bb) &amp; (ts &lt; middle_bb) &amp;             # Price between lower and middle BB\n    (volatility &lt; 30)                                # Low volatility environment\n)\n\nsell_signals = (\n    (ema_short.crossunder(ema_long)) &amp;               # Price trend confirmation\n    (rsi_values &gt; 70) &amp;                              # RSI overbought\n    (macd_line.crossunder(signal_line)) &amp;            # MACD bearish crossunder\n    (k.crossunder(d)) &amp; (k &gt; 50) &amp;                   # Stochastic bearish crossunder from high levels\n    (ts &gt; middle_bb) &amp; (ts &lt; upper_bb)               # Price between middle and upper BB\n)\n\nprint(\"Complex buy signals:\", buy_signals)\nprint(\"Complex sell signals:\", sell_signals)\n</code></pre>"},{"location":"examples/advanced_techniques/#custom-indicators","title":"Custom Indicators","text":""},{"location":"examples/advanced_techniques/#creating-a-custom-indicator","title":"Creating a Custom Indicator","text":"<pre><code>import numpy as np\nfrom pypulate import as_parray\n\n# Create a custom indicator function\ndef custom_momentum_oscillator(data, rsi_period=14, macd_fast=12, macd_slow=26, macd_signal=9, weight_rsi=0.5):\n    \"\"\"\n    Custom momentum oscillator combining RSI and MACD\n\n    Parameters\n    ----------\n    data : numpy.ndarray\n        Input price data\n    rsi_period : int\n        Period for RSI calculation\n    macd_fast : int\n        Fast period for MACD\n    macd_slow : int\n        Slow period for MACD\n    macd_signal : int\n        Signal period for MACD\n    weight_rsi : float\n        Weight for RSI component (0-1)\n\n    Returns\n    -------\n    numpy.ndarray\n        Custom momentum oscillator values\n    \"\"\"\n    # Convert to Parray\n    ts = as_parray(data)\n\n    # Calculate RSI (0-100)\n    rsi = ts.rsi(rsi_period)\n\n    # Calculate MACD\n    macd_line, signal_line, histogram = ts.macd(macd_fast, macd_slow, macd_signal)\n\n    # Normalize MACD histogram to 0-100 scale\n    # Find min and max values\n    hist_min = np.nanmin(histogram)\n    hist_max = np.nanmax(histogram)\n\n    # Normalize to 0-100\n    if hist_max - hist_min != 0:\n        normalized_hist = ((histogram - hist_min) / (hist_max - hist_min)) * 100\n    else:\n        normalized_hist = np.full_like(histogram, 50)\n\n    # Combine RSI and normalized MACD histogram\n    weight_macd = 1 - weight_rsi\n    custom_oscillator = (rsi * weight_rsi) + (normalized_hist * weight_macd)\n\n    return custom_oscillator\n\n# Apply the custom indicator\nprices = np.array([100, 102, 104, 103, 105, 107, 108, 107, 105, 104, 103, 105, 107, 109, 108])\ncustom_indicator = custom_momentum_oscillator(prices)\n\nprint(\"Custom Momentum Oscillator:\", custom_indicator)\n\n# Generate signals\noverbought = custom_indicator &gt; 70\noversold = custom_indicator &lt; 30\n\nprint(\"Overbought signals:\", overbought)\nprint(\"Oversold signals:\", oversold)\n</code></pre>"},{"location":"examples/advanced_techniques/#advanced-filtering-techniques","title":"Advanced Filtering Techniques","text":""},{"location":"examples/advanced_techniques/#combining-multiple-filters","title":"Combining Multiple Filters","text":"<pre><code>import numpy as np\nfrom pypulate import as_parray\n\n# Create noisy price data\nnp.random.seed(42)\nbase_prices = np.linspace(100, 150, 100)  # Upward trend\nnoise = np.random.normal(0, 5, 100)       # Random noise\nprices = base_prices + noise\n\n# Convert to Parray\nts = as_parray(prices)\n\n# Apply multiple filters in sequence\nfiltered_prices = (\n    ts\n    .kalman_filter(process_variance=1e-4, measurement_variance=1e-2)  # First pass with Kalman filter\n    .butterworth_filter(cutoff=0.1, order=3, filter_type='lowpass')   # Remove high-frequency noise\n    .savitzky_golay_filter(window_length=11, polyorder=3)             # Smooth the result\n)\n\n# Calculate the noise reduction\noriginal_variance = np.var(prices)\nfiltered_variance = np.var(filtered_prices)\nnoise_reduction_percent = (1 - (filtered_variance / original_variance)) * 100\n\nprint(f\"Original price variance: {original_variance:.2f}\")\nprint(f\"Filtered price variance: {filtered_variance:.2f}\")\nprint(f\"Noise reduction: {noise_reduction_percent:.2f}%\")\n</code></pre>"},{"location":"examples/advanced_techniques/#adaptive-filtering-based-on-volatility","title":"Adaptive Filtering Based on Volatility","text":"<pre><code>import numpy as np\nfrom pypulate import as_parray\n\n# Create price data with varying volatility\nnp.random.seed(42)\nn_points = 200\nbase_prices = np.linspace(100, 200, n_points)  # Upward trend\n\n# Create periods of different volatility\nvolatility = np.ones(n_points) * 2  # Base volatility\nvolatility[50:100] = 5              # Higher volatility in this region\nvolatility[150:] = 8                # Even higher volatility at the end\n\n# Generate prices with varying volatility\nnoise = np.random.normal(0, volatility)\nprices = base_prices + noise\n\n# Convert to Parray\nts = as_parray(prices)\n\n# Calculate historical volatility\nhist_vol = ts.historical_volatility(21)\n\n# Apply adaptive filtering based on volatility\nresult = np.full_like(prices, np.nan)\n\nfor i in range(len(prices)):\n    if i &lt; 21:  # Not enough data for volatility calculation\n        result[i] = prices[i]\n    else:\n        current_vol = hist_vol[i]\n\n        # Choose filter parameters based on volatility\n        if current_vol &lt; 10:  # Low volatility\n            # Light filtering\n            window_size = 3\n            n_sigmas = 2.0\n        elif current_vol &lt; 20:  # Medium volatility\n            # Medium filtering\n            window_size = 5\n            n_sigmas = 2.5\n        else:  # High volatility\n            # Strong filtering\n            window_size = 7\n            n_sigmas = 3.0\n\n        # Apply Hampel filter with adaptive parameters\n        if i &gt;= window_size:\n            window = prices[i-window_size:i+1]\n            median = np.median(window)\n            mad = np.median(np.abs(window - median))\n\n            if mad == 0:  # Avoid division by zero\n                result[i] = prices[i]\n            else:\n                # Scale MAD to estimate standard deviation\n                sigma = 1.4826 * mad\n\n                # Check if the point is an outlier\n                if abs(prices[i] - median) &gt; n_sigmas * sigma:\n                    result[i] = median  # Replace outlier with median\n                else:\n                    result[i] = prices[i]  # Keep original value\n        else:\n            result[i] = prices[i]\n\n# Convert result to Parray for further analysis\nfiltered_ts = as_parray(result)\n\nprint(\"Adaptive filtering complete\")\n</code></pre>"},{"location":"examples/advanced_techniques/#advanced-time-series-decomposition","title":"Advanced Time Series Decomposition","text":""},{"location":"examples/advanced_techniques/#trend-cycle-decomposition-with-hodrick-prescott-filter","title":"Trend-Cycle Decomposition with Hodrick-Prescott Filter","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom pypulate import as_parray\n\n# Create sample price data with trend, cycle, and noise\nnp.random.seed(42)\nn_points = 200\n\n# Create trend component\ntrend = np.linspace(100, 200, n_points)\n\n# Create cyclical component (sine wave)\ncycle_period = 40\ncycle = 15 * np.sin(2 * np.pi * np.arange(n_points) / cycle_period)\n\n# Create seasonal component (smaller sine wave)\nseasonal_period = 10\nseasonal = 5 * np.sin(2 * np.pi * np.arange(n_points) / seasonal_period)\n\n# Add random noise\nnoise = np.random.normal(0, 3, n_points)\n\n# Combine components\nprices = trend + cycle + seasonal + noise\n\n# Convert to Parray\nts = as_parray(prices)\n\n# Apply Hodrick-Prescott filter for trend-cycle decomposition\n# Lambda parameter controls smoothness of the trend component\ntrend_component, cycle_component = ts.hodrick_prescott_filter(lambda_param=1600)\n\n# Calculate seasonal and noise components\nseasonal_noise = prices - trend_component\n\nprint(\"Time series decomposition complete\")\n</code></pre>"},{"location":"examples/advanced_techniques/#combining-financial-and-business-metrics","title":"Combining Financial and Business Metrics","text":""},{"location":"examples/advanced_techniques/#integrated-dashboard-for-saas-business","title":"Integrated Dashboard for SaaS Business","text":"<pre><code>import numpy as np\nfrom pypulate import as_parray\nfrom pypulate.kpi import (\n    churn_rate, retention_rate, customer_lifetime_value,\n    customer_acquisition_cost, monthly_recurring_revenue,\n    annual_recurring_revenue, ltv_cac_ratio, payback_period\n)\n\n# Sample data for a SaaS business\nmonths = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\"]\n\n# Customer metrics\ncustomers_start = [100, 110, 125, 135, 150, 160]\ncustomers_end = [110, 125, 135, 150, 160, 175]\nnew_customers = [20, 25, 20, 30, 25, 30]\navg_revenue_per_customer = [50, 52, 53, 55, 56, 58]\n\n# Financial metrics\nmarketing_costs = [10000, 12000, 11000, 15000, 14000, 16000]\nsales_costs = [8000, 9000, 8500, 10000, 9500, 11000]\ngross_margin = 70  # 70% gross margin\n\n# Stock price (if public company)\nstock_prices = np.array([25, 26, 28, 27, 30, 32])\n\n# Calculate business KPIs\nbusiness_metrics = {\n    \"Month\": months,\n    \"Churn Rate (%)\": [],\n    \"Retention Rate (%)\": [],\n    \"MRR ($)\": [],\n    \"ARR ($)\": [],\n    \"CAC ($)\": [],\n    \"LTV ($)\": [],\n    \"LTV:CAC Ratio\": [],\n    \"Payback Period (months)\": []\n}\n\nfor i in range(len(months)):\n    # Calculate metrics\n    churn = churn_rate(customers_start[i], customers_end[i], new_customers[i])\n    retention = retention_rate(customers_start[i], customers_end[i], new_customers[i])\n    mrr = monthly_recurring_revenue(customers_end[i], avg_revenue_per_customer[i])\n    arr = annual_recurring_revenue(customers_end[i], avg_revenue_per_customer[i])\n    cac = customer_acquisition_cost(marketing_costs[i], sales_costs[i], new_customers[i])\n    ltv = customer_lifetime_value(avg_revenue_per_customer[i], gross_margin, churn)\n    ratio = ltv_cac_ratio(ltv, cac)\n    payback = payback_period(cac, avg_revenue_per_customer[i], gross_margin)\n\n    # Store metrics\n    business_metrics[\"Churn Rate (%)\"].append(churn)\n    business_metrics[\"Retention Rate (%)\"].append(retention)\n    business_metrics[\"MRR ($)\"].append(mrr)\n    business_metrics[\"ARR ($)\"].append(arr)\n    business_metrics[\"CAC ($)\"].append(cac)\n    business_metrics[\"LTV ($)\"].append(ltv)\n    business_metrics[\"LTV:CAC Ratio\"].append(ratio)\n    business_metrics[\"Payback Period (months)\"].append(payback)\n\n# Convert stock prices to Parray for technical analysis\nstock_ts = as_parray(stock_prices)\n\n# Calculate technical indicators\nstock_sma = stock_ts.sma(3)\nstock_ema = stock_ts.ema(3)\nstock_rsi = stock_ts.rsi(14)\n\n# Print integrated dashboard\nprint(\"=== SaaS Business Dashboard ===\")\nprint(\"\\nBusiness Metrics:\")\nfor i in range(len(months)):\n    print(f\"\\n{months[i]}:\")\n    print(f\"  Churn Rate: {business_metrics['Churn Rate (%)'][i]:.2f}%\")\n    print(f\"  Retention Rate: {business_metrics['Retention Rate (%)'][i]:.2f}%\")\n    print(f\"  MRR: ${business_metrics['MRR ($)'][i]:.2f}\")\n    print(f\"  ARR: ${business_metrics['ARR ($)'][i]:.2f}\")\n    print(f\"  CAC: ${business_metrics['CAC ($)'][i]:.2f}\")\n    print(f\"  LTV: ${business_metrics['LTV ($)'][i]:.2f}\")\n    print(f\"  LTV:CAC Ratio: {business_metrics['LTV:CAC Ratio'][i]:.2f}\")\n    print(f\"  Payback Period: {business_metrics['Payback Period (months)'][i]:.2f} months\")\n\nprint(\"\\nStock Technical Analysis:\")\nfor i in range(len(months)):\n    print(f\"\\n{months[i]}:\")\n    print(f\"  Stock Price: ${stock_prices[i]:.2f}\")\n    if i &gt;= 2:  # Need at least 3 points for SMA\n        print(f\"  SMA(3): ${stock_sma[i]:.2f}\")\n        print(f\"  EMA(3): ${stock_ema[i]:.2f}\")\n    if i &gt;= 13:  # Need at least 14 points for RSI\n        print(f\"  RSI(14): {stock_rsi[i]:.2f}\")\n</code></pre>"},{"location":"examples/basic_usage/","title":"Basic Usage","text":"<p>This guide demonstrates the basic usage of the <code>pypulate</code> package, focusing on the <code>Parray</code> class and various financial analysis methods.</p>"},{"location":"examples/basic_usage/#creating-a-parray","title":"Creating a Parray","text":"<p>The <code>Parray</code> class is a wrapper around NumPy arrays that provides method chaining for financial analysis.</p> <pre><code>import numpy as np\nfrom pypulate import as_parray\n\n# Create sample data\ndata = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n# Convert to Parray\nts = as_parray(data)\n</code></pre>"},{"location":"examples/basic_usage/#moving-averages","title":"Moving Averages","text":"<pre><code># Calculate Simple Moving Average\nsma_values = ts.sma(period=3)\n\n# Calculate Exponential Moving Average\nema_values = ts.ema(period=3)\n\n# Chain multiple moving averages\nresult = ts.ema(3).sma(2)\n</code></pre>"},{"location":"examples/basic_usage/#momentum-indicators","title":"Momentum Indicators","text":"<pre><code># Calculate RSI\nrsi_values = ts.rsi(period=14)\n\n# Calculate MACD\nmacd_line, signal_line, histogram = ts.macd()\n\n# Calculate Stochastic Oscillator\nk, d = ts.stochastic_oscillator()\n</code></pre>"},{"location":"examples/basic_usage/#volatility-measurements","title":"Volatility Measurements","text":"<pre><code># Calculate Bollinger Bands\nupper, middle, lower = ts.bollinger_bands(period=20, std_dev=2.0)\n\n# Calculate ATR\natr_values = ts.atr(period=14)\n</code></pre>"},{"location":"examples/basic_usage/#transforms","title":"Transforms","text":"<pre><code># Detect waves\nwaves = ts.wave(min_size=3)\n\n# Apply ZigZag transform\nzigzag_values = ts.zigzag(deviation=5.0, backstep=3)\n</code></pre>"},{"location":"examples/basic_usage/#filters","title":"Filters","text":"<pre><code># Apply Kalman filter\nfiltered_values = ts.kalman_filter()\n\n# Apply Butterworth filter\nfiltered_values = ts.butterworth_filter(cutoff=0.1, order=4, filter_type='lowpass')\n</code></pre>"},{"location":"examples/basic_usage/#utility-functions","title":"Utility Functions","text":"<pre><code># Calculate slope\nslope_values = ts.slope(period=5)\n\n# Calculate rolling statistics\nmax_values = ts.rolling_max(period=14)\nmin_values = ts.rolling_min(period=14)\nstd_values = ts.rolling_std(period=14)\n</code></pre>"},{"location":"examples/basic_usage/#method-chaining","title":"Method Chaining","text":"<p>One of the key features of <code>pypulate</code> is the ability to chain methods together for complex analysis:</p> <pre><code># Chain multiple operations\nresult = (\n    ts\n    .ema(5)                          # Apply 5-period EMA first\n    .rsi(14)                         # Calculate RSI on the EMA\n    .bollinger_bands(20, 2.0)        # Calculate Bollinger Bands on the RSI\n)\n\n# More complex example\nmacd_line, signal, hist = ts.macd()\nstoch_k, stoch_d = ts.stochastic_oscillator()\n\n# Generate signals\nbuy_signals = (\n    (ts.rsi(14) &lt; 30) &amp;                  # RSI oversold\n    (macd_line.crossover(signal)) &amp;      # MACD bullish crossover\n    (stoch_k.crossover(stoch_d))         # Stochastic bullish crossover\n)\n</code></pre>"},{"location":"examples/business_metrics/","title":"Business Metrics Examples","text":"<p>This guide demonstrates various business metrics analysis using the <code>pypulate</code> package.</p>"},{"location":"examples/business_metrics/#customer-metrics","title":"Customer Metrics","text":""},{"location":"examples/business_metrics/#churn-and-retention-analysis","title":"Churn and Retention Analysis","text":"<pre><code>from pypulate.kpi import churn_rate, retention_rate\n\n# Monthly customer data\nmonths = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\"]\ncustomers_start = [100, 110, 125, 135, 150, 160]\ncustomers_end = [110, 125, 135, 150, 160, 175]\nnew_customers = [20, 25, 20, 30, 25, 30]\n\n# Calculate churn and retention rates\nchurn_rates = []\nretention_rates = []\n\nfor i in range(len(months)):\n    churn = churn_rate(customers_start[i], customers_end[i], new_customers[i])\n    retention = retention_rate(customers_start[i], customers_end[i], new_customers[i])\n\n    churn_rates.append(churn)\n    retention_rates.append(retention)\n\n    print(f\"{months[i]}: Churn Rate = {churn:.2f}%, Retention Rate = {retention:.2f}%\")\n\n# Average churn and retention\navg_churn = sum(churn_rates) / len(churn_rates)\navg_retention = sum(retention_rates) / len(retention_rates)\n\nprint(f\"Average Churn Rate: {avg_churn:.2f}%\")\nprint(f\"Average Retention Rate: {avg_retention:.2f}%\")\n</code></pre>"},{"location":"examples/business_metrics/#customer-lifetime-value-analysis","title":"Customer Lifetime Value Analysis","text":"<pre><code>from pypulate.kpi import customer_lifetime_value, customer_acquisition_cost, ltv_cac_ratio\n\n# Customer metrics\navg_revenue_per_customer = 100  # $100 per month\ngross_margin = 70               # 70% gross margin\nchurn_rate_value = 5            # 5% monthly churn rate\ndiscount_rate = 10              # 10% annual discount rate\n\n# Marketing and sales costs\nmarketing_costs = 50000         # $50,000 marketing costs\nsales_costs = 30000             # $30,000 sales costs\nnew_customers = 200             # 200 new customers\n\n# Calculate CLV and CAC\nltv = customer_lifetime_value(avg_revenue_per_customer, gross_margin, churn_rate_value, discount_rate)\ncac = customer_acquisition_cost(marketing_costs, sales_costs, new_customers)\nratio = ltv_cac_ratio(ltv, cac)\n\nprint(f\"Customer Lifetime Value (CLV): ${ltv:.2f}\")\nprint(f\"Customer Acquisition Cost (CAC): ${cac:.2f}\")\nprint(f\"LTV:CAC Ratio: {ratio:.2f}\")\n\n# Evaluate business health\nif ratio &gt; 3:\n    print(\"Excellent LTV:CAC ratio (&gt;3)\")\nelif ratio &gt; 1:\n    print(\"Good LTV:CAC ratio (&gt;1)\")\nelse:\n    print(\"Poor LTV:CAC ratio (&lt;1)\")\n</code></pre>"},{"location":"examples/business_metrics/#revenue-metrics","title":"Revenue Metrics","text":""},{"location":"examples/business_metrics/#mrr-and-arr-analysis","title":"MRR and ARR Analysis","text":"<pre><code>from pypulate.kpi import monthly_recurring_revenue, annual_recurring_revenue\n\n# Monthly customer and revenue data\nmonths = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\"]\npaying_customers = [100, 110, 125, 135, 150, 160]\navg_revenue = [50, 52, 53, 55, 56, 58]  # Average revenue per customer\n\n# Calculate MRR and ARR\nmrr_values = []\narr_values = []\n\nfor i in range(len(months)):\n    mrr = monthly_recurring_revenue(paying_customers[i], avg_revenue[i])\n    arr = annual_recurring_revenue(paying_customers[i], avg_revenue[i])\n\n    mrr_values.append(mrr)\n    arr_values.append(arr)\n\n    print(f\"{months[i]}: MRR = ${mrr:.2f}, ARR = ${arr:.2f}\")\n\n# MRR growth\nmrr_growth = [(mrr_values[i] - mrr_values[i-1]) / mrr_values[i-1] * 100 for i in range(1, len(mrr_values))]\navg_mrr_growth = sum(mrr_growth) / len(mrr_growth)\n\nprint(f\"Average Monthly MRR Growth: {avg_mrr_growth:.2f}%\")\n</code></pre>"},{"location":"examples/business_metrics/#revenue-churn-and-expansion-analysis","title":"Revenue Churn and Expansion Analysis","text":"<pre><code>from pypulate.kpi import revenue_churn_rate, expansion_revenue_rate\n\n# Monthly revenue data\nmonths = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\"]\nrevenue_start = [5000, 5500, 6000, 6600, 7200, 7800]\nrevenue_end = [5500, 6000, 6600, 7200, 7800, 8500]\nnew_revenue = [800, 900, 1000, 1100, 1200, 1300]\nupsell_revenue = [200, 250, 300, 350, 400, 450]\ncross_sell_revenue = [100, 120, 150, 180, 200, 250]\n\n# Calculate revenue churn and expansion rates\nrevenue_churn_rates = []\nexpansion_rates = []\n\nfor i in range(len(months)):\n    rev_churn = revenue_churn_rate(revenue_start[i], revenue_end[i], new_revenue[i])\n    expansion = expansion_revenue_rate(upsell_revenue[i], cross_sell_revenue[i], revenue_start[i])\n\n    revenue_churn_rates.append(rev_churn)\n    expansion_rates.append(expansion)\n\n    print(f\"{months[i]}: Revenue Churn = {rev_churn:.2f}%, Expansion = {expansion:.2f}%\")\n\n# Net revenue retention\nnet_retention = [(revenue_end[i] - new_revenue[i]) / revenue_start[i] * 100 for i in range(len(months))]\navg_net_retention = sum(net_retention) / len(net_retention)\n\nprint(f\"Average Net Revenue Retention: {avg_net_retention:.2f}%\")\n</code></pre>"},{"location":"examples/business_metrics/#user-engagement-metrics","title":"User Engagement Metrics","text":""},{"location":"examples/business_metrics/#customer-satisfaction-and-effort-analysis","title":"Customer Satisfaction and Effort Analysis","text":"<pre><code>from pypulate.kpi import customer_satisfaction_score, customer_effort_score, net_promoter_score\nimport numpy as np\n\n# Sample survey data\ncsat_ratings = np.array([4, 5, 3, 5, 4, 5, 4, 3, 5, 4])  # 1-5 scale\nces_ratings = np.array([2, 3, 1, 2, 4, 2, 3, 2, 1, 2])   # 1-7 scale (lower is better)\n\n# NPS data\npromoters = 70      # Customers who rated 9-10\ndetractors = 10     # Customers who rated 0-6\npassives = 20       # Customers who rated 7-8\ntotal_respondents = promoters + passives + detractors\n\n# Calculate satisfaction metrics\ncsat = customer_satisfaction_score(csat_ratings, max_rating=5)\nces = customer_effort_score(ces_ratings, max_rating=7)\nnps = net_promoter_score(promoters, detractors, total_respondents)\n\nprint(f\"Customer Satisfaction Score (CSAT): {csat:.2f}%\")\nprint(f\"Customer Effort Score (CES): {ces:.2f}\")\nprint(f\"Net Promoter Score (NPS): {nps:.2f}\")\n\n# Evaluate customer satisfaction\nif csat &gt; 80:\n    print(\"Excellent CSAT (&gt;80%)\")\nelif csat &gt; 70:\n    print(\"Good CSAT (&gt;70%)\")\nelse:\n    print(\"Poor CSAT (&lt;70%)\")\n</code></pre>"},{"location":"examples/business_metrics/#user-activity-analysis","title":"User Activity Analysis","text":"<pre><code>from pypulate.kpi import daily_active_users_ratio, monthly_active_users_ratio, stickiness_ratio\n\n# Monthly user activity data\nmonths = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\"]\ntotal_users = [2000, 2200, 2500, 2800, 3100, 3500]\nmonthly_active_users = [1500, 1700, 2000, 2300, 2600, 3000]\ndaily_active_users = [500, 600, 700, 800, 900, 1100]\n\n# Calculate user activity metrics\ndau_ratios = []\nmau_ratios = []\nstickiness_ratios = []\n\nfor i in range(len(months)):\n    dau_ratio = daily_active_users_ratio(daily_active_users[i], total_users[i])\n    mau_ratio = monthly_active_users_ratio(monthly_active_users[i], total_users[i])\n    stickiness = stickiness_ratio(daily_active_users[i], monthly_active_users[i])\n\n    dau_ratios.append(dau_ratio)\n    mau_ratios.append(mau_ratio)\n    stickiness_ratios.append(stickiness)\n\n    print(f\"{months[i]}: DAU Ratio = {dau_ratio:.2f}%, MAU Ratio = {mau_ratio:.2f}%, Stickiness = {stickiness:.2f}%\")\n\n# Average stickiness\navg_stickiness = sum(stickiness_ratios) / len(stickiness_ratios)\nprint(f\"Average Stickiness Ratio: {avg_stickiness:.2f}%\")\n</code></pre>"},{"location":"examples/business_metrics/#financial-health-metrics","title":"Financial Health Metrics","text":""},{"location":"examples/business_metrics/#burn-rate-and-runway-analysis","title":"Burn Rate and Runway Analysis","text":"<pre><code>from pypulate.kpi import burn_rate, runway, gross_margin\n\n# Financial data\nstarting_capital = 1000000  # $1,000,000 starting capital\nending_capital = 700000     # $700,000 ending capital\nmonths = 6                  # 6 months period\ncurrent_capital = 700000    # $700,000 current capital\n\n# Revenue and costs\nrevenue = 150000            # $150,000 revenue\ncost_of_goods_sold = 45000  # $45,000 COGS\n\n# Calculate financial health metrics\nmonthly_burn = burn_rate(starting_capital, ending_capital, months)\nrunway_months = runway(current_capital, monthly_burn)\ngm = gross_margin(revenue, cost_of_goods_sold)\n\nprint(f\"Monthly Burn Rate: ${monthly_burn:.2f}\")\nprint(f\"Runway: {runway_months:.2f} months\")\nprint(f\"Gross Margin: {gm:.2f}%\")\n\n# Evaluate financial health\nif runway_months &gt; 18:\n    print(\"Healthy runway (&gt;18 months)\")\nelif runway_months &gt; 12:\n    print(\"Adequate runway (&gt;12 months)\")\nelse:\n    print(\"Concerning runway (&lt;12 months)\")\n</code></pre>"},{"location":"examples/business_metrics/#growth-metrics","title":"Growth Metrics","text":""},{"location":"examples/business_metrics/#conversion-and-virality-analysis","title":"Conversion and Virality Analysis","text":"<pre><code>from pypulate.kpi import conversion_rate, virality_coefficient, feature_adoption_rate\n\n# Growth data\nmonths = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\"]\ntotal_visitors = [10000, 12000, 15000, 18000, 22000, 25000]\nconversions = [500, 650, 800, 1000, 1300, 1500]\nnew_users = [400, 500, 600, 800, 1000, 1200]\ninvites_sent = [2000, 2500, 3000, 3500, 4000, 5000]\ntotal_users = [2000, 2400, 2900, 3500, 4300, 5300]\nusers_adopting_feature = [600, 800, 1000, 1400, 1800, 2300]\n\n# Calculate growth metrics\nconversion_rates = []\nvirality_coefficients = []\nfeature_adoption_rates = []\n\nfor i in range(len(months)):\n    conv_rate = conversion_rate(conversions[i], total_visitors[i])\n    virality = virality_coefficient(new_users[i], invites_sent[i], total_users[i])\n    feature_adoption = feature_adoption_rate(users_adopting_feature[i], total_users[i])\n\n    conversion_rates.append(conv_rate)\n    virality_coefficients.append(virality)\n    feature_adoption_rates.append(feature_adoption)\n\n    print(f\"{months[i]}: Conversion = {conv_rate:.2f}%, Virality = {virality:.2f}, Feature Adoption = {feature_adoption:.2f}%\")\n\n# Evaluate virality\navg_virality = sum(virality_coefficients) / len(virality_coefficients)\nif avg_virality &gt; 1:\n    print(\"Viral growth (coefficient &gt; 1)\")\nelse:\n    print(\"Non-viral growth (coefficient &lt; 1)\")\n</code></pre>"},{"location":"examples/financial_analysis/","title":"Financial Analysis Examples","text":"<p>This guide demonstrates various financial analysis strategies using the <code>pypulate</code> package.</p>"},{"location":"examples/financial_analysis/#technical-analysis","title":"Technical Analysis","text":""},{"location":"examples/financial_analysis/#moving-average-crossover-strategy","title":"Moving Average Crossover Strategy","text":"<pre><code>import numpy as np\nfrom pypulate import as_parray\n\n# Create sample price data\nprices = np.array([100, 102, 104, 103, 105, 107, 108, 107, 105, 104, 103, 105, 107, 109, 108])\n\n# Convert to Parray\nts = as_parray(prices)\n\n# Calculate fast and slow moving averages\nfast_ma = ts.ema(5)\nslow_ma = ts.ema(10)\n\n# Generate crossover signals\nbuy_signals = fast_ma.crossover(slow_ma)\nsell_signals = fast_ma.crossunder(slow_ma)\n\nprint(\"Buy signals:\", buy_signals)\nprint(\"Sell signals:\", sell_signals)\n</code></pre>"},{"location":"examples/financial_analysis/#rsi-overboughtoversold-strategy","title":"RSI Overbought/Oversold Strategy","text":"<pre><code># Calculate RSI\nrsi_values = ts.rsi(14)\n\n# Generate signals\nbuy_signals = rsi_values &lt; 30  # Oversold\nsell_signals = rsi_values &gt; 70  # Overbought\n\nprint(\"Buy signals (oversold):\", buy_signals)\nprint(\"Sell signals (overbought):\", sell_signals)\n</code></pre>"},{"location":"examples/financial_analysis/#macd-strategy","title":"MACD Strategy","text":"<pre><code># Calculate MACD\nmacd_line, signal_line, histogram = ts.macd()\n\n# Generate signals\nbuy_signals = macd_line.crossover(signal_line)\nsell_signals = macd_line.crossunder(signal_line)\n\nprint(\"Buy signals (MACD crossover):\", buy_signals)\nprint(\"Sell signals (MACD crossunder):\", sell_signals)\n</code></pre>"},{"location":"examples/financial_analysis/#bollinger-bands-strategy","title":"Bollinger Bands Strategy","text":"<pre><code># Calculate Bollinger Bands\nupper, middle, lower = ts.bollinger_bands(20, 2.0)\n\n# Generate signals\nbuy_signals = ts &lt; lower  # Price below lower band\nsell_signals = ts &gt; upper  # Price above upper band\n\nprint(\"Buy signals (price below lower band):\", buy_signals)\nprint(\"Sell signals (price above upper band):\", sell_signals)\n</code></pre>"},{"location":"examples/financial_analysis/#volatility-analysis","title":"Volatility Analysis","text":""},{"location":"examples/financial_analysis/#atr-based-position-sizing","title":"ATR-Based Position Sizing","text":"<pre><code># Calculate ATR\natr_values = ts.atr(14)\n\n# Define risk parameters\naccount_size = 10000  # $10,000 account\nrisk_percentage = 0.02  # 2% risk per trade\nrisk_amount = account_size * risk_percentage  # $200 risk per trade\n\n# Calculate position size based on ATR\ncurrent_price = prices[-1]\ncurrent_atr = atr_values[-1]\nstop_loss_distance = 2 * current_atr  # 2 ATR units for stop loss\n\n# Position size calculation\nposition_size = risk_amount / stop_loss_distance\nposition_value = position_size * current_price\n\nprint(f\"Current price: ${current_price}\")\nprint(f\"Current ATR: ${current_atr}\")\nprint(f\"Stop loss distance: ${stop_loss_distance}\")\nprint(f\"Position size: {position_size} shares\")\nprint(f\"Position value: ${position_value}\")\n</code></pre>"},{"location":"examples/financial_analysis/#volatility-regime-detection","title":"Volatility Regime Detection","text":"<pre><code># Calculate historical volatility\nhist_vol = ts.historical_volatility(21, 252)\n\n# Define volatility regimes\nlow_vol = hist_vol &lt; 15  # Less than 15% annualized volatility\nmedium_vol = (hist_vol &gt;= 15) &amp; (hist_vol &lt; 30)\nhigh_vol = hist_vol &gt;= 30  # More than 30% annualized volatility\n\nprint(\"Low volatility regime:\", low_vol)\nprint(\"Medium volatility regime:\", medium_vol)\nprint(\"High volatility regime:\", high_vol)\n</code></pre>"},{"location":"examples/financial_analysis/#multi-indicator-strategy","title":"Multi-Indicator Strategy","text":"<pre><code># Create a more complex strategy combining multiple indicators\ncomplex_buy_signals = (\n    (ts.rsi(14) &lt; 30) &amp;                          # RSI oversold\n    (ts.macd()[0].crossover(ts.macd()[1])) &amp;     # MACD bullish crossover\n    (ts &lt; ts.bollinger_bands(20, 2.0)[2])        # Price below lower Bollinger Band\n)\n\ncomplex_sell_signals = (\n    (ts.rsi(14) &gt; 70) &amp;                          # RSI overbought\n    (ts.macd()[0].crossunder(ts.macd()[1])) &amp;    # MACD bearish crossunder\n    (ts &gt; ts.bollinger_bands(20, 2.0)[0])        # Price above upper Bollinger Band\n)\n\nprint(\"Complex buy signals:\", complex_buy_signals)\nprint(\"Complex sell signals:\", complex_sell_signals)\n</code></pre>"},{"location":"examples/financial_analysis/#backtesting-simplified","title":"Backtesting (Simplified)","text":"<pre><code># Simplified backtesting example\ndef simple_backtest(prices, buy_signals, sell_signals):\n    cash = 10000  # Initial cash\n    shares = 0    # Initial shares\n    position_value = 0\n\n    for i in range(len(prices)):\n        if buy_signals[i] and cash &gt; 0:\n            # Buy as many shares as possible\n            shares = cash / prices[i]\n            cash = 0\n            print(f\"Day {i}: BUY at ${prices[i]}, Shares: {shares}\")\n\n        elif sell_signals[i] and shares &gt; 0:\n            # Sell all shares\n            cash = shares * prices[i]\n            shares = 0\n            print(f\"Day {i}: SELL at ${prices[i]}, Cash: ${cash}\")\n\n        # Calculate current position value\n        position_value = cash + (shares * prices[i])\n\n    return position_value\n\n# Generate signals for backtest\nsma_fast = ts.sma(5)\nsma_slow = ts.sma(10)\nbuy_signals = sma_fast.crossover(sma_slow)\nsell_signals = sma_fast.crossunder(sma_slow)\n\n# Run backtest\nfinal_value = simple_backtest(prices, buy_signals, sell_signals)\nprint(f\"Final portfolio value: ${final_value}\")\n</code></pre>"},{"location":"user-guide/allocation/","title":"Portfolio Allocation Examples","text":"<p>This document demonstrates various portfolio optimization methods available in the <code>pypulate</code> library using the <code>Allocation</code> class.</p>"},{"location":"user-guide/allocation/#overview","title":"Overview","text":"<p>The <code>Allocation</code> class provides several portfolio optimization methods:</p> <ol> <li>Mean-Variance Optimization</li> <li>Minimum Variance Portfolio</li> <li>Maximum Sharpe Ratio Portfolio</li> <li>Risk Parity Portfolio</li> <li>Maximum Diversification Portfolio</li> <li>Equal Weight Portfolio</li> <li>Market Cap Weight Portfolio</li> <li>Kelly Criterion Portfolio</li> <li>Black-Litterman Portfolio</li> <li>Hierarchical Risk Parity Portfolio</li> </ol>"},{"location":"user-guide/allocation/#basic-usage","title":"Basic Usage","text":"<p>First, let's import the necessary components:</p> <pre><code>from pypulate import Allocation, Parray\n</code></pre>"},{"location":"user-guide/allocation/#basic-portfolio-optimization","title":"Basic Portfolio Optimization","text":"<p>Let's start with a simple example using 3 assets:</p> <pre><code># Sample returns data (3 assets, 252 days of daily returns)\nreturns = Parray([\n    # Asset 1 (e.g., AAPL)\n    [0.02, -0.01, 0.015, 0.03, -0.005, 0.01, 0.02, -0.015, 0.025, 0.01] + \n    [0.015, -0.02, 0.01, 0.02, -0.01, 0.015, 0.025, -0.01, 0.02, 0.015] * 24 + \n    [0.015, -0.02, 0.01, 0.02, -0.01, 0.015, 0.025, -0.01, 0.02, 0.015],\n\n    # Asset 2 (e.g., MSFT)\n    [0.015, 0.02, -0.01, 0.025, 0.01, -0.015, 0.02, 0.01, -0.02, 0.015] + \n    [0.02, -0.015, 0.015, 0.025, -0.01, 0.02, 0.015, -0.015, 0.02, 0.01] * 24 + \n    [0.02, -0.015, 0.015, 0.025, -0.01, 0.02, 0.015, -0.015, 0.02, 0.01],\n\n    # Asset 3 (e.g., GOOGL)\n    [0.025, -0.02, 0.02, 0.015, -0.015, 0.02, 0.025, -0.02, 0.03, 0.02] + \n    [0.025, -0.02, 0.02, 0.015, -0.015, 0.02, 0.025, -0.02, 0.03, 0.02] * 24 + \n    [0.025, -0.02, 0.02, 0.015, -0.015, 0.02, 0.025, -0.02, 0.03, 0.02]\n]).T\n\n# Initialize the Allocation class\nallocation = Allocation()\n\n# Set risk-free rate (e.g., current 10-year Treasury yield)\nrisk_free_rate = 0.04  # 4% annual rate\n\n# Perform Mean-Variance Optimization\nweights, ret, risk = allocation.mean_variance(\n    returns=returns,\n    target_return=None,  # Maximize Sharpe ratio\n    risk_free_rate=risk_free_rate\n)\n\nprint(f\"Optimal Portfolio Weights: {weights}\")\nprint(f\"Expected Return: {ret:.4f}\")\nprint(f\"Portfolio Risk: {risk:.4f}\")\n</code></pre>"},{"location":"user-guide/allocation/#risk-parity-portfolio","title":"Risk Parity Portfolio","text":"<p>Risk Parity aims to equalize the risk contribution of each asset:</p> <pre><code># Calculate Risk Parity weights\nweights, ret, risk = allocation.risk_parity(returns=returns)\n\nprint(f\"Risk Parity Weights: {weights}\")\nprint(f\"Expected Return: {ret:.4f}\")\nprint(f\"Portfolio Risk: {risk:.4f}\")\n</code></pre>"},{"location":"user-guide/allocation/#kelly-criterion-with-conservative-sizing","title":"Kelly Criterion with Conservative Sizing","text":"<p>The Kelly Criterion can be aggressive, so we often use a fraction of the optimal weights:</p> <pre><code># Calculate Kelly Criterion weights\nweights, ret, risk = allocation.kelly_criterion(\n    returns=returns,\n    risk_free_rate=risk_free_rate\n)\n\n# Use half-Kelly for more conservative position sizing\nhalf_kelly_weights = weights * 0.5\n\nprint(f\"Full Kelly Weights: {weights}\")\nprint(f\"Half-Kelly Weights: {half_kelly_weights}\")\n</code></pre>"},{"location":"user-guide/allocation/#black-litterman-portfolio-with-views","title":"Black-Litterman Portfolio with Views","text":"<p>Black-Litterman allows incorporating market views into the optimization:</p> <pre><code># Market capitalizations\nmarket_caps = Parray([2.5e12, 2.8e12, 1.8e12])  # in USD\n\n# Define views (e.g., AAPL to outperform by 2%, GOOGL to underperform by 1%)\nviews = {0: 0.02, 2: -0.01}  # Asset indices and expected excess returns\nview_confidences = {0: 0.8, 2: 0.7}  # Confidence in views (0-1)\n\n# Calculate Black-Litterman weights\nweights, ret, risk = allocation.black_litterman(\n    returns=returns,\n    market_caps=market_caps,\n    views=views,\n    view_confidences=view_confidences,\n    tau=0.05,  # Uncertainty in the prior distribution\n    risk_free_rate=risk_free_rate\n)\n\nprint(f\"Black-Litterman Weights: {weights}\")\n</code></pre>"},{"location":"user-guide/allocation/#hierarchical-risk-parity","title":"Hierarchical Risk Parity","text":"<p>HRP uses hierarchical clustering to build a more robust portfolio:</p> <pre><code># Calculate HRP weights\nweights, ret, risk = allocation.hierarchical_risk_parity(\n    returns=returns,\n    linkage_method='ward',  # Using Ward linkage for clustering\n    distance_metric='correlation'  # Using correlation-based distance\n)\n\nprint(f\"HRP Weights: {weights}\")\n</code></pre>"},{"location":"user-guide/allocation/#comparing-different-methods","title":"Comparing Different Methods","text":"<p>Here's how to compare the performance of different optimization methods:</p> <pre><code># Define methods to compare\nmethods = [\n    (\"Mean-Variance\", allocation.mean_variance(returns, risk_free_rate=risk_free_rate)),\n    (\"Minimum Variance\", allocation.minimum_variance(returns)),\n    (\"Maximum Sharpe\", allocation.maximum_sharpe(returns, risk_free_rate=risk_free_rate)),\n    (\"Risk Parity\", allocation.risk_parity(returns)),\n    (\"Kelly Criterion\", allocation.kelly_criterion(returns, risk_free_rate=risk_free_rate))\n]\n\n# Compare results\nprint(\"\\nMethod Comparison Summary:\")\nprint(\"-\" * 50)\nprint(f\"{'Method':&lt;25} {'Return':&gt;10} {'Risk':&gt;10} {'Sharpe':&gt;10}\")\nprint(\"-\" * 50)\nfor method_name, (weights, ret, risk) in methods:\n    sharpe = (ret - risk_free_rate) / risk\n    print(f\"{method_name:&lt;25} {ret*100:&gt;9.2f}% {risk*100:&gt;9.2f}% {sharpe:&gt;9.2f}\")\n</code></pre>"},{"location":"user-guide/allocation/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/allocation/#1-data-preparation","title":"1. Data Preparation","text":"<ul> <li>1.1. Data Quality: Use clean, adjusted price data</li> <li>1.2. Missing Values: Handle missing values appropriately</li> <li>1.3. Transaction Costs: Consider transaction costs and liquidity</li> </ul>"},{"location":"user-guide/allocation/#2-risk-management","title":"2. Risk Management","text":"<ul> <li>2.1. Position Sizing: Consider using half-Kelly or quarter-Kelly for more conservative position sizing</li> <li>2.2. Constraints: Implement position limits and constraints</li> <li>2.3. Monitoring: Monitor portfolio turnover and rebalancing needs</li> </ul>"},{"location":"user-guide/allocation/#3-method-selection","title":"3. Method Selection","text":"<ul> <li>3.1. Mean-Variance: Good for traditional portfolio optimization</li> <li>3.2. Risk Parity: Better for risk management</li> <li>3.3. Kelly Criterion: Best for long-term growth</li> <li>3.4. Black-Litterman: Ideal when you have strong market views</li> <li>3.5. HRP: More robust to estimation errors</li> </ul>"},{"location":"user-guide/allocation/#4-portfolio-maintenance","title":"4. Portfolio Maintenance","text":"<ul> <li>4.1. Rebalancing Thresholds: Set appropriate rebalancing thresholds</li> <li>4.2. Cost Management: Consider transaction costs when rebalancing</li> <li>4.3. Tracking Error: Monitor tracking error against benchmarks</li> </ul>"},{"location":"user-guide/allocation/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"user-guide/allocation/#1-estimation-issues","title":"1. Estimation Issues","text":"<ul> <li>1.1. Overfitting: Use sufficient historical data</li> <li>1.2. Sample Bias: Consider using rolling windows</li> <li>1.3. Validation: Implement out-of-sample testing</li> </ul>"},{"location":"user-guide/allocation/#2-statistical-challenges","title":"2. Statistical Challenges","text":"<ul> <li>2.1. Estimation Error: Use robust estimation methods</li> <li>2.2. Shrinkage: Consider shrinkage estimators</li> <li>2.3. Regularization: Implement proper regularization</li> </ul>"},{"location":"user-guide/allocation/#3-implementation-realities","title":"3. Implementation Realities","text":"<ul> <li>3.1. Bid-Ask Spreads: Account for bid-ask spreads</li> <li>3.2. Market Impact: Consider market impact of trades</li> <li>3.3. Turnover Constraints: Implement turnover constraints</li> </ul>"},{"location":"user-guide/filters/","title":"Filters","text":"<p>Pypulate provides a comprehensive set of filtering techniques for financial time series data. This page explains the different types of filters available and how to use them.</p>"},{"location":"user-guide/filters/#overview","title":"Overview","text":"<p>Filters in Pypulate are designed to clean, smooth, and extract meaningful information from noisy financial time series data. The module includes:</p> <ol> <li>Kalman Filters: Optimal estimators for linear systems</li> <li>Signal Filters: Classical signal processing filters</li> <li>Adaptive Filters: Filters that adapt to changing data characteristics</li> <li>Particle Filters: Monte Carlo methods for non-linear/non-Gaussian systems</li> </ol>"},{"location":"user-guide/filters/#kalman-filters","title":"Kalman Filters","text":"<p>Kalman filters are optimal estimators that infer parameters of interest from indirect, inaccurate, and uncertain observations.</p>"},{"location":"user-guide/filters/#standard-kalman-filter","title":"Standard Kalman Filter","text":"<p>The standard Kalman filter is ideal for linear systems with Gaussian noise:</p> <pre><code>import numpy as np\nfrom pypulate.filters import kalman_filter\n\n# Create noisy data\nx = np.linspace(0, 10, 100)\ntrue_signal = np.sin(x)\nnoisy_signal = true_signal + np.random.normal(0, 0.1, len(x))\n\n# Apply Kalman filter\nfiltered_signal = kalman_filter(\n    noisy_signal,\n    process_variance=1e-5,\n    measurement_variance=1e-3\n)\n</code></pre>"},{"location":"user-guide/filters/#extended-kalman-filter-ekf","title":"Extended Kalman Filter (EKF)","text":"<p>The EKF is used for non-linear systems by linearizing around the current estimate:</p> <pre><code>import numpy as np\nfrom pypulate.filters import extended_kalman_filter\n\n# Define non-linear system\ndef state_transition(x):\n    # Non-linear state transition function\n    return np.array([x[0] + x[1], 0.5 * x[1]])\n\ndef observation(x):\n    # Non-linear observation function\n    return np.array([np.sin(x[0])])\n\ndef process_jacobian(x):\n    # Jacobian of state transition function\n    return np.array([[1, 1], [0, 0.5]])\n\ndef observation_jacobian(x):\n    # Jacobian of observation function\n    return np.array([[np.cos(x[0]), 0]])\n\n# Apply EKF\nQ = np.eye(2) * 0.01  # Process noise covariance\nR = np.array([[0.1]])  # Observation noise covariance\nfiltered_states = extended_kalman_filter(\n    observations, state_transition, observation,\n    process_jacobian, observation_jacobian, Q, R\n)\n</code></pre>"},{"location":"user-guide/filters/#unscented-kalman-filter-ukf","title":"Unscented Kalman Filter (UKF)","text":"<p>The UKF uses sigma points to handle non-linearities without requiring Jacobians:</p> <pre><code>import numpy as np\nfrom pypulate.filters import unscented_kalman_filter\n\n# Define non-linear system\ndef state_transition(x):\n    # Non-linear state transition function\n    return np.array([x[0] + x[1], 0.5 * x[1]])\n\ndef observation(x):\n    # Non-linear observation function\n    return np.array([np.sin(x[0])])\n\n# Apply UKF\nQ = np.eye(2) * 0.01  # Process noise covariance\nR = np.array([[0.1]])  # Observation noise covariance\nfiltered_states = unscented_kalman_filter(\n    observations, state_transition, observation, Q, R\n)\n</code></pre>"},{"location":"user-guide/filters/#signal-filters","title":"Signal Filters","text":"<p>Signal filters are used to remove noise and extract specific frequency components from time series data.</p>"},{"location":"user-guide/filters/#butterworth-filter","title":"Butterworth Filter","text":"<p>The Butterworth filter provides a flat frequency response in the passband:</p> <pre><code>import numpy as np\nfrom pypulate.filters import butterworth_filter\n\n# Create noisy data with multiple frequency components\nx = np.linspace(0, 10, 1000)\nsignal = np.sin(2 * np.pi * 0.05 * x) + 0.5 * np.sin(2 * np.pi * 0.25 * x)\n\n# Apply lowpass filter to remove high frequency component\nfiltered = butterworth_filter(\n    signal,\n    cutoff=0.1,  # Cutoff frequency\n    order=4,     # Filter order\n    filter_type='lowpass'\n)\n</code></pre>"},{"location":"user-guide/filters/#savitzky-golay-filter","title":"Savitzky-Golay Filter","text":"<p>The Savitzky-Golay filter smooths data by fitting successive sub-sets of adjacent data points with a low-degree polynomial:</p> <pre><code>import numpy as np\nfrom pypulate.filters import savitzky_golay_filter\n\n# Create noisy data\nx = np.linspace(0, 10, 100)\nsignal = np.sin(x) + np.random.normal(0, 0.1, len(x))\n\n# Apply Savitzky-Golay filter\nfiltered = savitzky_golay_filter(\n    signal,\n    window_length=11,  # Must be odd\n    polyorder=3        # Polynomial order\n)\n</code></pre>"},{"location":"user-guide/filters/#median-filter","title":"Median Filter","text":"<p>The median filter is excellent for removing outliers:</p> <pre><code>import numpy as np\nfrom pypulate.filters import median_filter\n\n# Create data with outliers\nx = np.linspace(0, 10, 100)\nsignal = np.sin(x)\nsignal[10] = 5  # Add outlier\nsignal[50] = -5  # Add outlier\n\n# Apply median filter\nfiltered = median_filter(signal, kernel_size=5)\n</code></pre>"},{"location":"user-guide/filters/#hampel-filter","title":"Hampel Filter","text":"<p>The Hampel filter is specifically designed for outlier detection and removal:</p> <pre><code>import numpy as np\nfrom pypulate.filters import hampel_filter\n\n# Create data with outliers\nx = np.linspace(0, 10, 100)\nsignal = np.sin(x)\nsignal[10] = 5  # Add outlier\nsignal[50] = -5  # Add outlier\n\n# Apply Hampel filter\nfiltered = hampel_filter(\n    signal,\n    window_size=5,  # Window size\n    n_sigmas=3.0    # Threshold for outlier detection\n)\n</code></pre>"},{"location":"user-guide/filters/#hodrick-prescott-filter","title":"Hodrick-Prescott Filter","text":"<p>The Hodrick-Prescott filter decomposes a time series into trend and cycle components:</p> <pre><code>import numpy as np\nfrom pypulate.filters import hodrick_prescott_filter\n\n# Create data with trend and cycle\nx = np.linspace(0, 10, 100)\ntrend = 0.1 * x**2\ncycle = np.sin(2 * np.pi * 0.1 * x)\ndata = trend + cycle\n\n# Apply Hodrick-Prescott filter\ntrend_component, cycle_component = hodrick_prescott_filter(\n    data,\n    lambda_param=100  # Smoothing parameter\n)\n</code></pre>"},{"location":"user-guide/filters/#adaptive-filters","title":"Adaptive Filters","text":"<p>Adaptive filters automatically adjust their parameters based on the input data.</p>"},{"location":"user-guide/filters/#adaptive-kalman-filter","title":"Adaptive Kalman Filter","text":"<p>The adaptive Kalman filter adjusts its noise parameters based on the observed data:</p> <pre><code>import numpy as np\nfrom pypulate.filters import adaptive_kalman_filter\n\n# Create noisy data with changing dynamics\nx = np.linspace(0, 10, 200)\ntrue_signal = np.sin(x) + 0.1 * x\nnoise_level = 0.1 * (1 + np.sin(x/2))  # Changing noise level\nnoisy_signal = true_signal + noise_level * np.random.randn(len(x))\n\n# Apply adaptive Kalman filter\nfiltered_signal = adaptive_kalman_filter(\n    noisy_signal,\n    adaptation_rate=0.05,  # Rate of adaptation\n    window_size=10         # Window for innovation estimation\n)\n</code></pre>"},{"location":"user-guide/filters/#least-mean-squares-lms-filter","title":"Least Mean Squares (LMS) Filter","text":"<p>The LMS filter is a simple adaptive filter that minimizes the mean square error:</p> <pre><code>import numpy as np\nfrom pypulate.filters import least_mean_squares_filter\n\n# Create noisy data\nx = np.linspace(0, 10, 1000)\nclean_signal = np.sin(2 * np.pi * 0.05 * x)\nnoise = 0.2 * np.random.randn(len(x))\nnoisy_signal = clean_signal + noise\n\n# Apply LMS filter\nfiltered_signal, weights = least_mean_squares_filter(\n    noisy_signal,\n    filter_length=10,  # Filter length\n    mu=0.02            # Step size\n)\n</code></pre>"},{"location":"user-guide/filters/#particle-filters","title":"Particle Filters","text":"<p>Particle filters are Monte Carlo methods that can handle non-linear and non-Gaussian systems.</p>"},{"location":"user-guide/filters/#standard-particle-filter","title":"Standard Particle Filter","text":"<p>The particle filter uses a set of particles to represent the posterior distribution:</p> <pre><code>import numpy as np\nfrom pypulate.filters import particle_filter\n\n# Define model functions\ndef state_transition(particles):\n    # Simple random walk model\n    return particles\n\ndef process_noise(particles):\n    # Add Gaussian noise\n    return particles + np.random.normal(0, 0.1, particles.shape)\n\ndef observation_func(state):\n    # Identity observation model\n    return state\n\ndef observation_likelihood(observation, predicted_observation):\n    # Gaussian likelihood\n    return np.exp(-0.5 * ((observation - predicted_observation) / 0.1) ** 2)\n\ndef initial_state(n):\n    # Initial particles from normal distribution\n    return np.random.normal(0, 1, n)\n\n# Apply particle filter\nfiltered_states, weights = particle_filter(\n    observations,\n    state_transition,\n    observation_func,\n    process_noise,\n    observation_likelihood,\n    n_particles=1000,\n    initial_state_func=initial_state\n)\n</code></pre>"},{"location":"user-guide/filters/#bootstrap-particle-filter","title":"Bootstrap Particle Filter","text":"<p>The bootstrap particle filter is a simplified version that resamples at every step:</p> <pre><code>import numpy as np\nfrom pypulate.filters import bootstrap_particle_filter\n\n# Define model functions\ndef state_transition(particles):\n    # Simple random walk model\n    return particles\n\ndef observation_func(state):\n    # Identity observation model\n    return state\n\n# Apply bootstrap particle filter\nfiltered_states, weights = bootstrap_particle_filter(\n    observations,\n    state_transition,\n    observation_func,\n    process_noise_std=0.1,\n    observation_noise_std=0.1,\n    n_particles=1000\n)\n</code></pre>"},{"location":"user-guide/filters/#choosing-the-right-filter","title":"Choosing the Right Filter","text":"<p>The choice of filter depends on your specific application:</p> <ul> <li>Kalman Filters: Best for linear systems or when you have a good model of the system dynamics</li> <li>Signal Filters: Good for general noise removal and frequency-based filtering</li> <li>Adaptive Filters: Useful when the signal characteristics change over time</li> <li>Particle Filters: Best for highly non-linear systems or non-Gaussian noise</li> </ul> <p>For financial time series, consider:</p> <ul> <li>Kalman/Adaptive Filters: For tracking changing trends</li> <li>Hampel/Median Filters: For removing outliers (e.g., flash crashes)</li> <li>Hodrick-Prescott Filter: For separating trend and cycle components</li> <li>Butterworth Filter: For removing high-frequency noise</li> </ul>"},{"location":"user-guide/filters/#example-combining-filters","title":"Example: Combining Filters","text":"<p>You can combine multiple filters for more sophisticated processing:</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom pypulate.filters import hampel_filter, kalman_filter\n\n# Create data with outliers and noise\nx = np.linspace(0, 10, 200)\ntrue_signal = np.sin(x) + 0.1 * x\nnoisy_signal = true_signal + 0.1 * np.random.randn(len(x))\nnoisy_signal[20] = 5  # Add outlier\nnoisy_signal[100] = -5  # Add outlier\n\n# First remove outliers with Hampel filter\noutlier_removed = hampel_filter(noisy_signal, window_size=5, n_sigmas=3.0)\n\n# Then smooth with Kalman filter\nfinal_signal = kalman_filter(outlier_removed, process_variance=1e-5, measurement_variance=1e-3)\n\n# Plot results\nplt.figure(figsize=(12, 6))\nplt.plot(x, true_signal, 'k-', label='True Signal')\nplt.plot(x, noisy_signal, 'r.', alpha=0.5, label='Noisy Signal with Outliers')\nplt.plot(x, outlier_removed, 'g-', alpha=0.7, label='After Hampel Filter')\nplt.plot(x, final_signal, 'b-', linewidth=2, label='After Kalman Filter')\nplt.legend()\nplt.title('Multi-stage Filtering')\nplt.grid(True, alpha=0.3)\nplt.show()\n</code></pre> <p>Filters also works with Parray chain methods. You can combine them with other tools easily to make advanced techniques.</p>"},{"location":"user-guide/getting-started/","title":"Getting Started with Pypulate","text":"<p>This guide will help you get started with Pypulate for financial time series analysis, business KPI calculations, and portfolio management.</p>"},{"location":"user-guide/getting-started/#installation","title":"Installation","text":"<pre><code>pip install pypulate\n</code></pre>"},{"location":"user-guide/getting-started/#core-components","title":"Core Components","text":"<p>Pypulate provides powerful classes for financial and business analytics:</p>"},{"location":"user-guide/getting-started/#1-parray-pypulate-array","title":"1. Parray (Pypulate Array)","text":"<p>The <code>Parray</code> class extends NumPy arrays with financial analysis capabilities:</p> <pre><code>from pypulate import Parray\n\n# Create a price array\nprices = Parray([10, 11, 12, 11, 10, 9, 10, 11, 12, 13, 15, 11, 8, 10, 14, 16])\n\n# Technical Analysis with method chaining\nresult = (prices\n    .sma(3)                     # Simple Moving Average\n    .ema(3)                    # Exponential Moving Average\n    .rsi(7)                    # Relative Strength Index\n)\n\n# Signal Detection\nfast_ma = prices.sma(3)\nslow_ma = prices.sma(12)\ngolden_cross = fast_ma.crossover(slow_ma)\ndeath_cross = fast_ma.crossunder(slow_ma)\n</code></pre>"},{"location":"user-guide/getting-started/#2-kpi-key-performance-indicators","title":"2. KPI (Key Performance Indicators)","text":"<p>The <code>KPI</code> class manages business metrics and health assessment:</p> <pre><code>from pypulate import KPI\n\n# Initialize KPI tracker\nkpi = KPI()\n\n# Customer Metrics\nchurn = kpi.churn_rate(\n    customers_start=1000,\n    customers_end=950,\n    new_customers=50\n)\n\n# Financial Metrics\nclv = kpi.customer_lifetime_value(\n    avg_revenue_per_customer=100,\n    gross_margin=70,\n    churn_rate_value=5\n)\n\n# Health Assessment\nhealth = kpi.health\nprint(f\"Business Health Score: {health['overall_score']}\")\nprint(f\"Status: {health['status']}\")\n</code></pre>"},{"location":"user-guide/getting-started/#3-portfolio","title":"3. Portfolio","text":"<p>The <code>Portfolio</code> class handles portfolio analysis and risk management:</p> <pre><code>from pypulate import Portfolio\n\n# Initialize portfolio analyzer\nportfolio = Portfolio()\n\n# Calculate Returns\nreturns = portfolio.simple_return([50, 100, 120], [60, 70, 120])\ntwrr = portfolio.time_weighted_return(\n    [0.02, 0.01, 0.1, 0.003]\n)\n\n# Risk Analysis\nsharpe = portfolio.sharpe_ratio(returns, risk_free_rate=0.02)\nvar = portfolio.value_at_risk(returns, confidence_level=0.95)\n\n# Portfolio Health\nhealth = portfolio.health\nprint(f\"Portfolio Health Score: {health['overall_score']}\")\nprint(f\"Risk Status: {health['components']['risk']['status']}\")\n</code></pre>"},{"location":"user-guide/getting-started/#4-allocation","title":"4. Allocation","text":"<p>The <code>Allocation</code> class provides advanced portfolio optimization and asset allocation methods:</p> <pre><code>from pypulate import Allocation\nimport numpy as np\n\n# Initialize allocation optimizer\nallocation = Allocation()\n\n# Sample returns data (252 days, 5 assets)\nreturns = np.random.normal(0.0001, 0.02, (252, 5))\nrisk_free_rate = 0.04\n\n# Mean-Variance Optimization\nweights, ret, risk = allocation.mean_variance(\n    returns, \n    risk_free_rate=risk_free_rate\n)\nprint(f\"Mean-Variance Portfolio:\")\nprint(f\"Expected Return: {ret:.2%}\")\nprint(f\"Risk: {risk:.2%}\")\nprint(f\"Weights: {weights}\")\n\n# Risk Parity Portfolio\nweights, ret, risk = allocation.risk_parity(returns)\nprint(f\"\\nRisk Parity Portfolio:\")\nprint(f\"Expected Return: {ret:.2%}\")\nprint(f\"Risk: {risk:.2%}\")\nprint(f\"Weights: {weights}\")\n\n# Kelly Criterion (with half-Kelly)\nweights, ret, risk = allocation.kelly_criterion(\n    returns, \n    kelly_fraction=0.5\n)\nprint(f\"\\nHalf-Kelly Portfolio:\")\nprint(f\"Expected Return: {ret:.2%}\")\nprint(f\"Risk: {risk:.2%}\")\nprint(f\"Weights: {weights}\")\n\n# Black-Litterman with views\nviews = {0: 0.15, 1: 0.12}  # Views on first two assets\nview_confidences = {0: 0.8, 1: 0.7}\nmarket_caps = np.array([1000, 800, 600, 400, 200])\nweights, ret, risk = allocation.black_litterman(\n    returns, \n    market_caps, \n    views, \n    view_confidences\n)\nprint(f\"\\nBlack-Litterman Portfolio:\")\nprint(f\"Expected Return: {ret:.2%}\")\nprint(f\"Risk: {risk:.2%}\")\nprint(f\"Weights: {weights}\")\n\n# Hierarchical Risk Parity\nweights, ret, risk = allocation.hierarchical_risk_parity(returns)\nprint(f\"\\nHierarchical Risk Parity Portfolio:\")\nprint(f\"Expected Return: {ret:.2%}\")\nprint(f\"Risk: {risk:.2%}\")\nprint(f\"Weights: {weights}\")\n</code></pre>"},{"location":"user-guide/getting-started/#5-servicepricing","title":"5. ServicePricing","text":"<p>The <code>ServicePricing</code> class provides a unified interface for various pricing models:</p> <pre><code>from pypulate import ServicePricing\n\n# Initialize pricing calculator\npricing = ServicePricing()\n\n# Tiered Pricing\nprice = pricing.calculate_tiered_price(\n    usage_units=1500,\n    tiers={\n        \"0-1000\": 0.10,    # First tier: $0.10 per unit\n        \"1001-2000\": 0.08, # Second tier: $0.08 per unit\n        \"2001+\": 0.05      # Final tier: $0.05 per unit\n    }\n)\nprint(f\"Tiered Price: ${price:.2f}\")  # $140.00 (1000 * 0.10 + 500 * 0.08)\n\n# Subscription with Features\nsub_price = pricing.calculate_subscription_price(\n    base_price=99.99,\n    features=['premium', 'api_access'],\n    feature_prices={'premium': 49.99, 'api_access': 29.99},\n    duration_months=12,\n    discount_rate=0.10\n)\n\n# Track Pricing History\npricing.save_current_pricing()\nhistory = pricing.get_pricing_history()\n</code></pre>"},{"location":"user-guide/getting-started/#common-patterns","title":"Common Patterns","text":""},{"location":"user-guide/getting-started/#1-method-chaining","title":"1. Method Chaining","text":"<p>Parray support method chaining for cleaner code:</p> <pre><code># Parray chaining\nsignals = (Parray(prices)\n    .sma(10)\n    .crossover(Parray(prices).sma(20))\n)\n</code></pre>"},{"location":"user-guide/getting-started/#2-health-assessments","title":"2. Health Assessments","text":"<p>Portfolio and KPI classes provide health assessments with consistent scoring:</p> <pre><code># Business Health\nkpi_health = kpi.health  # Business metrics health\n\n# Portfolio Health\nportfolio_health = portfolio.health  # Portfolio performance health\n\n# Health Status Categories\n# - Excellent: \u2265 90\n# - Good: \u2265 75\n# - Fair: \u2265 60\n# - Poor: \u2265 45\n# - Critical: &lt; 45\n</code></pre>"},{"location":"user-guide/getting-started/#3-state-management","title":"3. State Management","text":"<p>All classes maintain state for tracking and analysis:</p> <pre><code># KPI state\nstored_churn = kpi._state['churn_rate']\nstored_retention = kpi._state['retention_rate']\n\n# Portfolio state\nstored_returns = portfolio._state['returns']\nstored_risk = portfolio._state['volatility']\n\n# ServicePricing state\nstored_pricing = pricing._state['current_pricing']\npricing_history = pricing._state['pricing_history']\n</code></pre>"},{"location":"user-guide/getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basic components, explore these topics in detail:</p> <ul> <li>Parray Guide: Advanced technical analysis and signal detection</li> <li>KPI Guide: Comprehensive business metrics and health scoring</li> <li>Portfolio Guide: Portfolio analysis and risk management</li> <li>Service Pricing Guide: Pricing models and calculations</li> </ul>"},{"location":"user-guide/kpi/","title":"KPI Guide","text":"<p>The <code>KPI</code> class provides a comprehensive suite of methods for calculating and tracking business metrics. It maintains state to provide health assessments and trend analysis.</p>"},{"location":"user-guide/kpi/#basic-usage","title":"Basic Usage","text":"<pre><code>from pypulate import KPI\n\n# Initialize KPI tracker\nkpi = KPI()\n\n# Calculate basic metrics\nchurn = kpi.churn_rate(customers_start=1000, customers_end=950, new_customers=50)\nretention = kpi.retention_rate(customers_start=1000, customers_end=950, new_customers=50)\n\n# Get health assessment\nhealth = kpi.health\n</code></pre>"},{"location":"user-guide/kpi/#customer-metrics","title":"Customer Metrics","text":""},{"location":"user-guide/kpi/#churn-and-retention","title":"Churn and Retention","text":"<pre><code># Calculate churn rate\nchurn = kpi.churn_rate(\n    customers_start=1000,  # Starting customer count\n    customers_end=950,     # Ending customer count\n    new_customers=50       # New customers acquired\n)\n\n# Calculate retention rate\nretention = kpi.retention_rate(\n    customers_start=1000,\n    customers_end=950,\n    new_customers=50\n)\n</code></pre>"},{"location":"user-guide/kpi/#customer-lifetime-value","title":"Customer Lifetime Value","text":"<pre><code>clv = kpi.customer_lifetime_value(\n    avg_revenue_per_customer=100,  # Monthly revenue per customer\n    gross_margin=70,              # Gross margin percentage\n    churn_rate_value=5,          # Monthly churn rate\n    discount_rate=10             # Annual discount rate\n)\n</code></pre>"},{"location":"user-guide/kpi/#financial-metrics","title":"Financial Metrics","text":""},{"location":"user-guide/kpi/#revenue-metrics","title":"Revenue Metrics","text":"<pre><code># Calculate MRR\nmrr = kpi.monthly_recurring_revenue(\n    paying_customers=1000,\n    avg_revenue_per_customer=50\n)\n\n# Calculate ARR\narr = kpi.annual_recurring_revenue(\n    paying_customers=1000,\n    avg_revenue_per_customer=50\n)\n</code></pre>"},{"location":"user-guide/kpi/#cost-metrics","title":"Cost Metrics","text":"<pre><code># Calculate CAC\ncac = kpi.customer_acquisition_cost(\n    marketing_costs=50000,\n    sales_costs=30000,\n    new_customers=100\n)\n\n# Calculate ROI\nroi = kpi.roi(\n    revenue=150000,\n    costs=100000\n)\n</code></pre>"},{"location":"user-guide/kpi/#engagement-metrics","title":"Engagement Metrics","text":""},{"location":"user-guide/kpi/#net-promoter-score","title":"Net Promoter Score","text":"<pre><code>nps = kpi.net_promoter_score(\n    promoters=70,        # Customers rating 9-10\n    detractors=10,       # Customers rating 0-6\n    total_respondents=100\n)\n</code></pre>"},{"location":"user-guide/kpi/#customer-satisfaction","title":"Customer Satisfaction","text":"<pre><code># Calculate CSAT\ncsat = kpi.customer_satisfaction_score(\n    satisfaction_ratings=[4, 5, 3, 5, 4],\n    max_rating=5\n)\n\n# Calculate Customer Effort Score\nces = kpi.customer_effort_score(\n    effort_ratings=[2, 3, 1, 2, 4],\n    max_rating=7\n)\n</code></pre>"},{"location":"user-guide/kpi/#health-assessment","title":"Health Assessment","text":"<p>The <code>health</code> property provides a comprehensive assessment of business health based on all tracked metrics:</p> <pre><code>health = kpi.health\n\n# Health assessment structure\n{\n    'overall_score': 85.5,\n    'status': 'Good',\n    'components': {\n        'churn_rate': {\n            'score': 90.0,\n            'status': 'Excellent'\n        },\n        'retention_rate': {\n            'score': 85.0,\n            'status': 'Good'\n        },\n        # ... other metrics\n    }\n}\n</code></pre>"},{"location":"user-guide/kpi/#health-score-components","title":"Health Score Components","text":"<p>The health score is calculated based on weighted components:</p> <ul> <li>Customer Health (30%)</li> <li>Churn Rate</li> <li>Retention Rate</li> <li> <p>LTV/CAC Ratio</p> </li> <li> <p>Financial Health (30%)</p> </li> <li>Gross Margin</li> <li>ROI</li> <li> <p>Revenue Growth</p> </li> <li> <p>Engagement Health (40%)</p> </li> <li>NPS</li> <li>CSAT</li> <li>Feature Adoption</li> </ul> <p>Each component is scored from 0-100 and assigned a status: - Excellent: \u2265 90 - Good: \u2265 75 - Fair: \u2265 60 - Poor: \u2265 45 - Critical: &lt; 45</p>"},{"location":"user-guide/kpi/#state-management","title":"State Management","text":"<p>The KPI class maintains state for all calculated metrics in the <code>_state</code> dictionary. This allows for: - Trend analysis - Health assessment - Historical comparison - Metric correlation</p> <pre><code># Access stored metrics\nstored_churn = kpi._state['churn_rate']\nstored_retention = kpi._state['retention_rate']\n</code></pre>"},{"location":"user-guide/kpi/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/kpi/#1-data-collection-and-management","title":"1. Data Collection and Management","text":"<ul> <li>1.1. Initialize Early: Create the KPI instance at the start of your analysis</li> <li>1.2. Regular Updates: Update metrics consistently for accurate trending</li> <li>1.3. Store History: Consider saving state for long-term analysis</li> </ul>"},{"location":"user-guide/kpi/#2-analysis-and-monitoring","title":"2. Analysis and Monitoring","text":"<ul> <li>2.1. Monitor Health: Regularly check the health assessment</li> <li>2.2. Validate Inputs: Ensure input data quality for accurate metrics</li> <li>2.3. Compare Trends: Analyze metric changes over time rather than isolated values</li> </ul>"},{"location":"user-guide/kpi/#3-reporting-and-decision-making","title":"3. Reporting and Decision Making","text":"<ul> <li>3.1. Focus on Key Metrics: Prioritize metrics most relevant to your business model</li> <li>3.2. Set Thresholds: Establish alert thresholds for critical metrics</li> <li>3.3. Contextualize Results: Consider market conditions when interpreting metrics ``` </li> </ul>"},{"location":"user-guide/moving-averages/","title":"Moving Averages","text":"<p>Pypulate provides a comprehensive set of moving average functions for financial time series analysis. This  page explains the different types of moving averages available and how to use them.</p>"},{"location":"user-guide/moving-averages/#available-moving-averages","title":"Available Moving Averages","text":""},{"location":"user-guide/moving-averages/#specialized-moving-averages","title":"Specialized Moving Averages","text":"<p>These moving averages are designed for specific use cases:</p> <ul> <li>Volume-Weighted Moving Average (VWMA): Weights price by volume.</li> <li>Kaufman Adaptive Moving Average (KAMA): Adapts to market volatility.</li> <li>Arnaud Legoux Moving Average (ALMA): Reduces lag and noise.</li> <li>Fractal Adaptive Moving Average (FRAMA): Adapts to market fractal dimension.</li> <li>Jurik Moving Average (JMA): Reduces noise and lag.</li> <li>Laguerre Filter: Uses Laguerre polynomials for smoothing.</li> <li>Least Squares Moving Average (LSMA): Uses linear regression.</li> <li>McGinley Dynamic Indicator: Adapts to market speed.</li> <li>Modular Filter: Adjusts smoothing based on phase.</li> <li>Rex Dog Moving Average (RDMA): Average of six SMAs with different periods.</li> <li>Tillson T3: Triple EMA with reduced lag.</li> <li>Volatility-Adjusted Moving Average (VAMA): Adjusts based on volatility.</li> </ul>"},{"location":"user-guide/moving-averages/#using-moving-averages","title":"Using Moving Averages","text":""},{"location":"user-guide/moving-averages/#functional-approach","title":"Functional Approach","text":"<p>You can use moving averages directly by importing the functions:</p> <pre><code>import numpy as np\nfrom pypulate.moving_averages import sma, ema, hma\n\n# Create sample data\ndata = [10, 11, 12, 11, 10, 9, 10, 11, 12, 13]\n\n# Calculate moving averages\nsma_result = sma(data, period=3)\nema_result = ema(data, period=3)\nhma_result = hma(data, period=3)\n</code></pre>"},{"location":"user-guide/moving-averages/#method-chaining-with-parray","title":"Method Chaining with Parray","text":"<p>For a more fluent interface, you can use the <code>Parray</code> class:</p> <pre><code>from pypulate import Parray\n\n# Create sample data\ndata = Parray([10, 11, 12, 11, 10, 9, 10, 11, 12, 13])\n\n# Calculate moving averages using method chaining\nsma_result = Parray.sma(period=3)\nema_result = Parray.ema(period=3)\nhma_result = Parray.hma(period=3)\n</code></pre>"},{"location":"user-guide/moving-averages/#examples","title":"Examples","text":""},{"location":"user-guide/moving-averages/#comparing-different-moving-averages","title":"Comparing Different Moving Averages","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom pypulate import Parray\n\n# Generate sample price data\nnp.random.seed(42)\ndays = 100\nprice = np.cumsum(np.random.normal(0, 1, days)) + 100\n\n# Convert to Parray for method chaining\nprice_array = Parray(price)\n\n# Calculate different types of moving averages\nsma = price_array.sma(20)\nema = price_array.ema(20)\nwma = price_array.wma(20)\nhma = price_array.hma(20)\n\n# Plot the results\nplt.figure(figsize=(12, 6))\nplt.plot(price, label='Price', alpha=0.5, color='gray')\nplt.plot(sma, label='SMA(20)')\nplt.plot(ema, label='EMA(20)')\nplt.plot(wma, label='WMA(20)')\nplt.plot(hma, label='HMA(20)')\n\nplt.title('Comparison of Different Moving Averages')\nplt.xlabel('Days')\nplt.ylabel('Price')\nplt.legend()\nplt.grid(True, alpha=0.3)\nplt.show()\n</code></pre>"},{"location":"user-guide/moving-averages/#moving-average-crossover-strategy","title":"Moving Average Crossover Strategy","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom pypulate import Parray\n\n# Generate sample price data\nnp.random.seed(42)\ndays = 200\nprice = np.cumsum(np.random.normal(0, 1, days)) + 100\n\n# Convert to Parray for method chaining\nprice_array = Parray(price)\n\n# Calculate fast and slow EMAs\nfast_ema = price_array.ema(9)\nslow_ema = price_array.ema(21)\n\n# Generate buy/sell signals\nbuy_signals = fast_ema.crossover(slow_ema)\nsell_signals = fast_ema.crossunder(slow_ema)\n\n# Plot the results\nplt.figure(figsize=(12, 6))\nplt.plot(price, label='Price')\nplt.plot(fast_ema, label='9-day EMA', alpha=0.7)\nplt.plot(slow_ema, label='21-day EMA', alpha=0.7)\n\n# Plot buy signals\nbuy_indices = np.where(buy_signals)[0]\nplt.scatter(buy_indices, price[buy_indices], marker='^', color='green', s=100, label='Buy Signal')\n\n# Plot sell signals\nsell_indices = np.where(sell_signals)[0]\nplt.scatter(sell_indices, price[sell_indices], marker='v', color='red', s=100, label='Sell Signal')\n\nplt.title('Moving Average Crossover Strategy')\nplt.xlabel('Days')\nplt.ylabel('Price')\nplt.legend()\nplt.grid(True, alpha=0.3)\nplt.show()\n</code></pre>"},{"location":"user-guide/moving-averages/#choosing-the-right-moving-average","title":"Choosing the Right Moving Average","text":"<p>Different moving averages are suitable for different market conditions:</p> <ul> <li>Trending Markets: SMA, EMA, WMA, HMA</li> <li>Volatile Markets: KAMA, ALMA, FRAMA, JMA</li> <li>Ranging Markets: DEMA, TEMA, T3</li> </ul> <p>Experiment with different types to find the one that works best for your specific use case. </p>"},{"location":"user-guide/parray/","title":"Using the Parray Class","text":"<p>The <code>Parray</code> class is a powerful tool for financial time series analysis in Pypulate. It extends NumPy arrays with financial analysis methods that can be chained together for complex calculations.</p>"},{"location":"user-guide/parray/#introduction","title":"Introduction","text":"<p><code>Parray</code> is designed to make financial time series analysis more intuitive and concise. It inherits from <code>numpy.ndarray</code>, so it has all the functionality of NumPy arrays, plus additional methods for financial analysis.</p>"},{"location":"user-guide/parray/#getting-started","title":"Getting Started","text":""},{"location":"user-guide/parray/#creating-a-parray","title":"Creating a Parray","text":"<p>You can create a <code>Parray</code> object from any array-like object using the <code>Parray</code> class:</p> <pre><code>from pypulate.dtypes import Parray\n\n# From a list\ndata = [1, 2, 3, 4, 5]\np = Parray(data)\n\n# From a NumPy array\ndata = np.array([1, 2, 3, 4, 5])\np = Parray(data)\n</code></pre>"},{"location":"user-guide/parray/#moving-averages","title":"Moving Averages","text":"<p><code>Parray</code> provides methods for calculating various moving averages:</p> <pre><code>from pypulate import Parray\n\ndata = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\np = Parray(data)\n\n# Simple Moving Average\nsma = p.sma(3)  # 3-period SMA\n\n# Exponential Moving Average\nema = p.ema(3)  # 3-period EMA\n\n# Weighted Moving Average\nwma = p.wma(3)  # 3-period WMA\n\n# Hull Moving Average\nhma = p.hma(3)  # 3-period HMA\n</code></pre>"},{"location":"user-guide/parray/#crossover-and-crossunder-detection","title":"Crossover and Crossunder Detection","text":"<p>One of the most useful features of <code>Parray</code> is the ability to detect crossovers and crossunders, which are common signals in technical analysis:</p> <pre><code>from pypulate.dtypes import Parray\n\n# Create sample price data\ndata = Parray([10, 11, 12, 11, 10, 11, 12, 13])\n\n# Find where prices cross above 11\ncrossover_points = data.crossover(11)\n\n# Find where prices cross below 11\ncrossunder_points = data.crossunder(11)\n\n# Find where prices cross above a moving average\nma = data.sma(3)\ncrossover_ma = data.crossover(ma)\n</code></pre>"},{"location":"user-guide/parray/#advanced-technical-analysis","title":"Advanced Technical Analysis","text":""},{"location":"user-guide/parray/#oscillators-and-momentum","title":"Oscillators and Momentum","text":"<pre><code>from pypulate import Parray\n\n# Sample price data\nprices = Parray([\n    100, 102, 104, 103, 105, 107, 106, 108, 110, 109,\n    111, 113, 112, 115, 114, 116, 118, 117, 119, 120\n])\n\n# RSI (Relative Strength Index)\nrsi = prices.rsi(14)  # 14-period RSI\n\n\n# MACD (Moving Average Convergence Divergence)\nmacd_line, signal_line, histogram = prices.macd(6, 12, 6)\n\n# Rate of Change (ROC)\nroc = prices.roc(12)  # 12-period rate of change\n\n# Momentum\nmomentum = prices.momentum(10)  # 10-period momentum\n</code></pre>"},{"location":"user-guide/parray/#volatility-indicators","title":"Volatility Indicators","text":"<pre><code># Sample OHLC data\nhigh = Parray([\n    102, 104, 105, 104, 107, 108, 107, 109, 111, 110,\n    112, 114, 113, 116, 115, 117, 119, 118, 120, 121\n])\nlow = Parray([\n    99, 101, 103, 102, 104, 106, 105, 107, 109, 108,\n    110, 112, 111, 114, 113, 115, 117, 116, 118, 119\n])\nclose = Parray([\n    100, 102, 104, 103, 105, 107, 106, 108, 110, 109,\n    111, 113, 112, 115, 114, 116, 118, 117, 119, 120\n])\n\n# Bollinger Bands (uses close prices)\nupper_band, middle_band, lower_band = close.bollinger_bands(12, 2)  # 12-period, 2 standard deviations\n\n# Average True Range (ATR) - requires high, low, close prices\natr = Parray.atr(high, low, close, 14)  # 14-period ATR\n\n# Keltner Channels (uses high, low, close for ATR calculation)\nk_upper, k_middle, k_lower = Parray.keltner_channels(close, high, low, 12, 2)  # 12-period, 2 ATR multiplier\n\n# Standard Deviation\nstd = close.rolling_std(12)  # 12-period rolling standard deviation\n\n# CCI with typical price\ncci = close.typical_price(high, low).cci(9)\n</code></pre>"},{"location":"user-guide/parray/#trade-strategy","title":"Trade Strategy","text":"<pre><code># Calculate indicators\nadx = close.adx(14)  # 14-period ADX\nma_10 = close.sma(10)  # 10-period SMA\n\n# Generate long position signals\n# Long when: price &gt; MA(10) AND ADX &lt; 30 (weak trend, good for entry)\nlong_signals = (close &gt; ma_10) &amp; (adx &lt; 30)\n\n# Get indices where long_signals is True\nprint(\"Long Entry Points:\", np.where(long_signals)[0])\n</code></pre>"},{"location":"user-guide/parray/#custom-indicators","title":"Custom Indicators","text":"<pre><code># Create custom indicators using method chaining\ncustom_ma = (\n    prices.sma(10) * 0.5 +      # 50% weight to SMA\n    prices.ema(10) * 0.3 +      # 30% weight to EMA\n    prices.wma(10) * 0.2        # 20% weight to WMA\n)\n\n# Custom momentum indicator\ncustom_momentum = (\n    prices.roc(10) * 0.4 +      # 40% weight to ROC\n    prices.rsi(14) * 0.3 +      # 30% weight to RSI\n    prices.momentum(10) * 0.3   # 30% weight to Momentum\n)\n</code></pre>"},{"location":"user-guide/parray/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/parray/#1-signal-generation","title":"1. Signal Generation","text":"<ul> <li>1.1. Multiple Indicators: Combine multiple indicators for confirmation</li> <li>1.2. Risk Management: Use proper risk management with every signal</li> <li>1.3. Time Frame Alignment: Consider time frame alignment across indicators</li> <li>1.4. Noise Filtering: Filter out noise with minimum threshold values</li> </ul>"},{"location":"user-guide/parray/#2-performance-optimization","title":"2. Performance Optimization","text":"<ul> <li>2.1. Memory Management: Be mindful that method chaining creates intermediate arrays</li> <li>2.2. Large Datasets: For extremely large datasets, consider using underlying functions directly</li> <li>2.3. Vectorization: Leverage NumPy's vectorized operations for better performance</li> </ul>"},{"location":"user-guide/parray/#3-analysis-techniques","title":"3. Analysis Techniques","text":"<ul> <li>3.1. Custom Indicators: Create custom indicators by combining existing ones</li> <li>3.2. Backtesting: Test strategies on historical data before applying</li> <li>3.3. Parameter Optimization: Test different parameters to find optimal settings</li> </ul>"},{"location":"user-guide/parray/#performance-considerations","title":"Performance Considerations","text":"<p>Since <code>Parray</code> is a subclass of <code>numpy.ndarray</code>, it inherits all of NumPy's performance characteristics. However, there are a few things to keep in mind:</p> <ol> <li>Method chaining creates intermediate arrays, which can increase memory usage for very large datasets.</li> <li>For extremely performance-critical applications, you may want to use the underlying functions directly.</li> </ol> <p>For most use cases, the convenience of method chaining outweighs any minor performance impact. </p>"},{"location":"user-guide/portfolio/","title":"Portfolio Guide","text":"<p>The <code>Portfolio</code> class provides a comprehensive suite of methods for portfolio analysis, risk management, and performance attribution.</p>"},{"location":"user-guide/portfolio/#basic-usage","title":"Basic Usage","text":"<pre><code>from pypulate import Portfolio\n\n# Initialize portfolio analyzer\nportfolio = Portfolio()\n\n# Calculate basic returns\nsimple_ret = portfolio.simple_return(10, 12)\nlog_ret = portfolio.log_return(10, 12)\n</code></pre>"},{"location":"user-guide/portfolio/#return-metrics","title":"Return Metrics","text":""},{"location":"user-guide/portfolio/#simple-returns","title":"Simple Returns","text":"<pre><code># Calculate simple returns\nreturns = portfolio.simple_return([10, 20, 25], [12, 21, 20])\n\n# Calculate holding period return\nhpr = portfolio.holding_period_return(\n    [10, 20, 25]\n)\n\n# Calculate annualized return\nannual_ret = portfolio.annualized_return(\n    [10, 20, 25],\n    years=2\n)\n</code></pre>"},{"location":"user-guide/portfolio/#time-weighted-returns","title":"Time-Weighted Returns","text":"<pre><code># Calculate time-weighted return\ntwrr = portfolio.time_weighted_return(\n    [0.01, 0.03, 0.02, 0.02, 0.001],\n)\n</code></pre>"},{"location":"user-guide/portfolio/#money-weighted-returns","title":"Money-Weighted Returns","text":"<pre><code># Calculate money-weighted return (IRR)\nmwrr = portfolio.money_weighted_return([-1000, -500, 1700], [0, 0.5, 1], 0)\n</code></pre>"},{"location":"user-guide/portfolio/#risk-metrics","title":"Risk Metrics","text":""},{"location":"user-guide/portfolio/#volatility-measures","title":"Volatility Measures","text":"<pre><code># Calculate standard deviation\nstd_dev = portfolio.standard_deviation([0.01, 0.03, 0.02, 0.02, 0.001])\n</code></pre>"},{"location":"user-guide/portfolio/#value-at-risk","title":"Value at Risk","text":"<pre><code># Calculate parametric VaR\nvar = portfolio.value_at_risk(\n    [0.01, 0.03, 0.02, 0.02, 0.001],\n    confidence_level=0.95,\n    method = 'monte_carlo'\n)\n\n# Calculate conditional VaR (Expected Shortfall)\ncvar = portfolio.conditional_value_at_risk(\n    returns,\n    confidence_level=0.95\n)\n</code></pre>"},{"location":"user-guide/portfolio/#drawdown-analysis","title":"Drawdown Analysis","text":"<pre><code># Calculate maximum drawdown\nmax_dd = portfolio.max_drawdown(prices)\n\n# Get drawdown details\ndd_amount, dd_percent, dd_length = portfolio.drawdown_details(prices)\n</code></pre>"},{"location":"user-guide/portfolio/#risk-adjusted-performance","title":"Risk-Adjusted Performance","text":""},{"location":"user-guide/portfolio/#sharpe-ratio","title":"Sharpe Ratio","text":"<pre><code># Calculate Sharpe ratio\nsharpe = portfolio.sharpe_ratio(\n    returns,\n    risk_free_rate=0.02,\n    periods_per_year=252\n)\n</code></pre>"},{"location":"user-guide/portfolio/#information-ratio","title":"Information Ratio","text":"<pre><code># Calculate Information ratio\ninfo_ratio = portfolio.information_ratio(\n    returns,\n    benchmark_returns,\n    periods_per_year=252\n)\n</code></pre>"},{"location":"user-guide/portfolio/#capm-metrics","title":"CAPM Metrics","text":"<pre><code># Calculate beta\nbeta = portfolio.beta(returns, market_returns)\n\n# Calculate alpha\nalpha = portfolio.alpha(\n    returns,\n    market_returns,\n    risk_free_rate=0.02\n)\n</code></pre>"},{"location":"user-guide/portfolio/#health-assessment","title":"Health Assessment","text":"<p>The <code>health</code> property provides a comprehensive assessment of portfolio health:</p> <pre><code>health = portfolio.health\n\n# Health assessment structure\n{\n    'overall_score': 82.5,\n    'status': 'Good',\n    'components': {\n        'returns': {\n            'score': 85.0,\n            'status': 'Good'\n        },\n        'risk': {\n            'score': 78.0,\n            'status': 'Good'\n        },\n        'risk_adjusted': {\n            'score': 88.0,\n            'status': 'Good'\n        }\n    }\n}\n</code></pre>"},{"location":"user-guide/portfolio/#health-score-components","title":"Health Score Components","text":"<p>The portfolio health score is calculated based on three main components:</p> <ul> <li>Returns (30%)</li> <li>Absolute Returns</li> <li>Relative Returns</li> <li> <p>Consistency of Returns</p> </li> <li> <p>Risk Metrics (40%)</p> </li> <li>Volatility</li> <li>Value at Risk</li> <li>Maximum Drawdown</li> <li> <p>Recovery Time</p> </li> <li> <p>Risk-Adjusted Performance (30%)</p> </li> <li>Sharpe Ratio</li> <li>Information Ratio</li> <li>Sortino Ratio</li> <li>Treynor Ratio</li> </ul> <p>Each component is scored from 0-100 and assigned a status: - Excellent: \u2265 90 - Good: \u2265 75 - Fair: \u2265 60 - Poor: \u2265 45 - Critical: &lt; 45</p>"},{"location":"user-guide/portfolio/#state-management","title":"State Management","text":"<p>The Portfolio class maintains state for calculated metrics in the <code>_state</code> dictionary:</p> <pre><code># Access stored metrics\nstored_returns = portfolio._state['returns']\nstored_volatility = portfolio._state['volatility']\nstored_sharpe = portfolio._state['sharpe_ratio']\n</code></pre>"},{"location":"user-guide/portfolio/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/portfolio/#1-data-management","title":"1. Data Management","text":"<ul> <li>1.1. Data Quality: Ensure price and return data is clean and properly formatted</li> <li>1.2. Time Consistency: Use consistent time periods for comparative analysis</li> <li>1.3. Adjustments: Account for dividends, splits, and corporate actions</li> </ul>"},{"location":"user-guide/portfolio/#2-risk-assessment","title":"2. Risk Assessment","text":"<ul> <li>2.1. Regular Monitoring: Regularly monitor risk metrics</li> <li>2.2. Multiple Metrics: Use multiple risk measures for comprehensive assessment</li> <li>2.3. Stress Testing: Conduct stress tests under various market scenarios</li> </ul>"},{"location":"user-guide/portfolio/#3-performance-analysis","title":"3. Performance Analysis","text":"<ul> <li>3.1. Benchmark Selection: Choose appropriate benchmarks for relative analysis</li> <li>3.2. Attribution: Analyze sources of returns and risk</li> <li>3.3. Health Monitoring: Regularly assess portfolio health</li> </ul>"},{"location":"user-guide/portfolio/#4-reporting-and-communication","title":"4. Reporting and Communication","text":"<ul> <li>4.1. Clear Visualization: Present portfolio metrics with clear visualizations</li> <li>4.2. Context Provision: Provide context for performance numbers</li> <li>4.3. Consistent Reporting: Maintain consistent reporting formats </li> </ul>"},{"location":"user-guide/service-pricing/","title":"Service Pricing","text":"<p>The <code>ServicePricing</code> class provides a unified interface for calculating various types of service pricing models. It supports tiered pricing, subscription-based pricing, usage-based pricing, dynamic pricing adjustments, volume discounts, and custom pricing rules.</p>"},{"location":"user-guide/service-pricing/#quick-start","title":"Quick Start","text":"<pre><code>from pypulate import ServicePricing\n\n# Initialize pricing calculator\npricing = ServicePricing()\n\n# Calculate tiered pricing\nprice = pricing.calculate_tiered_price(\n    usage_units=1500,\n    tiers={\n        \"0-1000\": 0.10,\n        \"1001-2000\": 0.08,\n        \"2001+\": 0.05\n    }\n)\nprint(f\"Total price: ${price:.2f}\")  # Output: Total price: $140.02\n</code></pre>"},{"location":"user-guide/service-pricing/#features","title":"Features","text":""},{"location":"user-guide/service-pricing/#tiered-pricing","title":"Tiered Pricing","text":"<p>Calculate prices based on usage tiers:</p> <pre><code>tiers = {\n    \"0-1000\": 0.10,    # $0.10 per unit for first 1000 units = $100\n    \"1001-2000\": 0.08, # $0.08 per unit for next 500 units = $40\n    \"2001+\": 0.05      # $0.05 per unit for 2001+ units\n}\n\n# Cumulative pricing (default)\nprice = pricing.calculate_tiered_price(1500, tiers)\n# Result: $140.02\n\n# Non-cumulative pricing\nprice = pricing.calculate_tiered_price(1500, tiers, cumulative=False)\n# Result: $120.00\n</code></pre>"},{"location":"user-guide/service-pricing/#subscription-pricing","title":"Subscription Pricing","text":"<p>Calculate subscription prices with features and discounts:</p> <pre><code>price = pricing.calculate_subscription_price(\n    base_price=99.99,\n    features=['premium', 'api_access'],\n    feature_prices={'premium': 49.99, 'api_access': 29.99},\n    duration_months=12,\n    discount_rate=0.10\n)\n</code></pre>"},{"location":"user-guide/service-pricing/#usage-based-pricing","title":"Usage-Based Pricing","text":"<p>Calculate prices based on multiple usage metrics:</p> <pre><code>usage_metrics = {'api_calls': 1000, 'storage_gb': 50}\nmetric_rates = {'api_calls': 0.001, 'storage_gb': 0.10}\nprice = pricing.calculate_usage_price(\n    usage_metrics,\n    metric_rates,\n    minimum_charge=10.0,\n    maximum_charge=1000.0\n)\n</code></pre>"},{"location":"user-guide/service-pricing/#volume-discounts","title":"Volume Discounts","text":"<p>Apply volume-based discounts:</p> <pre><code>discount_tiers = {\n    100: 0.05,   # 5% discount for 100+ units\n    500: 0.10,   # 10% discount for 500+ units\n    1000: 0.15   # 15% discount for 1000+ units\n}\nprice = pricing.calculate_volume_discount(\n    base_price=10.0,\n    volume=750,\n    discount_tiers=discount_tiers\n)\n</code></pre>"},{"location":"user-guide/service-pricing/#time-based-pricing","title":"Time-Based Pricing","text":"<p>Calculate prices based on time duration with different units and rounding options:</p> <pre><code>price = pricing.calculate_time_based_price(\n    base_price=25.0,      # $25 per hour\n    duration=2.5,         # 2.5 hours\n    time_unit='hour',     # pricing unit (minute, hour, day)\n    minimum_duration=1.0, # minimum billable duration\n    rounding_method='up'  # round up to nearest unit\n)\n# Result: $63.00 (25.0 * 2.5 = 62.5, rounded up to 63)\n\n# Using minutes as the time unit\nprice = pricing.calculate_time_based_price(\n    base_price=0.50,      # $0.50 per minute\n    duration=45,          # 45 minutes\n    time_unit='minute'\n)\n# Result: $23.00 (0.50 * 45 = 22.5, rounded up to 23)\n</code></pre>"},{"location":"user-guide/service-pricing/#freemium-pricing","title":"Freemium Pricing","text":"<p>Calculate prices for freemium models with base features (free up to limits) and premium features:</p> <pre><code>price = pricing.calculate_freemium_price(\n    base_features=['storage', 'api_calls', 'users'],\n    premium_features=['advanced_analytics', 'priority_support'],\n    feature_usage={\n        'storage': 150,           # GB\n        'api_calls': 12000,\n        'users': 25,\n        'advanced_analytics': 100,\n        'priority_support': 1\n    },\n    free_limits={\n        'storage': 100,           # 100 GB free\n        'api_calls': 10000,       # 10,000 calls free\n        'users': 20               # 20 users free\n    },\n    overage_rates={\n        'storage': 0.1,           # $0.1 per GB over limit\n        'api_calls': 0.001,       # $0.001 per call over limit\n        'users': 2.0,             # $2 per user over limit\n        'advanced_analytics': 0.05, # $0.05 per usage unit\n        'priority_support': 50.0   # $50 flat fee (usage=1)\n    }\n)\n</code></pre>"},{"location":"user-guide/service-pricing/#bundle-pricing","title":"Bundle Pricing","text":"<p>Calculate prices for bundled items with combination-specific discounts:</p> <pre><code>price = pricing.calculate_bundle_price(\n    items=['laptop', 'mouse', 'keyboard', 'monitor'],\n    item_prices={\n        'laptop': 1200.0,\n        'mouse': 25.0,\n        'keyboard': 50.0,\n        'monitor': 200.0\n    },\n    bundle_discounts={\n        'laptop+mouse': 0.05,                # 5% off laptop+mouse\n        'keyboard+mouse': 0.10,              # 10% off keyboard+mouse\n        'laptop+keyboard+mouse': 0.15,       # 15% off laptop+keyboard+mouse\n        'laptop+monitor+keyboard+mouse': 0.20 # 20% off complete setup\n    },\n    minimum_bundle_size=2  # minimum items for discount eligibility\n)\n# Result: $1180.00 (20% discount on the complete bundle)\n</code></pre>"},{"location":"user-guide/service-pricing/#peak-pricing","title":"Peak Pricing","text":"<p>Apply different rates based on peak and off-peak hours:</p> <pre><code>price = pricing.calculate_peak_pricing(\n    base_price=50.0,      # base price per unit\n    usage_time=\"14:30\",   # time of usage (2:30 PM)\n    peak_hours={\n        \"monday\": (\"09:00\", \"17:00\"),\n        \"tuesday\": (\"09:00\", \"17:00\"),\n        \"wednesday\": (\"09:00\", \"17:00\"),\n        \"thursday\": (\"09:00\", \"17:00\"),\n        \"friday\": (\"09:00\", \"17:00\"),\n        \"saturday\": (\"10:00\", \"15:00\"),\n        \"sunday\": (\"10:00\", \"15:00\")\n    },\n    peak_multiplier=1.5,      # 50% premium during peak hours\n    off_peak_multiplier=0.8   # 20% discount during off-peak hours\n)\n# Result: $75.00 during peak hours (1.5 * $50)\n# Result: $40.00 during off-peak hours (0.8 * $50)\n</code></pre>"},{"location":"user-guide/service-pricing/#loyalty-pricing","title":"Loyalty Pricing","text":"<p>Calculate prices with loyalty discounts based on customer tenure:</p> <pre><code>result = pricing.calculate_loyalty_price(\n    base_price=100.0,\n    customer_tenure=24,    # months\n    loyalty_tiers={\n        12: 0.05,          # 5% discount after 1 year\n        24: 0.10,          # 10% discount after 2 years\n        36: 0.15           # 15% discount after 3 years\n    },\n    additional_benefits={\n        'free_shipping': 10.0,\n        'priority_support': 15.0\n    }\n)\n# Result is a dictionary with details:\n# {\n#   'loyalty_price': 90.0,           # $100 - 10% discount\n#   'loyalty_tier': 24,              # 2-year tier\n#   'loyalty_discount': 10.0,        # $10 discount\n#   'additional_benefits': {'free_shipping': 10.0, 'priority_support': 15.0}\n# }\n\nprint(f\"Loyalty Price: ${result['loyalty_price']}\")\n</code></pre>"},{"location":"user-guide/service-pricing/#dynamic-pricing","title":"Dynamic Pricing","text":"<p>Adjust prices based on market factors:</p> <pre><code>price = pricing.apply_dynamic_pricing(\n    base_price=100.0,\n    demand_factor=1.2,      # High demand\n    competition_factor=0.9,  # Strong competition\n    seasonality_factor=1.1,  # Peak season\n    min_price=80.0,\n    max_price=150.0\n)\n</code></pre>"},{"location":"user-guide/service-pricing/#custom-pricing-rules","title":"Custom Pricing Rules","text":"<p>Create and apply custom pricing rules:</p> <pre><code># Add a custom holiday pricing rule\npricing.add_custom_pricing_rule(\n    'holiday',\n    lambda price, multiplier: price * multiplier,\n    description=\"Applies holiday season multiplier\"\n)\n\n# Apply the custom rule\nholiday_price = pricing.apply_custom_pricing_rule('holiday', 100.0, 1.2)\n# Result: $120.00\n</code></pre>"},{"location":"user-guide/service-pricing/#price-history-tracking","title":"Price History Tracking","text":"<p>The <code>ServicePricing</code> class automatically tracks pricing calculations:</p> <pre><code># Save current pricing state to history\npricing.save_current_pricing()\n\n# Get pricing history\nhistory = pricing.get_pricing_history()\n</code></pre> <p>Each history entry contains: - Timestamp of the calculation - Pricing details for each calculation type (tiered, subscription, usage, etc.)</p>"},{"location":"user-guide/service-pricing/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/service-pricing/#1-tiered-pricing","title":"1. Tiered Pricing","text":"<ul> <li>1.1. Use cumulative pricing for fair billing across tiers</li> <li>1.2. Ensure tier ranges are continuous without gaps</li> <li>1.3. Use \"+\" suffix for unlimited upper tiers</li> </ul>"},{"location":"user-guide/service-pricing/#2-subscription-pricing","title":"2. Subscription Pricing","text":"<ul> <li>2.1. Set reasonable discount rates for longer subscriptions</li> <li>2.2. Keep feature prices proportional to their value</li> <li>2.3. Consider minimum subscription durations</li> </ul>"},{"location":"user-guide/service-pricing/#3-usage-pricing","title":"3. Usage Pricing","text":"<ul> <li>3.1. Set appropriate minimum charges to cover fixed costs</li> <li>3.2. Use maximum charges to make costs predictable</li> <li>3.3. Choose meaningful usage metrics</li> </ul>"},{"location":"user-guide/service-pricing/#4-time-based-pricing","title":"4. Time-Based Pricing","text":"<ul> <li>4.1. Choose appropriate time units for your service (minute, hour, day)</li> <li>4.2. Set minimum durations to avoid micro-billing</li> <li>4.3. Consider different rounding methods based on industry standards</li> </ul>"},{"location":"user-guide/service-pricing/#5-freemium-pricing","title":"5. Freemium Pricing","text":"<ul> <li>5.1. Clearly separate base (free) and premium features</li> <li>5.2. Set reasonable free limits that provide value but encourage upgrades</li> <li>5.3. Price premium features based on their value proposition</li> </ul>"},{"location":"user-guide/service-pricing/#6-bundle-pricing","title":"6. Bundle Pricing","text":"<ul> <li>6.1. Create meaningful bundles that complement each other</li> <li>6.2. Increase discount rates for larger bundles</li> <li>6.3. Set minimum bundle sizes to prevent abuse</li> </ul>"},{"location":"user-guide/service-pricing/#7-peak-pricing","title":"7. Peak Pricing","text":"<ul> <li>7.1. Define peak hours based on actual usage patterns</li> <li>7.2. Set reasonable multipliers that reflect demand without alienating customers</li> <li>7.3. Consider different peak hours for different days of the week</li> </ul>"},{"location":"user-guide/service-pricing/#8-loyalty-pricing","title":"8. Loyalty Pricing","text":"<ul> <li>8.1. Create meaningful tenure tiers that reward long-term customers</li> <li>8.2. Include additional benefits beyond just discounts</li> <li>8.3. Ensure discounts scale appropriately with tenure</li> </ul>"},{"location":"user-guide/service-pricing/#9-dynamic-pricing","title":"9. Dynamic Pricing","text":"<ul> <li>9.1. Keep market factors between 0.5 and 2.0</li> <li>9.2. Set reasonable price floors and ceilings</li> <li>9.3. Update factors regularly based on market conditions</li> </ul>"},{"location":"user-guide/service-pricing/#10-custom-rules","title":"10. Custom Rules","text":"<ul> <li>10.1. Document rule logic clearly</li> <li>10.2. Validate inputs in custom calculation functions</li> <li>10.3. Consider rule interactions and precedence</li> </ul>"},{"location":"user-guide/service-pricing/#error-handling","title":"Error Handling","text":"<p>The class includes robust error handling:</p> <ul> <li>Invalid tier ranges raise ValueError</li> <li>Missing custom rules raise KeyError</li> <li>Invalid metric names raise KeyError</li> <li>Negative prices raise ValueError</li> </ul>"},{"location":"user-guide/service-pricing/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Pricing calculations are optimized for speed</li> <li>History tracking has minimal overhead</li> <li>Custom rules are cached for repeated use</li> <li>Large tier structures are handled efficiently </li> </ul>"},{"location":"user-guide/technical/","title":"Technical Analysis","text":"<p>The <code>pypulate.technical</code> module provides a comprehensive set of technical analysis tools for financial time series data. This guide demonstrates practical usage with real market data.</p>"},{"location":"user-guide/technical/#quick-start","title":"Quick Start","text":"<p>Let's start with some sample market data:</p> <pre><code>import numpy as np\nfrom pypulate import Parray\n\n# Sample market data\nnp.random.seed(42)\ndays = 200\nprice = np.cumsum(np.random.normal(0, 1, days)) + 100\n\n# Convert to Parray for analysis\nclose = Parray(price)\n</code></pre>"},{"location":"user-guide/technical/#momentum-indicators","title":"Momentum Indicators","text":""},{"location":"user-guide/technical/#relative-strength-index-rsi","title":"Relative Strength Index (RSI)","text":"<p>RSI measures momentum on a scale of 0 to 100, with readings above 70 indicating overbought conditions and below 30 indicating oversold conditions.</p> <pre><code># Calculate RSI with 14-period lookback\nrsi = close.rsi(14)\nprint(f\"Latest RSI: {rsi[-1]:.2f}\")\n</code></pre>"},{"location":"user-guide/technical/#moving-average-convergence-divergence-macd","title":"Moving Average Convergence Divergence (MACD)","text":"<p>MACD shows the relationship between two moving averages of a price series. Note that MACD calculation requires enough data points to compute both moving averages - the minimum required length is the slow period (typically 26 points).</p> <pre><code># Calculate MACD (12, 26, 9)\nmacd_line, signal_line, histogram = close.macd(12, 26, 9)\nprint(f\"MACD Line: {macd_line[-1]:.2f}\")\nprint(f\"Signal Line: {signal_line[-1]:.2f}\")\nprint(f\"Histogram: {histogram[-1]:.2f}\")\n</code></pre> <p>Note: The traditional MACD settings (12, 26, 9) require at least 26 data points. For shorter time series: - Consider using shorter periods - Ensure your data length is sufficient for the chosen periods - The minimum data length needed = slow_period (second parameter)</p>"},{"location":"user-guide/technical/#volatility-indicators","title":"Volatility Indicators","text":""},{"location":"user-guide/technical/#bollinger-bands","title":"Bollinger Bands","text":"<p>Bollinger Bands consist of a middle band (20-day SMA) with upper and lower bands 2 standard deviations away.</p> <pre><code># Calculate Bollinger Bands\nupper_bb, middle_bb, lower_bb = close.bollinger_bands(20, 2.0)\nprint(f\"Upper Band: {upper_bb[-1]:.2f}\")\nprint(f\"Middle Band: {middle_bb[-1]:.2f}\")\nprint(f\"Lower Band: {lower_bb[-1]:.2f}\")\n</code></pre>"},{"location":"user-guide/technical/#trend-indicators","title":"Trend Indicators","text":""},{"location":"user-guide/technical/#moving-averages","title":"Moving Averages","text":"<pre><code># Calculate different types of moving averages\nsma_20 = close.sma(20)  # Simple Moving Average\nema_20 = close.ema(20)  # Exponential Moving Average\nwma_20 = close.wma(20)  # Weighted Moving Average\n\nprint(f\"20-day SMA: {sma_20[-1]:.2f}\")\nprint(f\"20-day EMA: {ema_20[-1]:.2f}\")\nprint(f\"20-day WMA: {wma_20[-1]:.2f}\")\n</code></pre>"},{"location":"user-guide/technical/#building-trading-strategies","title":"Building Trading Strategies","text":"<p>Here's an example of combining multiple indicators for a trading strategy:</p> <pre><code># Calculate indicators\nrsi = close.rsi(14)\nmacd_line, signal, hist = close.macd(12, 26, 9)\nupper_bb, middle_bb, lower_bb = close.bollinger_bands(20, 2.0)\n\n# Generate trading signals\nbuy_signals = (\n    (rsi &lt; 30) &amp;                  # RSI oversold\n    (macd_line &gt; signal) &amp;        # MACD bullish\n    (close &lt; lower_bb)            # Price below lower Bollinger Band\n)\n\nsell_signals = (\n    (rsi &gt; 70) &amp;                  # RSI overbought\n    (macd_line &lt; signal) &amp;        # MACD bearish\n    (close &gt; upper_bb)            # Price above upper Bollinger Band\n)\n\n# Print latest signals\nprint(\"Latest Signals:\")\nprint(f\"Buy Signal: {buy_signals[-1]}\")\nprint(f\"Sell Signal: {sell_signals[-1]}\")\n</code></pre>"},{"location":"user-guide/technical/#advanced-analysis","title":"Advanced Analysis","text":""},{"location":"user-guide/technical/#logarithmic-returns","title":"Logarithmic Returns","text":"<p>Calculate and analyze logarithmic returns:</p> <pre><code># Calculate log returns\nlog_returns = close.log().diff()\nprint(f\"Latest Log Return: {log_returns[-1]:.4f}\")\n\n# Calculate RSI on log returns\nlog_rsi = close.log().rsi(14)\nprint(f\"RSI of Log Returns: {log_rsi[-1]:.2f}\")\n</code></pre>"},{"location":"user-guide/technical/#statistical-measures","title":"Statistical Measures","text":"<pre><code># Calculate rolling statistics\nvolatility = close.rolling_std(20)\nzscore = close.zscore(20)\n\nprint(f\"20-day Volatility: {volatility[-1]:.2f}\")\nprint(f\"20-day Z-Score: {zscore[-1]:.2f}\")\n</code></pre>"},{"location":"user-guide/technical/#utility-functions","title":"Utility Functions","text":"<p>The module provides various utility functions for common calculations:</p> <pre><code>from pypulate.technical.utils import rolling_max, rolling_min, slope\n\n# Calculate 20-day high and low\nhigh_20 = rolling_max(close, 20)\nlow_20 = rolling_min(close, 20)\n\n# Calculate price slope\nprice_slope = slope(close, 5)\n\nprint(f\"20-day High: {high_20[-1]:.2f}\")\nprint(f\"20-day Low: {low_20[-1]:.2f}\")\nprint(f\"5-day Slope: {price_slope[-1]:.4f}\")\n\n# Calculate top and high from slope of moving averages\ntop_low = close.sma(20).slope()\n</code></pre>"},{"location":"user-guide/transforms/","title":"Transforms","text":"<p>Pypulate provides transforms for identifying patterns especialy price action patterns in financial time series data. This page explains the available transforms and how to use them.</p>"},{"location":"user-guide/transforms/#overview","title":"Overview","text":"<p>Transforms in Pypulate are functions that convert price data into a different representation to identify patterns or significant points. Currently, Pypulate supports two main transforms:</p> <ol> <li>Wave Transform: Identifies wave patterns in price data</li> <li>ZigZag Transform: Identifies significant highs and lows</li> </ol>"},{"location":"user-guide/transforms/#wave-transform","title":"Wave Transform","text":"<p>The wave transform converts OHLC data into a line without losing highs and lows, inspired by Glenn Neely wave chart.</p>"},{"location":"user-guide/transforms/#parameters","title":"Parameters","text":"<ul> <li><code>open</code>: Open prices array</li> <li><code>high</code>: High prices array</li> <li><code>low</code>: Low prices array</li> <li><code>close</code>: Close prices array</li> </ul>"},{"location":"user-guide/transforms/#usage","title":"Usage","text":"<pre><code>from pypulate.transforms import wave\nfrom pypulate import Parray\n\n# Real gold (XAU) OHLC data sample\ndata = {\n    'open': [1936.13, 1935.33, 1938.06, 1947.38, 1943.64, 1942.30, 1947.15, 1945.40, 1944.72, 1943.69,\n             1940.41, 1939.15, 1942.55, 1939.68, 1944.19, 1943.61, 1941.12, 1939.94, 1942.98, 1944.50],\n    'high': [1937.48, 1938.79, 1948.68, 1949.05, 1944.51, 1947.70, 1947.71, 1946.24, 1947.87, 1945.06,\n             1942.03, 1944.03, 1942.61, 1944.45, 1952.94, 1943.61, 1941.34, 1944.02, 1946.06, 1946.32],\n    'low': [1935.16, 1934.91, 1936.62, 1943.12, 1942.04, 1941.94, 1944.43, 1943.19, 1940.27, 1939.03,\n            1939.34, 1938.66, 1938.17, 1938.40, 1940.06, 1934.44, 1939.48, 1939.35, 1942.94, 1940.76],\n    'close': [1935.33, 1938.09, 1947.36, 1943.64, 1942.35, 1947.14, 1945.40, 1944.72, 1943.70, 1940.43,\n              1940.04, 1942.55, 1939.70, 1944.20, 1943.68, 1941.12, 1940.10, 1942.96, 1944.50, 1940.95]\n}\n\nwaves = wave(data['open'], data['high'], data['low'], data['close'])\n</code></pre>"},{"location":"user-guide/transforms/#interpreting-results","title":"Interpreting Results","text":"<p>The wave transform returns a 1D array containing the wave points.</p>"},{"location":"user-guide/transforms/#example","title":"Example","text":"<pre><code>import matplotlib.pylab as plt\nimport numpy as np\n\n# Plot the results\nplt.figure(figsize=(12, 6))\n\nfor i in range(len(data['close'])):\n    plt.plot([i, i], [data['low'][i], data['high'][i]], 'k-', alpha=0.3)\n\n    if data['close'][i] &gt;= data['open'][i]:\n        body_color = 'green'\n    else:\n        body_color = 'red'\n\n    plt.plot([i, i], [data['open'][i], data['close'][i]], color=body_color, linewidth=4)\n\nif len(waves) &gt; 0: \n    indices = np.arange(len(waves))\n    plt.plot(indices, waves, 'b-o', linewidth=2, markersize=5, label='Wave Points')\n\nplt.title('Wave Pattern Detection with Gold (XAU) OHLC Data')\nplt.xlabel('Time Period')\nplt.ylabel('Price (USD)')\nplt.legend()\nplt.grid(True, alpha=0.3)\nplt.show()\n</code></pre>"},{"location":"user-guide/transforms/#zigzag-transform","title":"ZigZag Transform","text":"<p>The ZigZag transform identifies significant highs and lows in price data by filtering out smaller price movements.</p>"},{"location":"user-guide/transforms/#parameters_1","title":"Parameters","text":"<ul> <li><code>threshold</code>: Minimum percentage change (0.03 = 3%) required to identify a new pivot point (default: 0.03)</li> </ul>"},{"location":"user-guide/transforms/#usage_1","title":"Usage","text":"<pre><code>import numpy as np\nfrom pypulate.transforms import zigzag\nfrom pypulate import Parray\n\n# Real gold (XAU) price data\nprice = [1935.33, 1938.09, 1947.36, 1943.64, 1942.35, 1947.14, 1945.40, 1944.72, 1943.70, 1940.43,\n         1940.04, 1942.55, 1939.70, 1944.20, 1943.68, 1941.12, 1940.10, 1942.96, 1944.50, 1940.95]\np_array = Parray(price)\n\n# Method 1: Using the function directly\nzz = zigzag(price, threshold=0.0005)  # 0.05% threshold for gold which is less volatile\n\n# Method 2: Using Parray method chaining\nzz = p_array.zigzag(threshold=0.0005)  # 0.05% threshold\n</code></pre>"},{"location":"user-guide/transforms/#interpreting-results_1","title":"Interpreting Results","text":"<p>The zigzag transform returns a array with zigzag pivot points.</p>"},{"location":"user-guide/transforms/#example_1","title":"Example","text":"<pre><code>import matplotlib.pylab as plt\n\n# Plot zigzag points and lines\nplt.figure(figsize=(12, 6))\nplt.plot(price, label='Gold Price', alpha=0.7, color='gold')\n\nif zz.size &gt; 0:\n    plt.plot(zz[:, 0], zz[:, 1], 'ro-', linewidth=2, label='ZigZag')\n\nplt.title('ZigZag Pattern Detection on Gold (XAU) Prices')\nplt.xlabel('Time Period')\nplt.ylabel('Price (USD)')\nplt.legend()\nplt.grid(True, alpha=0.3)\nplt.show()\n</code></pre>"},{"location":"user-guide/transforms/#combining-wave-and-zigzag-transforms","title":"Combining Wave and ZigZag Transforms","text":"<p>You can control the wave transform with zigzag as it will filter the mini changes in direction of line by zigzag threshold. This combination is particularly useful for identifying significant wave patterns while filtering out market noise.</p>"},{"location":"user-guide/transforms/#example-filtered-wave-analysis","title":"Example: Filtered Wave Analysis","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom pypulate import Parray\nfrom pypulate.transforms import wave, zigzag\n\n# Sample OHLC data\ndata = {\n    'open': [1936.13, 1935.33, 1938.06, 1947.38, 1943.64, 1942.30, 1947.15, 1945.40, 1944.72, 1943.69,\n             1940.41, 1939.15, 1942.55, 1939.68, 1944.19, 1943.61, 1941.12, 1939.94, 1942.98, 1944.50],\n    'high': [1937.48, 1938.79, 1948.68, 1949.05, 1944.51, 1947.70, 1947.71, 1946.24, 1947.87, 1945.06,\n             1942.03, 1944.03, 1942.61, 1944.45, 1952.94, 1943.61, 1941.34, 1944.02, 1946.06, 1946.32],\n    'low': [1935.16, 1934.91, 1936.62, 1943.12, 1942.04, 1941.94, 1944.43, 1943.19, 1940.27, 1939.03,\n            1939.34, 1938.66, 1938.17, 1938.40, 1940.06, 1934.44, 1939.48, 1939.35, 1942.94, 1940.76],\n    'close': [1935.33, 1938.09, 1947.36, 1943.64, 1942.35, 1947.14, 1945.40, 1944.72, 1943.70, 1940.43,\n              1940.04, 1942.55, 1939.70, 1944.20, 1943.68, 1941.12, 1940.10, 1942.96, 1944.50, 1940.95]\n}\n\n# Convert to numpy arrays\nopen_prices = np.array(data['open'])\nhigh_prices = np.array(data['high'])\nlow_prices = np.array(data['low'])\nclose_prices = np.array(data['close'])\n\n# Step 1: Calculate wave points\nwave_points = wave(open_prices, high_prices, low_prices, close_prices)\n\n# Step 2: Apply zigzag to filter the wave points\n# Create a Parray from wave points to use the zigzag method\nwave_parray = Parray(wave_points)\nfiltered_wave = wave_parray.zigzag(threshold=0.005)  # 0.5% threshold\n\n# Create figure and axis\nfig, ax = plt.subplots(figsize=(12, 6))\n\n# Plot OHLC data as candlesticks\nfor i in range(len(close_prices)):\n    # Plot vertical line from low to high (wick)\n    ax.plot([i, i], [low_prices[i], high_prices[i]], 'k-', alpha=0.3)\n\n    # Determine candle color\n    if close_prices[i] &gt;= open_prices[i]:\n        # Bullish candle (close &gt; open)\n        body_color = 'green'\n    else:\n        # Bearish candle (open &gt; close)\n        body_color = 'red'\n\n    # Plot candle body\n    ax.plot([i, i], [open_prices[i], close_prices[i]], color=body_color, linewidth=4)\n\n# Plot original wave points\nindices = np.arange(len(wave_points))\nax.plot(indices, wave_points, 'b-', linewidth=1, alpha=0.5, label='Wave Points')\n\n# Plot filtered wave points\nif filtered_wave.size &gt; 0:\n    ax.plot(filtered_wave[:, 0], filtered_wave[:, 1], 'ro-', linewidth=2, markersize=5, label='Filtered Wave Points')\n\n# Add labels and styling\nax.set_title('Filtered Wave Pattern Detection with ZigZag')\nax.set_xlabel('Time Period')\nax.set_ylabel('Price')\nax.legend()\nax.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p>This technique provides several benefits:</p> <ol> <li>Noise Reduction: The zigzag transform filters out minor price fluctuations in the wave pattern</li> <li>Trend Identification: Helps identify the true underlying trend by focusing on significant price movements</li> <li>Signal Clarity: Reduces false signals by eliminating small reversals that don't meet the threshold criteria</li> <li>Visualization Enhancement: Creates a cleaner chart that highlights important price levels and potential reversal points</li> <li>Price Action: This method is super useful for detecting price action patterns from price movement maybe better than candlesticks.</li> </ol> <p>You can adjust the threshold parameter to control the sensitivity of the filtering. A higher threshold will result in fewer, more significant pivot points, while a lower threshold will capture more minor price movements. </p>"}]}